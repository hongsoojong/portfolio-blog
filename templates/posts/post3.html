{% extends 'posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(3) C 언어의 기본 문법 2</a>
{% endblock post_title %}

{% block post_content %}

    {% block post_date %}
        <div class="container w-1/2 mx-auto mb-10 post_date">[ Sep 07, 2021 ]</div>    
    {% endblock post_date %}

    <main class="container w-1/2 mx-auto font_kor">
        <div class="post_text">
            <li>C의 함수는 기본적으로 모두 전역(global)함수</li>
            <p class="ml-7">⇒ 즉, C함수는 어디서든 호출할 수 있음! 물론 이걸 제한할 수 있는 키워드는 따로 존재함</p>
            <li>함수의 오버로딩 없음 ⇒ 따라서 함수를 다르게 만들어야 함</li>
            <p class="post_def mb-7">오버로딩 : 함수의 이름은 같고 매가변수의 타입이나 수만 다른 경우</p>
        </div>
        <div>
            <div class="post_heading">함수</div>
            <div class="post_text">
                <li>일종의 작은 프로그램 단위</li>
                <li>지금까지 사용해온 printf()나 scanf()등도 C언어에서 미리 만들어 제공한 함수로, 메인 함수 'main()' 도 프로그램이 실행될 때 처음으로 실행하도록 약속된 함수를 말함</li>
                <li>이처럼 '함수'는 특정한 기능을 하는 코드들을 묶어 하나의 명령어처럼 사용 가능</li>
                <li>기본적으로 이미 만들어서 제공하는 printf() 같은 함수 이외에 새로운 함수를 만들 수도 있음</li>
            </div>
            <div class="post_subheading">함수 선언(function declaration)</div>
            <div class="post_text">
                <li>함수의 구현체 없이 함수 원형(prototype)만 선언해 주는 것</li>
                <p class="ml-7">⇒ 함수의 원형은 다음 사항들을 명시</p>
                <p class="ml-12">1. 함수의 이름</p>
                <p class="ml-12">2. 반환형</p>
                <p class="ml-12">3. 매개변수들의 자료형</p>
            <div class="post_subheading">함수 정의(function definition)</div>
            <div class="post_text">
                <li>실제로 함수를 구현해놓은 것</li>
                <li>함수 정의는 그 자체로 함수 선언이기도 함</li>
            </div>
            <img src="{% static 'img/sourcecode/post3-1.png' %}">
            <div class="post_text">
                <li>함수를 사용하기 전에 그 함수를 선언 (혹은 헤더 파일에)</li>
                <li>C 언어에서는 위에서 아래 방향으로 프로그램이 실행되고, 아래에서 사용할 것들은 반드시 위에서 선언이 되어야함</li>
                <li>하지만 위에 많은 함수들을 선언하게 되면 보기 좋지 못하고, 메인 함수를 찾기 위해 스크롤바를 한참 내려야 할 수도 있음</li>
                <p class="ml-7">⇒ 정방 선언을 통해 함수를 메인 함수 밑으로 내릴 수 있음</p>
            </div>
            <div class="post_subheading">전방 선언</div>
            <img src="{% static 'img/sourcecode/post3-2.png' %}">
            <div class="post_text">
                <li>함수를 사용하기 전에 그 함수를 선언 (혹은 헤더 파일에)</li>
                <li>전방선언의 작동원리</li>
                <p class="ml-7">1. 컴파일러가 함수의 이름과 반환형 그리고 매개변수를 알 수 있음</p>
                <p class="ml-7">2. 실제 어디로 가서 코드를 찾아야하는지 모르니 구멍으로 남겨둠</p>
                <p class="ml-7">3. 컴파일의 다음 단계인 링크(link) 단계에서 실제 코드 위치를 찾아 그 구멍에 메워줌</p>            
            </div>
            <div class="post_subheading text-red-400">int main과 void main</div>
            <div class="post_text">
                <p class="font-bold">< int를 반환하는 main이 표준 문법 ! ></p>
                <li>C 언어 표준 안에서는 void main을 허용하지 않고 int main만 사용이 가능함</li>
                <li>main 함수가 반환하는 값은 해당 프로그램의 종료상태를 의미하는 값으로 사용되기 때문에 종료상태가 없다는 의미인 void main의 형식은 잘못된 형식임</li>
                <li>그렇다면 왜 컴파일러들이 오랜 기간 동안 잘못된 void main을 허용한 것인가 ? 이유는 매우 단순함 (컴파일러를 개발하는 입장에서 개발자가 main 함수의 반환값을 사용하지도 않으면서 return문을 적는 것이 불편할 수도 있다고 판단해서 void main이라는 표현을 추가적으로 제공 ⇒ 즉, 개발자 입장에서 코드를 적게 쓸 수 있도록 도와주기 위해서 void main이라는 문법을 제공한 것)</li>
                <li>컴파일러 입장에서는 void main 함수를 컴파일할 때 내부적으로 int main 함수와 다르게 처리하는 것이 없음 ⇒ void main, int main은 동일하게 처리가 됨</li>
                <li>하지만 최근 컴파일러를 하나로 통합하려는 시도를 하고 있는 많은 컴파일러 회사들이 이 노력에 동참하고 있으며, 비표준화된 void main 함수 또한 사라지고 있는 추세로 앞으로 C 프로그래밍을 할 때 void main을 사용하면 오류가 나는 컴파일러는 늘어날 것임</li>
            </div>
            <div class="post_heading">함수 매개변수/피연산자 평가순서</div>
            <div class="post_subheading">함수 매개변수 평가순서</div>
            <img src="{% static 'img/sourcecode/post3-3.png' %}">
            <div class="post_text">
                <li>표준에 따르면, 함수 매개변수의 평가순서는 명시되지 않음 (<span class="font-bold">unspecified</span>)</li>
                <p class="ml-7">⇒ 즉, 컴파일러에 따라 평가 순서가 달라질 수 있음</p>
                <li>하지만 printf(()가 실제로 실행되기 전에 add()와 substract()가 모두 호출된다는 것은 보장</li>
            </div>
            <div class="post_subheading">피연산자 평가순서</div>
            <img src="{% static 'img/sourcecode/post3-4.png' %}">
            <div class="post_text">
                <li>역시나 find_next_dungeon()이 먼저 호출된다는 보장이 없음 ⇒ 역시나 평가순서가 명시되지 않음</li>
                <li>한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하면 안됨</li>
                <li>해법 : 두 함수를 두줄에 따로 호출 할 것!!</li>
            </div>
            <div class="post_subheading">Undefined behavior(결과가 정의되지 않음)</div>
            <img src="{% static 'img/sourcecode/post3-5.png' %}">
            <div class="post_text">
                <li>기본적으로 한 줄에 동일한 변수를 여러 번 바꾸면 위험 ⇒ 함수 매개변수의 평가순서는 컴파일러마다 다를 수 있음</li>
                <p class="ml-7">1. 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음</p>
                <p class="ml-7">2. 한 줄에서 같은 변수를 여러 번 수정하면 정의되지 않은 결과</p>
                <div class="post_def">
                    <p>unspecified : 위험하지는 않지만 컴파일러에 따라 결과가 다를 수 있음</p>
                    <p>undifined: 위험함! 무슨 일이 일어날지 모름</p>
                </div>
                <img src="{% static 'img/sourcecode/post3-6.png' %}" class="ml-7">
            </div>
        </div>
        <div>
            <div class="post_heading">연산자 우선순위와 평가순서</div>
            <img src="{% static 'img/sourcecode/post3-7.png' %}">
            <div class="post_text">
                <li>연산자 우선순위와 평가순위는 서로 아무런 연관이 없음 ⇒ add(), substract(), divide()의 평가순서는 알 수 없음</li>
                <li>함수 호출(평가)의 순서는 알 수 없으나, 최종적으로 연산이 이루어질땐 곱셈이 먼저 이루어짐</li>
            </div>
            <div class="post_subheading">&&와 ||는 평가순서를 강제하는 연산자</div>
            <img src="{% static 'img/sourcecode/post3-8.png' %}">
            <div class="post_text">
                <li>논리연산자 &&와 ||의 경우 왼쪽 피연산자를 먼저 실행함</li>
                <p class="ml-7">⇒ 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할 수도 있음</p>
                <img src="{% static 'img/sourcecode/post3-9.png' %}" class="ml-7">
            </div>
            <div class="post_heading">평가순위 정리</div>
            <div class="post_text">
                <li>한 줄에 있는 피연산자들은 기본적으로 평가순서가 보장 안됨</li>
                <li>&&와 || 정도만 됨 (short circuit, sequence point    )</li>
                <li>추가적으로 삼항(?:)도 평가순서가 보장됨 ⇒ if/else를 줄여 써 놓은 것이라고 생각하면 됨</li>
                <li>함수를 실제 실행하기 전에 모든 매개변수와 ;은 우선 평가 됨 ⇒ 이건 너무나도 당연한 내용!</li>
            </div>
        </div>
        <div>
            <div class="post_heading">범위(scope) - 블록 범위 / 파일 범위 / 함수 범위 / 함수 선언 범위</div>
            <div class="post_text">
                <p class="-ml-3">총 4가지의 범위로 분류할 수 있음</p>
                <p>1. 블록 범위</p>
                <p>2. 파일 범위</p>
                <p>3. 함수 범위</p>
                <p>4. 함수 선언 범위</p>
            </div>
            <div class="post_subheading">블록 범위</div>
            <div class="post_text">
                <li>중괄호({}) 안에 선언한 것들은 그 블록 안에서만 사용 가능</li>
                <li>블록 안에 또다른 블록을 넣을 수도 있음 ⇒ 그러면 안쪽 블록은 바깥 블록에 접근 가능, 그 반대는 안됨</li>
            </div>
            <div class="post_subheading">블록 범위와 변수 선언 위치</div>
            <img src="{% static 'img/sourcecode/post3-10.png' %}">
            <div class="post_text">
                <li>함수 중간에 블록을 열고 변수 선언 가능</li>
                <li>함수 시작 지점에서 모든 변수를 선언하면 실수할 여지가 없음</li>
                <p class="ml-7">⇒ 하지만 정확하게 어느 지점에서 사용하는 변수인지 파악 불가능</p>
                <p class="ml-12">중간에 그 값이 바뀔 수도 있음</p>
                <li>블록을 이용해서 함수 중간에 선언하는 것도 하나의 방법임</li>
            </div>
            <div class="post_subheading">파일 범위</div>
            <img src="{% static 'img/sourcecode/post3-11.png' %}">
            <div class="post_text">
                <li>어떤 블록이나 매개변수 목록에도 안 속하고, 파일 안에 있는 것 (translation unit)</li>
                <li>파일 범위에 있는 변수</li>
                <p class="ml-7">- 다른 소스 파일에서 링크 가능</p>
                <p class="ml-7">- 프로그램 실행동안 공간을 차지</p>
                <p class="ml-7">⇒ 즉, 스택 메모리에 들어가는 것이 아니라 데이터 섹션에 들어감</p>
                <li>이게 바로 전역변수!</li>
            </div>
            <div class="post_subheading">함수 범위</div>
            <div class="post_text">
                <li>유일한 예 : 레이블(label)</li>
                <li>goto문</li>
                <li>함수 안에서 선언된 레이블은 함수 어디에서라도 접근 가능</li>
                <p class="ml-7">⇒ 다른 범위들은 위에서 이미 선언된 것만 접근이 가능했음</p>
            </div>
            <div class="post_subheading">함수 선언 범위</div>
            <img src="{% static 'img/sourcecode/post3-12.png' %}">
            <div class="post_text">
                <li>함수 선언의 매개변수 목록에 있는 것은 그 목록 안에서 접근 가능</li>
                <li>많이 쓸 일은 없음</li>
            </div>
        </div>
        <div>
            <div class="post_heading">const</div>
            <img src="{% static 'img/sourcecode/post3-13.png' %}">
            <div class="post_text">
                <li>이름 달린 상수를 만들어주기 좋음 ⇒ 개발자의 실수를 막아줄 수 있는 KEY</li>
                <li>기본적으로 모든 변수에 const를 붙이는 것이 좋음</li>
                <li>정말 값 변경이 필요한 변수에만 const를 생략</li>
            </div>
        </div>
        <div>
            <div class="post_heading">goto문</div>
            <div class="post_text">
                <li>C는 위에서 아래로 순차적으로 코드를 실행함</li>
                <li>goto를 쓰면 순서를 어기고 다음에 실행할 코드를 마음대로 지정 가능</li>
                <p class="ml-7">⇒ 같은 함수 내에 있는 label로 점프함</p>
            </div>
            <div class="post_subheading">goto문과 while문</div>
            <img src="{% static 'img/sourcecode/post3-14.png' %}" class="mb-6">
            <div class="post_subheading">goto문과 do-while문</div>
            <img src="{% static 'img/sourcecode/post3-15.png' %}" class="mb-6">
            <div class="post_subheading">반복문은 결국 goto를 사용하는 코드</div>
            <div class="post_text">
                <li>어셈블리어는 반복문이란게 없음</li>
                <li>원래 어셈블리어 프로그래밍을 하다가 C로 넘어온거라 초기엔 goto문을 많이 썼음</li>
                <li>당연히 이보다 안전한 방법이 보통의 반복문을 쓰는 것</li>
                <p class="ml-7">⇒ 이건 명백한 사실이라 누구나 동의, 따라서 goto를 자주 쓰지는 않음</p>
            </div>
            <div class="post_subheading">goto는 정말로 악마인가?</div>
            <div class="post_text">
                <li>물론..</li>
                <li>goto를 난잡하게 사용하게 되면 코드가 이리 뛰고 저리 뛰고 꼬이게 됨</li>
                <li>이러한 코드를 스파게티 코드라고 부름 (아주 꼬임)</li>
                <li>이로 인해 코드를 쓰고 읽는데 실수가 발생하게 됨</li>
            </div>
            <div class="post_subheading">허나 goto가 늘 악마인 것은 아님!</div>
            <div class="post_text">
                <p class="ml-3 font-bold">< 경우 1 ></p>
                <p class="ml-7">goto없이 안쪽 for문에서 탈출하려면 쓸데없이 if문을 여러 개 써야함</p>
                <p class="ml-7">[ goto를 안 쓰는 3중 for문 ]</p>
                <img src="{% static 'img/sourcecode/post3-16.png' %}" class="ml-7">
                <p class="ml-7">[ goto를 쓰는 3중 for문 ]</p>
                <img src="{% static 'img/sourcecode/post3-17.png' %}" class="ml-7 mb-6">
                <p class="ml-3 font-bold">< 경우 2 ></p>
                <img src="{% static 'img/sourcecode/post3-18.png' %}" class="ml-7">
                <li class="ml-7">poto없이 쓰려면 bool 변수를 하나 만들어서 계속 검사를 진행해야함</li>
                <img src="{% static 'img/sourcecode/post3-19.png' %}" class="ml-7">
                <li class="ml-7">물른 early exit을 해도 됨 ⇒ 하지만 오류를 처리하는 코드들이 if문 안에 반복되어 사용</li>
                <li class="ml-7">오류를 처리하는 코드를 함수로 만들어됨 ⇒ 하지만 한 군데서만 쓰는 코드를 함수로 만드는 것은 유지/보수 문제를 유발하기도 함</li>
                <img src="{% static 'img/sourcecode/post3-20.png' %}" class="ml-7">
                <li class="ml-7  mb-6">goto를 쓰면 해결됨</li>
                <p class="ml-3 font-bold">< 경우 3 ></p>
                <p class="ml-7">로버트 러브(Robert Love)가 리눅스 커널 관련 토론에서 사랑을 담아 댓글로 남긴 goto 활용법</p>
                <img src="{% static 'img/sourcecode/post3-21.png' %}" class="ml-7">
                <li class="ml-7">중간에 에러가 나면 이미 수행한 작업을 되돌림</li>
                <li class="ml-7">A만 수행했다면 A만 되돌리고, A > B를 수행했다면 B > A 순으로 되돌림</li>
            </div>
            <div class="post_subheading">goto문의 BEST PRACTICES</div>
            <div class="post_text">
                <li>goto문은 언제나 전방(아래쪽)으로만 점프할 것</li>
                <p class="ml-7">⇒ 후방(위)으로만 점프하면 스파게티처럼 코드가 꼬이기 쉬움</p>
                <li>내포된(nested) 루프에서 빠져나올 때는 자유로이 쓸 것</li>
                <li>한 함수 안에 있는 여러 개의 조건문이 공통된 코드로 실행해야할 때도 써도 됨</li>
                <p class="ml-7">⇒ 예 : 함수 마지막에 성공 / 오류 조건 처리</p>
            </div>
        </div>
        <div>
            <div class="post_heading">배열</div>
            <img src="{% static 'img/sourcecode/post3-22.png' %}">
            <div class="post_text">
                <li>C#과 달리 new를 반드시 사용할 필요가 없음</li>
            </div>
            <div class="post_heading">스택 메모리</div>
            <div class="flex justify-center">
                <table class="mb-6 w-1/2 table-fixed">
                    <tbody class="text-center">
                      <tr>
                        <td class="post_table_border">스택</td>
                      </tr>
                      <tr>
                        <td class="post_table_border">힙</td>
                      </tr>
                      <tr>
                        <td class="post_table_border">데이터</td>
                      </tr>
                      <tr>
                        <td class="post_table_border">코드</td>
                      </tr>
                      <tr>
                        <td class="font-bold">C의 메모리</td>
                      </tr>
                    </tbody>
                </table>
            </div>
            <div class="post_text">
                <li>C는 스택 메모리 덕분에 값형으로도 배열을 만들 수 있음</li>
                <li>우선 자료구조인 스택이랑 헷갈리지 말 것 ⇒ 둘 다 작동방법이 동일해서(LIFO; last in first out) 스택이란 이름을 쓸 뿐</li>
                <li>각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간</li>
                <li>스택 메모리의 크기는 프로그램 빌드 시에 결정됨</li>
                <li>스택 메모리의 위치는 실행 시에 결정 됨</li>
                <li>함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가 그 함수가 반환하면 그냥 지워버리는 개념 (실제 지우진 않음)</li>
            </div>
            <div class="post_subheading">기본 자료형 변수는 스택 메모리를 차지!</div>
            <div class="post_text">
                <li>여태까지 모든 기본형 변수(char, int, float)를 new 없이 사용할 수 있었던 이유가 바로 스택 메모리에 할당됬기 때문</li>
                <li>기본 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듦 ⇒ 이것이 바로 값형</li>
                <li>스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여있음</li>
                <li>new로 만든 데이터는 힙(heap) 메모리에 할당됨 ⇒ 이 경우 메모리에 구멍이 뚫릴 수 있음 </li>
            </div>
            <div class="post_subheading">배열의 요소 개수를 구하는 방법</div>
            <img src="{% static 'img/sourcecode/post3-23.png' %}" class="mb-6">
            <div class="post_subheading">sizeof(매개변수)와 배열의 총 바이트 수</div>
            <img src="{% static 'img/sourcecode/post3-24.png' %}">
            <div class="flex justify-center my-4">
                <table class="w-2/3 table-fixed ml-7">
                    <tbody class="text-center">
                      <tr>
                        <td class="post_table_border">10</td>
                        <td>지역 변수 1</td>
                      </tr>
                      <tr>
                        <td class="post_table_border bg-yellow-100">2</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td class="post_table_border bg-yellow-100">3</td>
                        <td>지역 변수 2 (배열)</td>
                      </tr>
                      <tr>
                        <td class="post_table_border bg-yellow-100">4</td>
                        <td ></td>
                      </tr>
                      <tr>
                        <td class="post_table_border border-4 border-red-600 bg-yellow-100">2</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td class="post_table_border border-4 border-red-600 bg-yellow-100">3</td>
                        <td>지역 변수 2가 함수의 매개변수</td>
                      </tr>
                      <tr>
                        <td class="post_table_border border-4 border-red-600 bg-yellow-100">4</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td class="post_table_border">10</td>
                        <td>지역 변수 1이 함수의 매개변수</td>
                      </tr>
                      <tr>
                        <td class="post_table_border py-5">호출된 함수의 스택 프레임 생략</td>
                        <td></td>
                      </tr>
                    </tbody>
                </table>
            </div>
            <div class="post_text">
                <li>sizeof()가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면</li>
                <p class="ml-7">1. 그 배열의 모든 요소가 스택에 다 복사되어 전달되어야 함</p>
                <p class="ml-7">2. 그리고 호출되는 모든 함수는 스택에 복사된 모든 요소의 크기를 정확히 알아야함</p>
            </div>
            <div class="post_subheading">함수의 스택 메모리 사용량은 고정</div>
            <div class="post_text">
                <li>함수는 호출자가 누구든 간에 딱 정해진 수와 크기의 매개변수가 들어온다는 가정으로 동작</li>
                <li>함수가 먼저 결정되고, 호출자는 그 함수를 호출할 뿐</li>
            </div>
            <div class="post_subheading">sizeof(매개변수)가 4를 반환한 이유는?</div>
            <img src="{% static 'img/sourcecode/post3-25.png' %}">
            <div class="flex justify-center my-4">
                <table class="w-2/3 table-fixed ml-7">
                    <tbody class="text-center">
                      <tr>
                        <td class="post_table_border">2</td>
                        <td>0x0004E200</td>
                      </tr>
                      <tr>
                        <td class="post_table_border">3</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td class="post_table_border">4</td>
                        <td></td>
                      </tr>
                      <tr>
                        <td class="post_table_border border-4 border-red-600 bg-yellow-100">0x0004E200</td>
                        <td ></td>
                      </tr>
                      <tr>
                        <td class="post_table_border py-5">호출된 함수의 스택 프레임 생략</td>
                        <td></td>
                      </tr>
                    </tbody>
                </table>
            </div>
            <div class="post_text">
                <li>배열을 매개변수로 전달할 떄는 실제 모든 요소를 스택에 넣진 않음</li>
                <li>그 대신 그 배열의 시작 위치(주소)를 스택에 넣어줌</li>
                <p class="ml-7">- 이 주소의 크기 = 포인터 데이터형의 크기</p>
                <p class="ml-7">- 32비트 플랫폼에서는 3바이트, 64비트 플랫폼에서는 8바이트</p>
                <p class="ml-7">그래서 sizeof()를 하면 4바이트가 나옴</p>
            </div>
            <div class="post_subheading">길이가 명시된 매개변수 배열</div>
            <img src="{% static 'img/sourcecode/post3-26.png' %}">
            <div class="post_text">
                <li>위와 같은 코드는 길이가 5인 배열을 넣은 것이 아닌가?</li>
                <p class="ml-7">⇒ 이는 단순히 프로그래머가 읽기 편하기 위해 [5]를 써준 것</p>
                <p class="ml-12">컴파일을 진행하면 void process(int nums[])와 동일</p>
                <li>원본 배열의 변화 ⇒ 위 코드는 복사본이 아니라 원본을 바꿈</li>
                <p class="ml-7">- 어떤 사람들은 이것을 원본을 바꾸기 때문에 '참조에 의한 호출'이라 함</p>
                <p class="ml-7">- 어떤 사람들은 이것을 위치를 바꾸기 떄문에 '값에 의한 호출'이라 함</p>
                <p class="ml-7">- 어떤 사람들은 이것을 C는 참조에 의한 호출이 없고 그냥 주소를 전달하는 방법을 통해 '참조에 의한 호출을 시뮬레이션 하는 방법'이라고도 말함</p>
                <p class="ml-7">- 중요하지 않음 : 원본이 바뀐다는 사실만 알면 됨</p>
                <div class="flex justify-center my-4">
                    <table class="w-2/3 table-fixed ml-7">
                        <tbody class="text-center">
                          <tr>
                            <td class="post_table_border border-4 border-red-600 bg-yellow-100">0</td>
                            <td>0x000dcf984</td>
                          </tr>
                          <tr>
                            <td class="post_table_border border-4 border-red-600 bg-yellow-100">2</td>
                            <td></td>
                          </tr>
                          <tr>
                            <td class="post_table_border border-4 border-red-600 bg-yellow-100">4</td>
                            <td></td>
                          </tr>
                          <tr>
                            <td class="post_table_border border-4 border-red-600 bg-yellow-100">6</td>
                            <td></td>
                          </tr>
                          <tr>
                            <td class="post_table_border border-4 border-red-600 bg-yellow-100">8</td>
                            <td></td>
                          </tr>
                          <tr>
                            <td class="post_table_border">0x000dcf984</td>
                            <td ></td>
                          </tr>
                          <tr>
                            <td class="post_table_border">5</td>
                            <td></td>
                          </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="post_subheading">매개변수 배열의 길이를 알 수 있는 방법 : 없음!!</div>
            <div class="post_text">
                <li>배열 자체에서 크기를 알아올 수 있는 방법은 없음</li>
                <p class="ml-7">예외 : 앞서 설명한 ARRAY_LENGTH() 꼼수(매크로)를 쓸 경우</p>
                <p class="ml-7">즉, 배열의 크기는 따로 기억해둬야 함</p>
                <img src="{% static 'img/sourcecode/post3-27.png' %}" class="ml-7">
            </div>
            <div class="post_subheading">배열 요소의 초깃값</div>
            <div class="post_text">
                <li>C는 배열 요소의 값을 초기화해주지 않음</li>
                <li>따라서 그 전에 그 메모리에 남아있던 값을 그대로 사용 (변수도 마찬가지)</li>
                <img src="{% static 'img/sourcecode/post3-28.png' %}" class="ml-7">
            </div>
            <div class="post_subheading">배열 요소의 초기화</div>
            <img src="{% static 'img/sourcecode/post3-29.png' %}" class="mb-6">
            <div class="post_subheading">배열 요소의 초기화 : BEST PRACTICE</div>
            <img src="{% static 'img/sourcecode/post3-30.png' %}">
            <div class="post_text">
                <li>배열의 모든 값을 0으로 초기화</li>
                <li>0 뒤에 쉼표</li>
                <li>이를 통해 초기화 목록이 모든 값을 직접 초기화해주지는 않지만 쉼표 뒤가 모두 0으로 초기화 됨</li>
                <li>초기화를 제대로 진행하지 않는다면 초기화 안된 지역변수를 모른 채 사용할 수 있으며, 버퍼 오버플로도 가능 ⇒ 버퍼 오버플로를 아무도 체크해주지 않음</li>
            </div>
            <div class="post_heading">다차원 배열 (2차원, 3차원 배열)</div>
            <img src="{% static 'img/sourcecode/post3-31.png' %}" class="mb-6">
            <img src="{% static 'img/sourcecode/post3-32.png' %}" class="mb-6">
            <div class="post_subheading">1차원 vs 2차원 vs 3차원</div>
            <img src="{% static 'img/sourcecode/post3-33.png' %}" class="border border-black mb-2">
            <div class="post_text">
                <li>1차원 배열</li>
                <p class="ml-7 font-bold">int nums1[2];</p>
                <p class="ml-7 font-bold">⇒ { 1, 2 }</p>
                <table class="w-2/3 table-fixed ml-7">
                    <tbody class="text-center">
                      <tr>
                        <td class="post_table_border">1</td>
                        <td class="post_table_border">2</td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                      </tr>
                    </tbody>
                </table>
                <li>2차원 배열 : 1차원 배열들의 모임 [y][x]</li>
                <p class="ml-7 font-bold">int nums2[2][3];</p>
                <p class="ml-7 font-bold">⇒ { { 1, 2, 3}, { 4, 5, 6} }</p>
                <table class="w-2/3 table-fixed ml-7">
                    <tbody class="text-center">
                      <tr>
                        <td class="post_table_border">1</td>
                        <td class="post_table_border">2</td>
                        <td class="post_table_border">3</td>
                        <td class="post_table_border">4</td>
                        <td class="post_table_border">5</td>
                        <td class="post_table_border">6</td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                      </tr>
                    </tbody>
                </table>
                <li>3차원 배열 : 2차원 배열들의 모임 [z][y][x]</li>
                <p class="ml-7 font-bold">int nums3[2][3][2];</p>
                <p class="ml-7 font-bold">⇒ { { { 1, 2 }, { 3, 4 }, { 5, 6 } }, { { 7, 8 }, { 9, 10 }, { 11, 12 } } }</p>
                <table class="w-2/3 table-fixed ml-7">
                    <tbody class="text-center">
                      <tr>
                        <td class="post_table_border">1</td>
                        <td class="post_table_border">2</td>
                        <td class="post_table_border">3</td>
                        <td class="post_table_border">4</td>
                        <td class="post_table_border">5</td>
                        <td class="post_table_border">6</td>
                        <td class="post_table_border">7</td>
                        <td class="post_table_border">8</td>
                        <td class="post_table_border">9</td>
                      </tr>
                      <tr>
                        <td class="post_table_border">10</td>
                        <td class="post_table_border">11</td>
                        <td class="post_table_border">12</td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                        <td class="post_table_border"></td>
                      </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </main>
{% endblock post_content %}