{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(10) 레지스터, 스택 & 힙, 동적 메모리. 다중 포인터</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 29, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="ca7e927f-5ec3-4d6e-a446-e9ca82f2ac3b" class="page sans"><div class="page-body"><ul id="cef8a9f2-d86b-4dd2-9aae-29689e3d3dc8" class="bulleted-list"><li style="list-style-type:disc">컴퓨터는 한 덩어리의 완전체가 아니라 다양한 부품으로 구성</li></ul><ul id="853fa1b9-8b57-48fa-bd51-420c8bc3b785" class="bulleted-list"><li style="list-style-type:disc">CPU, 메모리, 하드 디스크, SSD 등</li></ul><h3 id="8b263f8a-acd6-4225-8a19-d7a3faf80051" class="">프로그램에서 주로 사용하는 부품</h3><p id="9fa45b0e-62fb-432f-bbe1-21113dda3c01" class="">⇒ 이 중 프로그램에서 주로 사용하는 부품은 2개</p><p id="e0bff890-4a8f-4c3c-acaa-12fc63161ef3" class="">1) CPU</p><ul id="bd05847a-d0c5-457b-9809-61c60e8c16b3" class="bulleted-list"><li style="list-style-type:disc">모든 코드의 로직(연산)을 실행하는 제어 장치</li></ul><ul id="0946d576-fae8-4f9b-a18c-56db961e0972" class="bulleted-list"><li style="list-style-type:disc">컴퓨터에서 가장 핵심적인 <strong>두뇌</strong>라고 할 수 있음</li></ul><p id="515d6e0a-ce34-4be2-af7f-59ae1e3cfdf6" class="">2) 메모리</p><ul id="95e4300b-96a5-464f-8de5-26a5543a6653" class="bulleted-list"><li style="list-style-type:disc">실행 중인 코드 및 연산의 중간 결과 등을 저장하는 공간</li></ul><ul id="cfa1042f-2b64-464b-86f0-4791ee6328f3" class="bulleted-list"><li style="list-style-type:disc">변수나 배열 등에 대입되는 데이터가 저장됨</li></ul><ul id="2071da2d-b53c-4342-9933-69e868a724f0" class="bulleted-list"><li style="list-style-type:disc">무언가를 &#x27;적어둔다&#x27;는 점에서 <strong>공책 또는 메모장</strong> 같다고 할 수 있음</li></ul><h2 id="67ec1a94-da86-48d5-8d96-7dfbf82f87f1" class="">메모리</h2><ul id="460b1caf-6e66-452c-a3c0-08511b9ab32b" class="bulleted-list"><li style="list-style-type:disc">그램 실행 중에 여러 데이터가 공유하는 메모리는 둘로 나눔<p id="6caa5e1a-9b8f-45b0-8cc0-6e666e68d98e" class="">1) 스택(stack) 메모리</p><p id="49a1e0c7-88e8-48b6-8fc7-381e3e082340" class="">2) 힙(heap) 메모리</p></li></ul><ul id="b6ab3e72-a5d2-4eb1-9097-a8ff9f5d7613" class="bulleted-list"><li style="list-style-type:disc">사실상 이 둘은 물리적으로 같은 메모리</li></ul><ul id="72b41c0b-5fa5-41ae-bf12-b98b9ec94f52" class="bulleted-list"><li style="list-style-type:disc">이 외에 데이터 섹션, 코드 섹션 등도 있으나 그건 특정 코드 및 데이터용으로 고정</li></ul><hr id="d91514af-c9b0-49af-aaa0-05e3fa90c5bd"/><p id="7cb0022d-f853-43ca-a78a-5c92e197bf5a" class=""><strong>기본은 힙 메모리</strong></p><ul id="5526d0d9-49b7-4856-8938-7698e48a6b90" class="bulleted-list"><li style="list-style-type:disc">힙 메모리가 범용적인 기본 형태</li></ul><p id="a5e8de33-6abf-4e52-b5f4-e9427bf2c557" class=""><strong>스택 메모리는 특별한 용도를 가진 메모리</strong></p><ul id="5c335c6e-6e4e-420f-880a-8ba2a5fa5443" class="bulleted-list"><li style="list-style-type:disc">프로그램마다 특별한 용도에서 사용하라고 별도로 뗴어놔 준 것<ul id="d86901ae-6b37-462a-91cb-dd5dfc1e681d" class="bulleted-list"><li style="list-style-type:circle">엄밀히 말하면 프로그램마다가 아니라 그 프로그램의 thread마다</li></ul></li></ul><p id="156c20f8-3d4a-4ee0-ae7f-06aaff60d99a" class=""><strong>CPU 안에도 저장 공간이 있음</strong></p><ul id="16414bbf-82e1-440a-ba45-1af3b6ba9fff" class="bulleted-list"><li style="list-style-type:disc">레지스터 : CPU에서만 사용할 수 있는 <strong>고속</strong> 저장 공간</li></ul><ul id="431baf73-4f60-4862-9b86-58a4aeadf67a" class="bulleted-list"><li style="list-style-type:disc">엄밀한 의미의 메모리는 아님</li></ul><hr id="7cca6e9e-91ab-4920-83fa-181553bbb9ed"/><h2 id="ff677353-548b-43bd-b485-35af937c28b8" class="">스택 메모리</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="126e211f-6358-40ff-99d9-273cedcaa920"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>스택 메모리(정적 메모리)는 특별한 용도를 가진 메모리이다. 프로그램마다 특별한 용도에서 사용하라고 별도로 할당하는 영역이다. 이에 따라 컴파일시 그 메모리 크기가 결정된다. 함수를 호출할 때 지역변수와 매개변수들이 저장되는 공간으로, 메인 함수 안에서의 변수들도 당연히 포함된다. 함수가 종료되면 해당 함수에 할당된 변수들은 메모리에서 해제된다. 스택은 높은 주소에서 낮은 주소 방향으로 채워지며, 함수의 재귀가 깊어 질 경우 stack 영역을 넘어 stack overflow가 발생할 수 있다.</strong></div></figure><ul id="c74e220c-558a-4aa5-b1c6-02ac840666e5" class="bulleted-list"><li style="list-style-type:disc">스택이 채워지는 방향 : 높은 주소 → 낮은 주소</li></ul><ul id="fe8c0323-d930-4889-a1ec-d89cf435e93f" class="bulleted-list"><li style="list-style-type:disc">함수를 호출할 때 스택에 정확히 어떤 게 어떤 순서로 들어가는지는 함수 호출 규약(calling convention)에 따라 달라짐</li></ul><h2 id="a5300031-aff6-48ad-9030-7ff1fbe73b63" class="">레지스터</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3371b01b-45f8-4376-8366-331ee1c91a3a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>레지스터는 휘발성 데이터 자장공간으로, CPU 안에 있는 가장 빠른 저장 공간(SRAM)이다. CPU가 연산을 할 때 보통 레지스터에 저장되어 있는 데이터를 사용한다. 그 연산결과도 레지스터에 다시 저장하는 것이 보통이다. 레지스터는 흔히 말하는 &#x27;메모리&#x27;는 아니다.</strong></div></figure><ul id="d0ba8bd6-25b5-4536-b47c-6e1c4aa4d00d" class="bulleted-list"><li style="list-style-type:disc">휘발성 데이터 저장공간 (컴퓨터를 껐다가 켜면 사라짐)</li></ul><ul id="20fe09c8-240a-48c2-b46e-9de4bbca3c53" class="bulleted-list"><li style="list-style-type:disc">메모리는 아님!</li></ul><ul id="9236abad-1d63-4c47-9981-d0dd68b8734f" class="bulleted-list"><li style="list-style-type:disc">레지스터가 있는 이유<p id="d3850875-553c-4725-b261-f32f8d0f7e91" class="">⇒ 앞에서 CPU는 뇌, 메모리는 공책이라고 했음. 머릿속에서 생각한 것을 공책에 옮겨적으려면 시간이 걸리듯이 CPU가 생각한 것을 메모리에 적거나 그로부터 읽을 때도 시간이 걸림</p></li></ul><h3 id="28cdcc39-a861-46ea-a178-32355563f698" class=""><strong>메모리를 읽고 쓰는게 느린 이유</strong></h3><p id="6b6b16f2-24bd-4596-9ece-5bee0184d669" class="">1) CPU가 메모리에 접근할 때마다 버스에 타야함</p><ul id="a7d45265-2955-4664-80fe-3273671a92e5" class="bulleted-list"><li style="list-style-type:disc">즉, CPU가 연산할 때마다 메모리에 접근하는 시간이 발생함<ul id="73e00cd4-f370-44d3-a706-60ac101ded32" class="bulleted-list"><li style="list-style-type:circle">버스가 크면 한번에 많이 읽어오겠지만, 메모리가 낭비가 생기고</li></ul><ul id="773ae006-0c10-4e42-99a6-bac46c255233" class="bulleted-list"><li style="list-style-type:circle">버스가 작으면 메모리 낭비는 적을 수 있겠지만, 여러 번 왔다갔다 할 수 있음</li></ul></li></ul><p id="5623f8b6-7a65-482f-b00f-8b1f3ccafb33" class="">2) 대부분 컴퓨터에 장착하는 메모리는 DRAM(Dynamic Random Access Memory)임</p><ul id="ab733633-721d-43b2-920e-b6d110c3bc73" class="bulleted-list"><li style="list-style-type:disc">DRAM은 가격이 저렴한 대신 한가지 큰 단점이 있음<ul id="29056db3-f98c-4fb6-a179-836d81d3e124" class="bulleted-list"><li style="list-style-type:circle">기록된 내용을 유지하기 위해서 주기적으로 정보를 다시 써줘야함</li></ul><ul id="8bc2eef5-4aeb-4165-8f26-5dca84e7ba1b" class="bulleted-list"><li style="list-style-type:circle">다시 쓰는 동안 또 시간을 소모</li></ul></li></ul><ul id="21321484-10e8-4f4f-a1c0-7d3e44da5801" class="bulleted-list"><li style="list-style-type:disc">이러한 단점이 없는 메모리로 SRAM(Static RAM)이 있지만, 비용이 매우 비싸며, 이걸 몇 기가나 달기에는 좀 부담스러움 </li></ul><h3 id="f4eb0dbb-ec07-4fd2-b880-c9f0829d72a9" class="">비용은 저렴하지만 속도가 빠른 컴퓨터</h3><ul id="437180a8-4283-4702-8689-1abfe17962a9" class="bulleted-list"><li style="list-style-type:disc">SRAM을 CPU와 메모리 사이에 두는 방법을 고안함<ul id="ae462a3f-c206-4945-a750-08aa6beed845" class="bulleted-list"><li style="list-style-type:circle">단, 너무 비싸니 매우 적은 용량만</li></ul><ul id="7270ec8d-931d-4a6d-af81-b5c87b6be7e9" class="bulleted-list"><li style="list-style-type:circle">일반적인 SRAM하고는 조금 다름</li></ul></li></ul><ul id="857670b3-1cac-4ded-b6ff-1f671a238bdf" class="bulleted-list"><li style="list-style-type:disc">CPU랑 가까이 두고 싶어서 아예 <strong>CPU 안에</strong> 넣어버림</li></ul><ul id="00a75866-983c-4d3d-a9e5-a747de2bf8d2" class="bulleted-list"><li style="list-style-type:disc">그것이 바로 <strong>레지스터</strong></li></ul><h3 id="45f56d86-5126-46cc-bb9d-e4887f52dfef" class="">레지스터</h3><ul id="0002aff9-5699-4b64-b9fb-322c4d3bc681" class="bulleted-list"><li style="list-style-type:disc">레지스터는 CPU가 사용하는 저장 공간 중에 가장 빠른 저장 공간</li></ul><ul id="33ff86d1-fb2e-4937-b471-33d97d733d63" class="bulleted-list"><li style="list-style-type:disc">CPU가 연산을 할 때 보통 레지스터에 저장되어 있는 데이터를 사용</li></ul><ul id="8e0a8d87-ef20-4686-943e-e788d9d175dd" class="bulleted-list"><li style="list-style-type:disc">그 연산결과도 레지스터에 다시 저장하는게 보통임</li></ul><ul id="e21b0c1d-397a-4981-84b6-2ff215be72a2" class="bulleted-list"><li style="list-style-type:disc">다시 한번 강조하자면, 레지스터는 흔히 말하는 &#x27;메모리&#x27;가 아님<p id="a6e7fcfc-e2dd-4704-957e-671700140311" class="">⇒ CPU가 레지스터에 접근하는 방법과 메모리 접근하는 방법은 다른게 보통임</p></li></ul><h3 id="87bed846-e19e-4c0d-b25c-39c9b847fdbd" class="">어셈블리어로 보는 레지스터</h3><ul id="89f6ded8-c035-4e17-bcd2-bdd6de4f0cac" class="bulleted-list"><li style="list-style-type:disc"><code>ebp</code>, <code>esp</code>, <code>eax</code>, <code>ecx</code> : 모두 다 레지스터</li></ul><p id="c571a951-6b25-41bc-a314-816cc0495c93" class=""><strong>&lt;x86 아키텍쳐에서 사용하는 레지스터&gt;</strong></p><ul id="52b05a6d-1a2c-444f-98a8-cdfe266cbc53" class="bulleted-list"><li style="list-style-type:disc">8개의 범용 레지스터(general-purpose register)<ul id="03806a78-7248-4a48-9d7f-b5f46b86f886" class="bulleted-list"><li style="list-style-type:circle">ESP, EBP, EAX, EBX, ECX, EDX 등등</li></ul></li></ul><ul id="a03c42f2-82ad-4355-a812-2cfec7052d99" class="bulleted-list"><li style="list-style-type:disc">6개의 세그먼터 레지스터(segment register)</li></ul><ul id="6dfb06ab-fb03-44de-8cf2-e4b9da15cf81" class="bulleted-list"><li style="list-style-type:disc">1개의 플래그 레지스터(flags register)</li></ul><ul id="6ac04e3f-2a01-4733-a681-6fd0038a8634" class="bulleted-list"><li style="list-style-type:disc">1개의 명령어 포인터(instruction pointer)</li></ul><ul id="cd8d1d37-de53-4d7c-a75c-cd228af773fc" class="bulleted-list"><li style="list-style-type:disc">등등</li></ul><p id="6d876194-4de4-4f24-a140-a7fe042320eb" class=""><strong>&lt;C코드의 어셈블리어 패턴&gt;</strong></p><p id="49e61ca1-8402-43d1-9a69-eb4409ef3f6b" class="">1) 변수의 값을 메모리 어딘가에 저장</p><p id="d4ccbe75-bde3-489b-bb02-cc746b881fd8" class="">2) 그 변수의 값을 읽어와 레지스터에 저장</p><p id="96783815-6782-4533-bd2d-f4da5ecf61ac" class="">3) 레지스터에 저장된 값을 가지고 계산한 뒤, 계산 결과도 레지스터에 저장</p><p id="0527d3f4-5504-4dcf-96ff-6cb0fead25b8" class="">4) 그 결과를 다시 메모리에 저장</p><p id="5b47af45-31f5-47d0-8726-79dd6dbe6a92" class="">5) 그리고 다시 그 결과를 사용해서 계산하면 레지스터에 또 복사</p><h3 id="211f7db0-37e8-4858-8f1b-2ae1d363dcbd" class="">register 키워드</h3><p id="8d020f08-5b32-407e-b3a6-594eae318919" class=""><strong>&lt;메모리를 거치지 않고 레지스터만 쓰면 빠를 것 같은데?&gt;</strong></p><p id="3e69b04e-a655-4db8-972d-d1844663fc3f" class="">⇒ 어셈블리어로 코드를 작성하면 언제든지 사용가능<div class="indented"><p id="ae732858-ec43-44a2-b58b-17d72617bd87" class="">단, CPU에 탑재된 레지스터 수가 몇 개 없기 때문에 모든 것을 레지스터에 저장하는 것은 불가능</p></div></p><p id="ca730896-fdc7-4f26-a8de-f34f3b919b87" class=""><strong>&lt;C 코드에서 레지스터를 사용하는 방법&gt;</strong></p><ul id="f4eb3752-6aa2-43c8-b2e0-2ea216357916" class="bulleted-list"><li style="list-style-type:disc">레지스터를 사용해달라고 부탁할 수는 있음<p id="040557ce-e456-45bb-8203-4ca33c94b321" class="">⇒ 들어줄지 말지는 컴파일러는 마음</p></li></ul><ul id="d10080fe-429c-4535-8ef9-03012a344a51" class="bulleted-list"><li style="list-style-type:disc">따라서 가능하면 레지스터를 사용해 달라는 &#x27;힌트&#x27;정도만 줄 수 있음<p id="928d12a9-2107-40b0-ab96-a25ae5e44abb" class="">⇒ 하지만 현재 크게 의미없음</p></li></ul><p id="7069605f-4be1-44e9-9273-50fbc866427f" class=""><strong>&lt;레지스터 사용을 &#x27;요청&#x27;하는 예&gt;</strong></p><ul id="5d2ea11a-3a1f-41b3-a090-3c3edbcf4b3a" class="bulleted-list"><li style="list-style-type:disc">스택이 아니라면 가능한 레지스터 넣어달라고 요청<p id="58dabc83-3f9e-49a9-9e73-047b5a29364c" class=""><strong>⇒ 반드시 레지스터를 사용해주는 것은 아님!!</strong></p></li></ul><pre id="98293749-8e2c-41a2-91d6-b627533d1ea5" class="code"><code>int num;
register size_t i;

num = 0;

for (i=0; i &lt; 1000; ++i) {
	num += i;
}

printf(&quot;num: %d\n&quot;, num);</code></pre><p id="dc865a78-00ca-4a59-aa3d-c8bbc134a131" class=""><strong>&lt;register 키워드&gt;</strong></p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="591d3fb0-f94c-4704-919d-c546767d7620"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>register &lt;자료형&gt; &lt;변수명&gt;;</strong></div></figure><ul id="cb67324d-5481-4514-9326-126cacc84fcd" class="bulleted-list"><li style="list-style-type:disc">저장 유형 지정자(storage-class specifier)</li></ul><ul id="72e03c74-5a80-44e2-a0f7-fce0319107ca" class="bulleted-list"><li style="list-style-type:disc"><strong>가능하다면 </strong>해당 변수를 레지스터에 저장할 것을 요청</li></ul><ul id="e2fb0dd5-88fb-4f87-93b6-add5a193dfd9" class="bulleted-list"><li style="list-style-type:disc">실제로 레지스터를 사용할지 말지는 컴파일러가 결정</li></ul><ul id="c857282e-c4e2-45e3-b182-75f9305c81b7" class="bulleted-list"><li style="list-style-type:disc"><strong>레지스터는 메모리가 아님</strong></li></ul><ul id="4f74807b-6b8e-4876-a451-41cc60a435ee" class="bulleted-list"><li style="list-style-type:disc"><strong>따라서, 레지스터 변수들은 몇 가지 제약을 받음</strong></li></ul><hr id="39479d24-e54b-47ad-9496-92a4a3573640"/><p id="4db28c24-74f7-42f7-beb2-1b2396b2d58c" class=""><strong>제약 1 : 변수의 주소를 구할 수 없음</strong></p><pre id="0b638313-3c86-46d7-a113-ca129a3d5c2d" class="code"><code>register int num = 10;
int*p;

p = &amp;num; /* 컴파일 오류 */ </code></pre><p id="d7c869dd-87b9-41da-906d-18c6d3457c49" class=""><strong>제약 2 : 레지스터 배열을 포인터로 사용 불가</strong></p><pre id="d03f737f-e375-47fc-9e0d-322fa17e7622" class="code"><code>register int nums[10];
int*p;

p = &amp;nums;       /* 컴파일 오류 */ 
p = &amp;nums[0];    /* 컴파일 오류 */ </code></pre><p id="c2acdefc-eb45-46e2-a3b2-178244b779cd" class=""><strong>제약 3 : 블록 범위에서만 사용 가능</strong></p><pre id="04417055-ab0e-4ac2-8412-58b783868417" class="code"><code>#include &lt;stdio.h&gt;

register int g_num;   /* 컴파일 오류 */

int main(void)
{
	return 0;
}</code></pre><ul id="63b25d7f-0ece-41dc-88d7-d6f2c64cca3d" class="bulleted-list"><li style="list-style-type:disc">전역 변수에는 사용할 수 없음<p id="b6bef29f-07fd-49f6-bfd1-5c885e59b54e" class="">⇒ 전역 변수를 사용하는 순간 데이터 섹션에 들어가야함</p></li></ul><hr id="68b4d254-aa34-4f58-afd5-84f7e789300c"/><p id="2527c906-35f0-410a-9c67-81e6c634d2ff" class=""><strong>&lt;더이상 거의 사용하지 않는 register 키워드&gt;</strong></p><ul id="53eda0eb-90f0-4294-bdb3-73eccec2c4ad" class="bulleted-list"><li style="list-style-type:disc">크게 의미가 없음 → 데스크탑 컴파일러들은 register 키워드를 넣어준다고 해서 특별하게 해주는 것이 없으며 대부분 무시함</li></ul><ul id="91e6e3f3-1eba-48d7-ba56-614017ec0516" class="bulleted-list"><li style="list-style-type:disc">예전 임베디드 시스템에서는 의미가 있었음<p id="f252ae37-03cc-4fd1-bdd2-04650f0d81f9" class="">⇒ CPU도 매우 느렸고, 메모리 용량도 적었고, 최적화를 잘 해주지 않는 컴파일러 때문에 프로그래머가 레지스터 사용까지 직접 지시했어야 했음</p></li></ul><ul id="ffa7daf9-4e1c-4579-bedd-a3e476ba057a" class="bulleted-list"><li style="list-style-type:disc">이제는 보통 컴파일러가 배포(release) 모드에서 알아서 최적화<ul id="e7925e04-c43c-4059-907d-4facd96cb2b7" class="bulleted-list"><li style="list-style-type:circle">불필요한 스택 메모리의 접근을 없애고</li></ul><ul id="4c5a684f-9c26-4c14-8c7b-db84fe4f45c4" class="bulleted-list"><li style="list-style-type:circle">레지스터에만 있으면 빠를 거 같은 변수도 그렇게 해주고<p id="9d17d2d6-b045-46e2-9517-3f65f03ec17f" class="">⇒ 더이상 프로그래머가 수동으로 사용하지 않는 키워드</p></li></ul></li></ul><h2 id="403a1208-126c-4ec6-83cf-f79eb8e9baa8" class="">힙 메모리</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3a18c172-4e2e-4b5c-86fa-88b8f4568fd3"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>힙 메모리(동적 메모리)는 범용적인 메모리 공간으로, 사용자에 의해 관리되는 영역이다. 스택 메모리와는 달리 컴파일러 및 CPU가 자동으로 메모리 관리를 해주지 않으며 사용자가 동적으로 할당한 변수들이 저장된다. 실행 중 그 크기와 위치가 결정되며, 스택 메모리와는 반대로 낮은 주소에서 높은 주소로 할당된다. </strong></div></figure><h3 id="a00ae9a4-f623-4165-acf0-eeba36845a56" class="">스택 메모리의 단점</h3><p id="deee891e-9fd2-498e-adcd-d6bd5609622d" class=""><strong>&lt;수명&gt;</strong></p><ul id="5049daa1-f7bb-459a-aed1-55128da22ed1" class="bulleted-list"><li style="list-style-type:disc">함수가 반환하면 그 안에 있던 데이터가 다 날아감<ul id="3547c07a-60c5-404d-8587-be1ae3a02430" class="bulleted-list"><li style="list-style-type:circle">즉, 함수 안에 있는 변수와 수명은 함수가 끝날 때까지</li></ul></li></ul><ul id="58a5bd51-80ab-4c25-806d-3fd167a32efe" class="bulleted-list"><li style="list-style-type:disc">그러지 않고 데이터를 오래 보존하려면 전역변수, 또는 <code>static</code>키워드를 사용해야 했음<ul id="d287a36a-ffb2-4994-83e4-51b09fd29fd4" class="bulleted-list"><li style="list-style-type:circle">이런 변수의 수명은 프로그램 실행 내내</li></ul></li></ul><ul id="a5d44bbc-6507-49eb-afa4-730b12ba97f9" class="bulleted-list"><li style="list-style-type:disc">그 중간 어딘가 내가 원할 때 만들거나 지울 수 있는 저장공간은?</li></ul><p id="3cb1d06e-1eff-4f78-8dca-ac6e7998d96b" class=""><strong>&lt;크기&gt;</strong></p><ul id="cf8200b4-6d63-4af8-aee7-43d6a4f4fec8" class="bulleted-list"><li style="list-style-type:disc"><strong>특정 용도에 쓰라고 별도로 떼어 놓은 메모리</strong></li></ul><ul id="11f77c48-45de-46b7-a177-8e3986eef1b9" class="bulleted-list"><li style="list-style-type:disc"><strong>그 크기는 컴파일 시에 결정하므로 너무 크게 못 잡음</strong></li></ul><ul id="dd09f055-66b5-4ddd-87ce-797a5410aa70" class="bulleted-list"><li style="list-style-type:disc">프로그램을 실행할 시스템의 메모리가 1MB일 수도 있고 4GB일 수도<p id="8bdba81b-3ea0-4034-929b-8e728df923cf" class="">⇒ 최소한에 맞출 수 밖에 없음</p></li></ul><ul id="231fd036-6847-429f-ac63-85f28a7cfe61" class="bulleted-list"><li style="list-style-type:disc">그래서 엄청 큰 데이터를 처리해야 할 경우 스택 메모리에 넣지 못함<p id="9b4f3a17-c79a-49bc-a6e5-cbdc605fa643" class="">⇒ 예 : 4K로 녹화해서 파일의 크기가 2GB인 동영상 파일</p></li></ul><h3 id="39166f85-793d-4153-ac25-53fca8d8dd06" class="">힙 메모리</h3><ul id="99f8b8fd-cc32-4533-8b83-26a2680a566e" class="bulleted-list"><li style="list-style-type:disc">컴퓨터에 존재하는 범용적 메모리</li></ul><ul id="f64830ad-6fb2-4ad6-894c-674f965c4b32" class="bulleted-list"><li style="list-style-type:disc">스택 메모리처럼 특정 용도로 떼어 놓은 게 아님</li></ul><ul id="73c054c7-c16c-4a2d-bc3f-b4ec25e1669f" class="bulleted-list"><li style="list-style-type:disc">스택과 달리 컴파일러 및 CPU가 자동적으로 메모리 관리를 안 해줌</li></ul><ul id="d5db1a34-81dd-43ee-a6fd-d183888ce933" class="bulleted-list"><li style="list-style-type:disc">따라서 프로그래머가 원하는 때 원하는 만큼 메모리를 할당받아와 사용하고 원할 때 반납(해제)할 수 있음</li></ul><h3 id="fc066f1a-3565-40d0-9fce-6a545fb3b8e5" class="">힙 메모리의 장점</h3><ul id="7a5eb5fc-2b26-49e1-9641-747cfd3caf75" class="bulleted-list"><li style="list-style-type:disc">용량 제한 없음<ul id="bbbdd634-13c3-4a84-bee8-a965b5387620" class="bulleted-list"><li style="list-style-type:circle">컴퓨터에 남아있는 메모리만큼 사용 가능</li></ul></li></ul><ul id="c80f68a1-c7b5-4b44-91b3-5fbde01d154f" class="bulleted-list"><li style="list-style-type:disc">프로그래머가 데이터의 수명을 직접 제어<ul id="c32838c2-4756-4c85-8a03-b155aa6e8c2c" class="bulleted-list"><li style="list-style-type:circle">스택에 저장되는 변수처럼 함수 호출이 끝나면 사라지지 않음</li></ul><ul id="a466f3b3-4408-430a-9a6b-8ccdbb0a6eb4" class="bulleted-list"><li style="list-style-type:circle">전역변수처럼 프로그램이 실행되는 동안 계속 살아있는 것도 아님</li></ul></li></ul><h3 id="77d02f4b-9f06-44a4-bfd7-c9c0be90c6f9" class="">힙 메모리의 단점</h3><p id="ed29dc17-9d07-4906-91c7-dbe67b7f4b3c" class="">1) 빌려온 메모리를 직접 해제 안 하면 누구도 그 메모리를 쓸 수 없음</p><ul id="a4ff6c8c-0e50-4099-8bb7-50a47286aa54" class="bulleted-list"><li style="list-style-type:disc">그 메모리는 계속 누군가에게 빌려준 상태</li></ul><ul id="f0c47d7b-9a75-4480-816d-7c3e9bdefc52" class="bulleted-list"><li style="list-style-type:disc">만약, 빌려간 쪽에서 그 메모리 주소를 잃어버리면 메모리 누수 발생<hr id="dbe71500-9393-4097-99bc-035e8ecf1a90"/><p id="003409c9-6d42-42d6-b20b-f7f02eb1a409" class=""><strong>C는 언매니지드 언어다!</strong></p><ul id="7cf3505b-5a9a-4dfd-8529-5e12e5ef21fd" class="bulleted-list"><li style="list-style-type:circle">매니지드 언어(예: C3, Java 등)는 메모리 해제를 알아서 해주는 언어</li></ul><ul id="c56206e7-f320-418e-baf3-3497dc86fcf6" class="bulleted-list"><li style="list-style-type:circle">이를 메모리 관리(manage) 해준다고 하여 매니지드 언어라고 함</li></ul><ul id="37d2a5ba-0d5d-4d98-b3e9-40c58708597e" class="bulleted-list"><li style="list-style-type:circle">이 메모리 관리 기능은 다른 훌륭한 프로그래머들이 구현한 것<ul id="c39f4bf0-398f-469e-8112-bdd5742a30c9" class="bulleted-list"><li style="list-style-type:square">메모리 누수가 날 가능성이 적음</li></ul><ul id="9ec63d2d-d84b-4d14-ab74-af100042bae9" class="bulleted-list"><li style="list-style-type:square">당연히 범용적으로 만든거라 속도 등이 느릴 수 있음</li></ul></li></ul><ul id="1334ba8c-0499-425f-b480-dff424447947" class="bulleted-list"><li style="list-style-type:circle">C는 그런 언어가 아니기에 프로그래머가 직접 해줘야함<ul id="11204296-5376-4609-90ab-eb079662f25b" class="bulleted-list"><li style="list-style-type:square">최대한 효율성을 선택하는 대신</li></ul><ul id="14ba8643-c595-4fa4-9444-0509256380cb" class="bulleted-list"><li style="list-style-type:square">실수를 막기 위해 여러 가지 원칙들을 습관화</li></ul></li></ul><hr id="76667365-3429-4b3f-ab0a-e14956ce2632"/></li></ul><p id="39f858b4-bb27-4aff-bd78-cdfba05d2359" class="">2) 스택에 비해 할당/해제 속도가 느림</p><ul id="743107fb-0eb0-4c3f-bef8-f768bb467f36" class="bulleted-list"><li style="list-style-type:disc"><strong>스택은 오프셋 개념</strong> vs <strong>힙은 사용/비사용 중인 메모리 관리</strong> 개념</li></ul><ul id="3325c1e8-c11b-4d4c-bfdd-c4a451aa3847" class="bulleted-list"><li style="list-style-type:disc">메모리 공간에 구멍이 생겨 효율적으로 메모리 관리가 어렵기도 함<p id="6113b965-4b8a-4746-b26e-441540bde1f7" class="">⇒ 메모리의 파편화(fragment)</p></li></ul><h3 id="050722f7-9ab0-4057-84ef-8250174f10a2" class="">정적 메모리와 동적 메모리</h3><ul id="9bd25caf-3772-42f0-a2d2-5b52a80a1f25" class="bulleted-list"><li style="list-style-type:disc">스택은 <strong>정적 메모리</strong><ul id="0e2c0be3-4248-4d39-ab8d-7ce1ccfa60ec" class="bulleted-list"><li style="list-style-type:circle">이미 공간이 따로 잡혀 있음</li></ul><ul id="bd9c09c2-2981-44f4-9804-3e83056db39a" class="bulleted-list"><li style="list-style-type:circle">할당/해제가 자동으로 관리되게 코드가 컴파일됨</li></ul><ul id="c44133ff-c20a-41cc-9cf4-319a28fe88ef" class="bulleted-list"><li style="list-style-type:circle">오프셋 개념으로 정확히 몇 바이트씩 사용해야하는지 컴파일시 결정</li></ul></li></ul><ul id="bb785098-d008-4bd4-9006-b25179207297" class="bulleted-list"><li style="list-style-type:disc">힙은 <strong>동적 메모리</strong><ul id="21804fa5-d19a-45b0-b209-705382b5741c" class="bulleted-list"><li style="list-style-type:circle">실행 중에 크기와 할당/해제 시기가 결정됨</li></ul></li></ul><h2 id="17833e7a-ba1c-495f-9cc6-66862fb7699e" class="">동적 메모리</h2><p id="5c25c870-9e9a-4431-b10c-7dffb3c0e253" class="">프로그램이 동적 메모리를 가져다 사용할 때는 총 3가지 단계를 거침</p><p id="253ff004-b0c0-4eb5-a3d2-53f1f26f3e76" class="">1) 메모리 할당</p><p id="e840adbe-f46e-4f69-aaf8-66f0153f23ea" class="">2) 메모리 사용</p><p id="46b2bf5e-df19-4fd0-8b26-5ad2c0fa906e" class="">3) 메모리 해제</p><h3 id="9b3d9817-1bfb-4ea3-8c1c-fb87f5ac5591" class="">동적 메모리 사용 단계 1 : 메모리 할당</h3><ul id="9d82dea0-634e-4ffc-a213-abbfebb66b17" class="bulleted-list"><li style="list-style-type:disc">힙 관리자에게 메모리를 xxx 바이트만큼 달라고 요창<ul id="0c4a9344-399e-4a79-9a3c-e5a3547bccc4" class="bulleted-list"><li style="list-style-type:circle">관리자는 연속되는 그만큼의 메모리를 찾아서 반환</li></ul><ul id="9782e233-5e17-40b6-98ae-5f4ddb7d8434" class="bulleted-list"><li style="list-style-type:circle">반환된 메모리는 <strong>메모리 주소</strong>니 당연히 <strong>포인터 </strong>자료형에 저장 가능<p id="8bc2511d-17a5-4744-b08b-451703006d9b" class=""><strong>⇒ 주소 반환!</strong></p></li></ul></li></ul><h3 id="424934b5-b43d-4d78-811f-3d5014cb1baf" class="">동적 메모리 사용 단계 2 : 메모리 사용</h3><ul id="17ed0fdc-1470-44b1-88d5-a9d0e89186ec" class="bulleted-list"><li style="list-style-type:disc">그 메모리를 원하는 대로 사용</li></ul><h3 id="2091eab3-e287-4de7-ae87-c32a9a359f1e" class="">동적 메모리 사용 단계 3 : 메모리 반납</h3><ul id="20dd4a56-5a6a-4607-bcd4-3ece73930834" class="bulleted-list"><li style="list-style-type:disc">힙 관리자에게 그 메모리 주소를 돌려주면서 다 썼다고 알려줌</li></ul><h2 id="f0c918c6-3555-4c73-bb03-7f2657b5b254" class="">메모리 할당 및 해제 함수</h2><h3 id="26c695e9-cc71-4103-8354-488777890dac" class="">메모리 할당 및 해제 함수</h3><p id="d79d1c7f-1f17-499d-9d21-a8bff94788a3" class="">⇒ <code>&lt;stdlib.h&gt;</code></p><ul id="d295c187-ba64-405b-8beb-90a15f1f9ba8" class="bulleted-list"><li style="list-style-type:disc">할당 : <code>malloc()</code>, <code>calloc()</code></li></ul><ul id="b87952b7-479f-4f91-aaf1-ad09d2d02762" class="bulleted-list"><li style="list-style-type:disc">해제 : <code>free()</code></li></ul><ul id="5123ba21-0364-4d5a-8e77-5981d453bbae" class="bulleted-list"><li style="list-style-type:disc">재할당 : <code>realloc()</code></li></ul><h3 id="e23880a0-7b40-4faa-b066-0883b718ab2b" class="">기타 메모리 관련 함수</h3><p id="e399d69c-92f7-4827-8496-e0070d93310f" class="">⇒ <code>&lt;string.h&gt;</code></p><ul id="72c1c86a-169b-4d74-8acc-614dcc649bdb" class="bulleted-list"><li style="list-style-type:disc"><code>memset()</code>, <code>memcpy()</code>, <code>memcmp()</code></li></ul><h3 id="b865f04b-962e-4852-a8d4-5a31ce4de0a2" class="">malloc()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </h3><pre id="3c39ed0d-0df4-42d3-9136-0dd32868dde1" class="code"><code>______ malloc(size_t size);</code></pre><ul id="6b770e21-0a6e-49b9-814b-e8c36678cfc1" class="bulleted-list"><li style="list-style-type:disc">메모리 할당(memory allocation)의 약자</li></ul><ul id="9f80ad59-b09b-432a-b900-3fc1cd6f18a2" class="bulleted-list"><li style="list-style-type:disc"><strong>size바이트 만큼 메모리를 반환해줌 (</strong><strong><code>size_t</code></strong><strong> : 음수는 안됨!)</strong></li></ul><ul id="913a69fb-0fec-450d-88af-2a9359ea2c58" class="bulleted-list"><li style="list-style-type:disc"><strong><code>void*</code></strong><strong>로 반환</strong><p id="bbbfb528-0451-4625-b363-b0c471908c5a" class=""><strong>⇒ 범용적이고 프로그래머가 알아서 사용할 수 있도록</strong></p></li></ul><ul id="0f96472c-7241-4d1c-8a17-ed5bb51c357a" class="bulleted-list"><li style="list-style-type:disc">포인터 외에 다른 자료형으로 반환될 수 없음</li></ul><pre id="639e3419-2294-40f3-8f72-ad1a627eeae5" class="code"><code>void* malloc(size_t size);</code></pre><ul id="e8c5bbb7-c60e-4783-853a-cac9732d59f2" class="bulleted-list"><li style="list-style-type:disc">반환된 메모리에 들어있는 값은 쓰레기 값<p id="f10e373e-40ec-43c9-a5f3-fb8c844f39ea" class="">⇒ 이전에 남아있던 데이터가 그대로 나옴</p></li></ul><ul id="8c15cc7f-5aac-40d7-aafe-72f685e51587" class="bulleted-list"><li style="list-style-type:disc"><strong>즉, 초기화 해주지 않음</strong><p id="d8fd98ec-dffd-4c54-b73f-70a7ff459669" class=""><strong>⇒ 사용하기 위해 프로그래머가 직접 초기화</strong></p></li></ul><ul id="d5dc5107-1454-48f7-87d9-76768446c82b" class="bulleted-list"><li style="list-style-type:disc">메모리가 더이상 없다거나 해서 실패하면 NULL 반환</li></ul><h3 id="3954fd29-7cad-41e0-8cc4-4144a072b63e" class="">free() : malloc()의 짝꿍 함수!</h3><ul id="bc9d60a2-9bd2-4669-a3c0-08b32ab2104d" class="bulleted-list"><li style="list-style-type:disc">동적 메모리는 프로그래머가 직접 빌리고 직접 반납까지 해줘야함!</li></ul><ul id="4002feb6-9143-4baa-a533-5ee0ebb1b608" class="bulleted-list"><li style="list-style-type:disc"><strong>그러므로 </strong><strong><code>malloc()</code></strong><strong> 코드를 작성하면 곧바로 </strong><strong><code>free()</code></strong><strong> 코드도 추가하는 습관을 들이는 것이 좋음</strong></li></ul><h3 id="7edf6cea-4deb-4786-916d-1bff099c2eef" class="">malloc()을 쓰는 예</h3><p id="00d72b89-da6b-478c-8c01-2516300a6d30" class=""><strong>&lt;예시 1&gt;</strong></p><pre id="8ea6ba62-129f-4421-8622-b0687a73c19e" class="code"><code>#include &lt;stdlib.h&gt;

#define LENGTH (10)</code></pre><pre id="323446ee-2529-4021-ac9f-3fdcd3169a7d" class="code"><code>size_t i;
int* nums = malloc(LENGTH * sizeof(int)); 
/* 데이터의 크기 : 요소 수 * 데이터 크기  */
/* 동적 배열을 저장하기 위한 40바이트 할당 요청 */

for (i = 0; i &lt; LENGTH; ++i) {
	nums[i] = i * LENGTH;
}

for (i = 0; i &lt; LENGTH; ++i) {
	printf(&quot;%d&quot;, nums[i]);
}

free(nums);

/*
0 10 20 30 40 50 60 70 80 90
_
*/</code></pre><p id="8031f47f-1c74-438d-af9c-a2db7d194e71" class=""><strong>&lt;예시 2 : 여러 줄의 입력을 받아 출력&gt;</strong></p><pre id="f289e140-f9e2-495d-9d18-a8c4d06f8ce9" class="code"><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define NUM_LINES (5)
#define LINE_LENGTH (2048)</code></pre><pre id="4b6c5a93-0a20-4c16-ba73-83c24bdaae00" class="code"><code>char* lines[NUM_LINES];
char line[LINE_LENGTH];
size_t i;
size_t j;

for (i = 0; i &lt; NUM_LINES; ++i) {
	if (!fgets(line, LINE_LENGTH, stdin)) {
		clearerr(stdin);
		break;
	}

	lines[i] = malloc(strlen(line) + 1); /* NULL 문자 넣기 위해 + 1 */
	if (lines[i] == NULL) {
		fprintf(stderr, &quot;%s\n&quot;, &quot;out of mem&quot;);
		break;
	}

	strcpy(lines[i], line);
}

for (j = 0; j &lt; i; ++j) {
	printf(&quot;%s&quot;, lines[j]);
}

for (j = 0; j &lt; i; ++j) {
	free(lines[j]);
}</code></pre><p id="53567460-ce02-4abf-87eb-89e58c3e958b" class="">⇒ 한계 : <code>char* lines[NUM_LINES];</code> 줄수가 NUM_LINES로 고정</p><p id="e0ddecb7-aa58-4a84-8caf-ef9fa193e8cc" class=""><strong>&lt;예시 3 : 학생 정보 입력 받기&gt;</strong></p><pre id="e5c4aa5a-86e0-4e86-a6e0-abde5e2c9cca" class="code"><code>#define INCREMENT (2)</code></pre><pre id="f7ce7ffa-a15f-453e-8042-cd8a36de0fc8" class="code"><code>typedef struct {
	char firstname[NAME_LEN];
	char lastname[NAME_LEN];
	unsigned int id;
	float gpa;
} student_t;</code></pre><pre id="45f93de5-4f31-4eed-bcb4-d5def46dbe4a" class="code"><code>student_t read_student()
{
	student_t s;

	/* 오류 처리 코드 생략 */

	printf(&quot;Enter firstname: &quot;);
	scanf(&quot;%s&quot;, s.firstname);

	printf(&quot;Enter lastname: &quot;);
	scanf(&quot;%s&quot;, s.lastname);

	printf(&quot;Enter id: &quot;);
	scanf(&quot;%d&quot;, s.id);

	printf(&quot;Enter gpa: &quot;);
	scanf(&quot;%f&quot;, s.gpa);

	return s;
}</code></pre><pre id="9940efdb-b2f8-45cb-90a8-8c6c80defe13" class="code"><code>while (TRUE) {
	student = read_student();

	if (current_index == max_students) {
		max_students += INCREMENT;
		tmp = malloc(max_students * sizeof(students_t));
		memcpy(tmp, students, current_index * sizeof(student_t));
		free(students);
		students = tmp;
	}

	students[current_index++] = student;
}

free(students);
students = NULL</code></pre><p id="b1d0eb09-3b9d-4772-8768-5a21801cf4f6" class=""><strong>&lt;예시 3 : 파일에서 학생 정보 읽기&gt;</strong></p><pre id="b760c4d2-0b05-4b1a-bb7b-61c46e88f945" class="code"><code>/* test.dat */
총학생수...이름...성...아이디...gpa...이름...성...아이디...gpa...</code></pre><pre id="4262510a-b33e-4e6c-971b-8b85a2ed4752" class="code"><code>FILE* file;
size_t num_students;
size_t num_read;
student_t* students;

file - fopen(&quot;text.dat&quot;, &quot;rb&quot;);
/* 파일 오류 처리 코드 생략 */

num_read = fread(&amp;num_students, sizeof(size_t), 1, file);

students = malloc(num_students * sizeof(student_t);

num_read = fread(students, sizeof(students_t), num_students, file);

fclose(file);

/* 다 끝나고 free() 해줘야함 */</code></pre><h3 id="d88ce8c2-2b11-4879-97d4-7dfd500ad372" class="">제대로 된 free() 설명</h3><pre id="c8084327-9f95-437d-9c85-c001477d1a27" class="code"><code>void free(void* ptr);</code></pre><ul id="0ec34522-1a00-427b-8f17-54f18e4ad541" class="bulleted-list"><li style="list-style-type:disc">할당받은 메모리를 해제하는 함수</li></ul><ul id="9f3df22b-93f0-4e57-b8a7-703c62f1d02d" class="bulleted-list"><li style="list-style-type:disc">즉, 메모리 할당 함수들을 통해서얻은 메모리만 해제 가능</li></ul><ul id="b39fcb9e-5ae2-4e9e-b5c0-c73d2b62b1a8" class="bulleted-list"><li style="list-style-type:disc">그 외의 주소를 매개변수로 전달할 경우 결과가 정의되지 않음</li></ul><pre id="79454745-92b4-44a2-b7e5-898a4c4ca26e" class="code"><code>int* num;

nums = malloc(LENGTH * sizeof(int));

/* 뭔가 num로 이것저것 함 */

free(nums); /* 위에 어떤 코드가 있냐에 따라 문제가 될 수도 있음 */</code></pre><h3 id="8b759f92-1caa-4dd4-bc02-ecba6f2fa690" class="">동적 메모리 할당 시 문제 1</h3><ul id="1500bac1-1d57-4e26-be7a-562eeb211628" class="bulleted-list"><li style="list-style-type:disc">메모리 할당 함수가 반환한 주소가 저장된 변수를 그대로 포인터 연산에 사용하면 메모리 해제할 때 문제가 발생할 수 있음</li></ul><ul id="34d2ae64-95e4-400d-8eaf-2931386f3650" class="bulleted-list"><li style="list-style-type:disc">최초로 받아온 주소가 아니라 다른 위치를 가리킴 → 그 주소로 메모리 해제 요청 → 결과가 정의되지 않음</li></ul><pre id="34ff4078-f3c1-4e91-9a63-a19fe454c363" class="code"><code>int* nums;

nums = malloc(LENGTH * sizeof(int));

for (i = 0; i &lt; LENGTH; ++i) {
	*num++ = 10 * (i + 1);
}

free(nums); /* 엉뚱한 주소를 해제 (0x100 / 0x110) */</code></pre><h3 id="ae66cb76-2dda-4aea-a2eb-253fa8765b0e" class="">코딩 표준 : 할당받은 포인터로 연산 금지</h3><ul id="50f1c041-5d9f-4496-a4fa-0ea3b45a34c7" class="bulleted-list"><li style="list-style-type:disc">메모리 할당 함수에서 받아온 포인터와 포인터 연산에 사용하는 포인터는 분리하자</li></ul><pre id="f34bccf1-b3ca-4e6e-a06b-c9bd4d0e7aad" class="code"><code>void* nums;
int* p;
size_t i;

nums = malloc(LENGTH * sizeof(int));
p = nums;

for (i = 0; i &lt; LENGTH; ++i) {
	*p++ = 10 * (i + 1);
}

free(nums);</code></pre><h3 id="7083a318-cb78-4c96-b38b-130a9f160437" class="">동적 메모리 할당 시 문제 2</h3><pre id="bf632a09-fbf5-4700-8b2d-c2edda3f7a17" class="code"><code>void* nums;
int* p;
size_t i;

nums = malloc(LENGTH * sizeof(int));
p = nums;

for (i = 0; i &lt; LENGTH; ++i) {
	*p++ = 10 * (i + 1);
}

free(nums);

/* 코드 100줄 */

free(nums); /* 결과가 정의되지 않음 */</code></pre><ul id="7da44e1b-3110-4074-80db-0a90547c8dbc" class="bulleted-list"><li style="list-style-type:disc">해제한 메모리를 또 해제하려고 할 때도 결과가 정의되지 않음<p id="e294280b-1ff1-4c4e-969b-553c7aae0db7" class="">⇒ 잘못하면 크래쉬가 날 수도 있음</p></li></ul><pre id="da96f85f-4770-49ff-bb8d-9bc957fa88e5" class="code"><code>void* nums;
int* p;
size_t i;

nums = malloc(LENGTH * sizeof(int));
p = nums;

for (i = 0; i &lt; LENGTH; ++i) {
	*p++ = 10 * (i + 1);
}

free(nums);

for (i = 0; i &lt; LENGTH; ++i) {
	*p++ += 5;  /* 결과가 정의되지 않음 */
}</code></pre><ul id="18bea0ec-4d95-46bc-951b-a28b786e5efb" class="bulleted-list"><li style="list-style-type:disc"><strong>해제한 메모리를 또 사용하려고 할 때도 결과가 정의되지 않음 (memory stomp)</strong><p id="1addac97-f53f-41d6-a7dc-7749dfc67d0f" class="">⇒ 잘못하면 크래쉬가 날 수도 있음</p></li></ul><h3 id="d965d801-9126-4578-8557-c6bf041436be" class="">코딩 표준 : 해제 후 널 포인터를 대입</h3><ul id="949a4fc4-5322-4bc9-9c49-0634dbedd31e" class="bulleted-list"><li style="list-style-type:disc"><code>free()</code>한 뒤에 변수에 <code>NULL</code>을 대입해서 초기화<ul id="5357303f-f5e9-4afd-a6d4-5a4902861691" class="bulleted-list"><li style="list-style-type:circle">안 그러면 해제된 놈인지 나중에 모름</li></ul><ul id="22638e02-3187-474b-b061-f7ea1e9fa1c7" class="bulleted-list"><li style="list-style-type:circle">널 포인터를 <code>free()</code>의 매개변수로 전달해도 안전</li></ul></li></ul><pre id="dcf71c26-ed28-4d8b-8cbc-f96de791b07f" class="code"><code>void* nums;
int* p;
size_t i;

nums = malloc(LENGTH * sizeof(int));
p = nums;

/* 코드 생략 */

free(nums);
nums = NULL;</code></pre><h3 id="84679141-be3f-431d-87bf-0295f7b35f6c" class="">정리</h3><ul id="026fd0fd-65ea-4d3a-9a97-555a653c34c3" class="bulleted-list"><li style="list-style-type:disc"><code>malloc()</code>한 뒤 <strong><code>free()</code></strong><strong>를 까먹으면</strong> <mark class="highlight-red"><strong>메모리 누수</strong></mark></li></ul><ul id="def42d8a-bea7-4dd4-ad75-79d1708bcdbc" class="bulleted-list"><li style="list-style-type:disc"><code>malloc()</code>으로 받아온 주소를 지역변수에서 저장해놨는데 <strong>해제 안하고 함수에서 나가면</strong> 주소가 사라져 <mark class="highlight-red"><strong>지울 방법이 아예 없어짐</strong></mark></li></ul><h3 id="03439102-4ac2-41e6-a957-d0b1657c00cc" class="">베스트 프렉티스 : malloc()과 free()는 한 몸</h3><ul id="add179fe-9a75-4448-ae72-4182f76e59b3" class="bulleted-list"><li style="list-style-type:disc"><code>malloc()</code>을 코드에 추가하자마자 다른 일 하기 전에 곧바로 <code>free()</code>도 추가할 것</li></ul><h3 id="a9184e18-5afe-4c8e-b88e-94cc30c6e887" class="">free()는 몇 바이트를 해제할지 어떻게 알까</h3><p id="7c76cb9f-c48f-47d0-a6cd-1f030f11aff6" class="">1) 구현마다 다르지만 보통 <code>malloc(32)</code>하면 그것보다 조금 더 큰 메모리를 할당한 뒤, 제일 앞부분에 어떤 데이터들을 채워 넣음</p><p id="67694078-09dd-4d17-bd95-0928fda57933" class="">⇒ <code>malloc()</code>과 <code>free()</code>가 보는 &#x27;어떤 데이터&#x27;를 넣어줌</p><p id="fcd0fd3b-5d54-442a-9d9f-8dd941c02184" class="">2) 그리고 그만큼 오프셋을 더한 값을 주소로 돌려줌<div class="indented"><ul id="1c137fe3-2af2-4329-a40e-7f5e2b0d0552" class="bulleted-list"><li style="list-style-type:disc">우린 돌려받은 주소로부터 원래 요청했던 32바이트를 사용</li></ul></div></p><p id="73579077-e7fe-4d20-8b0b-481f37d3a843" class="">3) 나중에 그 주소 해제를 요청하면 <code>free()</code>가 다시 오프셋만큼 빼서 그 앞 주소를 본 뒤, 실제 몇 바이가 할당됬었는지 확인 후 해제</p><h3 id="b1087c20-12bf-4ee0-81a7-7c3e739b2a66" class="">calloc()</h3><pre id="4af4d963-dbfa-4125-8825-7236bff743fa" class="code"><code>void* calloc(size_t num, size_t size);</code></pre><ul id="a5b2e475-9b4a-485f-80ee-f3edba169e20" class="bulleted-list"><li style="list-style-type:disc">의미는 아무도 모름 → 의견 분분<ul id="86598cc8-85dd-46c2-992e-7ef5511fdfaa" class="bulleted-list"><li style="list-style-type:circle">counted alloc</li></ul><ul id="fa822201-b9cf-41bd-8008-ee0f55a83771" class="bulleted-list"><li style="list-style-type:circle">clear alloc</li></ul><ul id="b94b5a17-723b-4307-81fa-fcf98577efc1" class="bulleted-list"><li style="list-style-type:circle">C alloc ...</li></ul></li></ul><ul id="290649e9-43af-45b4-b43e-72682541aac4" class="bulleted-list"><li style="list-style-type:disc"><strong>메모리를 할당할 때 자료형의 크기(size)와 수(num)를 따로 지정</strong></li></ul><ul id="3d5438d2-0946-4108-b1de-59e23e315b9b" class="bulleted-list"><li style="list-style-type:disc"><strong>모든 바이트를 0으로 초기화해줌</strong></li></ul><ul id="2df4e5d9-30e1-4b74-b7d9-4696cb9f6dca" class="bulleted-list"><li style="list-style-type:disc"><strong>잘 안씀!</strong></li></ul><ul id="19f09a1f-84dd-4f85-8f24-26bbda3a949e" class="bulleted-list"><li style="list-style-type:disc">보통 <code>calloc()</code> 대신 <code>malloc()</code>와 <code>memset()</code>을 조합해서 씀<ul id="3b0a0492-6dff-47d0-8e76-1ba70a305f4f" class="bulleted-list"><li style="list-style-type:circle"><code>memset()</code>을 쓰면 0 외에의 값으로 초기화 가능</li></ul><pre id="42ea72bf-0d1b-49f4-83c2-77801b9ea9e0" class="code"><code>void* nums;

nums = calloc(LENGTH, sizeof(int));

free(nums);
nums = NULL</code></pre><pre id="8fa418ec-392a-4c26-8827-e93baaf8a03f" class="code"><code>void* nums;

nums = malloc(LENGTH * sizeof(int));
memset(nums, 0, LENGTH * sizeof(int)); 

free(nums);
nums = NULL</code></pre><p id="203e3bb0-0d32-4243-9c12-5a0d7ff5f6b8" class="">⇒ 두 방식은 거의 비슷함</p></li></ul><h3 id="548975a2-4afe-43ad-80a5-d70e21192c99" class="">memset()</h3><pre id="3563e64b-2ef4-4aeb-82d9-02f89c1a5df9" class="code"><code>void* memset(void* dest, int ch, size_t count);</code></pre><ul id="82ece057-0581-4984-8f1e-eb34ba573dd6" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>에 있음</li></ul><ul id="e79c44d6-fd8f-46f4-b204-d9fa61ee904e" class="bulleted-list"><li style="list-style-type:disc"><strong><code>char</code></strong><strong>로 초기화(1바이트씩) 됨</strong></li></ul><ul id="5af2220d-96f0-4d13-adec-b1b5333dc14b" class="bulleted-list"><li style="list-style-type:disc">그 외의 자료형으로 초기화하려면 직접 for문을 써야함</li></ul><ul id="5bc72e12-04e7-47dd-8be8-10653a20e757" class="bulleted-list"><li style="list-style-type:disc">다음과 같은 경우 결과가 정의되지 않음<ul id="292d707d-83a9-4c0e-a6e9-aeed932da97d" class="bulleted-list"><li style="list-style-type:circle"><code>count</code>가 <code>dest</code>의 영역을 넘어설 경우 (소유하지 않은 메모리에 쓰기)</li></ul><ul id="fd5b5506-8ad2-4f48-9be9-092131bc7db1" class="bulleted-list"><li style="list-style-type:circle"><code>dest</code>가 널 포인터일 경우 (널 포인터 역참조)</li></ul></li></ul><h3 id="243f45fa-a968-404b-b932-c781cdbc7566" class="">char로만 초기화해주는 memset()</h3><pre id="0ce755f2-01f4-4129-b8d6-e81b69c49640" class="code"><code>void* nums;

nums = malloc(LENGTH * sizeof(int));      /* LENGTH: 4 */
memset(nums, 1000, LENGTH * sizeof(int)); /* 1000은 16진수로 0X3E8 */

free(nums);
nums = NULL
</code></pre><h3 id="790026ca-a2f3-42d7-ae54-9069330d245e" class="">int로 초기화</h3><pre id="472bf431-0935-4244-988e-b65da4434f10" class="code"><code>void* nums;
int* p;
size_t i;

nums = malloc(LENGTH * sizeof(int)); 
p = nums;

for (i = 0; i &lt; LENGTH; ++i) {
	*p++ = 1000;
}

free(nums);
nums = NULL</code></pre><h3 id="1a5211fc-4cb0-450b-9a83-ee0f484c1abf" class="">memcpy()</h3><pre id="4c9f3979-937b-42f5-ba93-69dfa3ff9656" class="code"><code>void* memcpy(void* dest, const void* src, size_t count);</code></pre><ul id="afeb1ba1-bc72-4cce-98f7-6ae20725cd35" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>에 있음</li></ul><ul id="3fb6a23f-a3b0-4da4-81f1-ebed4e1e4834" class="bulleted-list"><li style="list-style-type:disc"><code>src</code>의 데이터를 <code>count</code>바이트 만큼 <code>dest</code>에 복사</li></ul><ul id="ef954929-9268-44e9-b234-f3284349fab4" class="bulleted-list"><li style="list-style-type:disc">다음과 같은 경우 결과가 정의되지 않음<ul id="31f68c58-9454-4320-94de-15921cb128f3" class="bulleted-list"><li style="list-style-type:circle"><code>dest</code>의 영역 뒤에 데이터를 복사할 경우 (소유하지 않은 메모리에 쓰기)</li></ul><ul id="6f734ea6-093a-4ce0-83c0-a74a368cbe51" class="bulleted-list"><li style="list-style-type:circle"><code>src</code>나 <code>dest</code>가 널 포인터일 경우 (널 포인터 역참조)</li></ul></li></ul><h3 id="6837bd4b-7624-4180-a25d-27e2b79a979e" class="">realloc()</h3><pre id="502e0eec-f47c-426c-8d69-a3698ca0ea42" class="code"><code>void* realloc(void* ptr, size_t new size);</code></pre><ul id="5200a84e-2f53-4fff-a815-3673cd17d936" class="bulleted-list"><li style="list-style-type:disc">이미 존재하는 메모리(ptr)의 크기를 new_size 바이트로 변경</li></ul><ul id="cccf868d-345c-4b1b-8fe9-e157df72ba6b" class="bulleted-list"><li style="list-style-type:disc">새로운 크기가 허용하는 한 기존 데이터를 그대로 유지</li></ul><ul id="9bf13916-a986-4237-9f3a-859852124853" class="bulleted-list"><li style="list-style-type:disc">아까 봤던 학생 정보 입력 받기 예에서 동적 배열 크기를 늘리던 코드를 이 함수로 대체 가능</li></ul><h3 id="709b81e8-553a-4745-8ee4-9ac2d730267c" class="">크기가 커져야할 때의 두 가지 경우</h3><p id="0ace2e43-0d7b-4e09-9317-7615516206e2" class="">1) 지금 갖고 있는 메모리 뒤에 충분한 공간이 없으면 새로운 메모리를 할당한 뒤, 기존 내용을 복사하고 새 주소 반환</p><pre id="373fec3a-bc36-405e-80ed-5d19154e8a54" class="code"><code>str = malloc(LENGTH * sizeof(char));    /* LENGTH: 4 */
str = realloc(str, 2 * LENGTH * sizeof(char));</code></pre><p id="75d465ad-b8ad-49c3-92a7-21d3ed311127" class="">2) 지금 갖고 있는 메모리 뒤에 공간이 충분하다면 그냥 기존 주소를 반환(보장은 없음). 그리고 추가된 공간을 쓸 수 있게 됨</p><pre id="6d71813d-1ad9-4a13-9f21-0b3e04357dd9" class="code"><code>str = malloc(LENGTH * sizeof(char));    /* LENGTH: 4 */
str = realloc(str, 2 * LENGTH * sizeof(char));</code></pre><h3 id="b29dedcf-8793-4b22-9965-e39140abf2c4" class="">크기가 작아져야할 경우</h3><ul id="21342c48-ac16-4795-b64b-b4a73d6771e6" class="bulleted-list"><li style="list-style-type:disc">기존 주소가 그대로 반환되거나</li></ul><ul id="9e4530eb-446a-4e24-ae49-e5ba2b118dd5" class="bulleted-list"><li style="list-style-type:disc">다른 곳에 메모리를 새로 할당 후, 새로운 주소를 반환해줄 수도 있음</li></ul><h3 id="d7fb6468-bf9e-467b-b41b-8c8de937bb9d" class="">realloc()의 메모리 누수</h3><pre id="46cf42d9-dad8-4765-b156-fb21c2a51aa2" class="code"><code>void* realloc(void* ptr, size_t new_size);
</code></pre><ul id="cc7e6fc5-7d91-489f-a690-3fa45e52fba9" class="bulleted-list"><li style="list-style-type:disc">반환값<ul id="fad5f4ae-d456-49d4-80a2-9a4926ca9b14" class="bulleted-list"><li style="list-style-type:circle">성공 시,  새롭게 할당된 메모리의 시작 주소를 반환하여 기존 메모리는 해제됨</li></ul><ul id="8188c0d0-82c5-4778-8d97-ee24d8747fcb" class="bulleted-list"><li style="list-style-type:circle"><strong>실패 시,  </strong><strong><code>NULL</code></strong><strong>을 반환하지만 기존 메모리는 해제되지 않음</strong></li></ul></li></ul><ul id="3c143859-d876-497b-9214-c17fe003beb3" class="bulleted-list"><li style="list-style-type:disc"><strong>실패 시 메모리 누수가 발생할 수 있음!!</strong></li></ul><pre id="ccc2ef6e-841b-499f-88b4-2aa41d9ad0a0" class="code"><code>void* nums;
nums = malloc(SIZE);

nums = realloc(nums, 2 * SIZE);  /* NULL 반환 */</code></pre><ul id="1d73e6c0-7fa4-43a6-bcd5-a4e1b8c3780b" class="bulleted-list"><li style="list-style-type:disc">원래 nums에 저장되어있던 주소가 사라짐</li></ul><ul id="b6b5763b-49a3-489c-a6ac-815c28a7bfa6" class="bulleted-list"><li style="list-style-type:disc">NULL이 반환됬다는 이야기는 재할당에 실패했다는 의미</li></ul><ul id="39117e77-7937-4e68-917e-3124c25b1dec" class="bulleted-list"><li style="list-style-type:disc">따라서 기존 메모리는 해제되지 않음</li></ul><ul id="e004358a-95b0-4edc-b9c7-a142926c1f66" class="bulleted-list"><li style="list-style-type:disc"><strong>그러나 그 주소를 잃어버려서 해제할 수 없다! 메모리 누수 발생!!</strong></li></ul><h3 id="b93983e1-be9d-4924-9d86-07e259a2eaae" class="">올바른 재할당 방법</h3><pre id="bda4054e-d7ac-4202-a64b-6d09ad0bec97" class="code"><code>void* nums;
void* tmp;

num = malloc(SIZE);

tmp = realloc(nums, 2 * SIZE);
if (tmp !=- 0) {
	nums = tmp;
}</code></pre><ul id="a4de8203-fbd4-4c82-bd3c-e991dde10aff" class="bulleted-list"><li style="list-style-type:disc"><code>realloc()</code>은 <code>malloc()</code> + <code>memcpy()</code> + <code>free()</code>와 유사함<pre id="e7d4813a-6078-44fa-9522-3e0024b4475c" class="code"><code>void* nums;
void* tmp;

/* LENGTH: 4, nums: 10 */
num = malloc(SIZE);

tmp = realloc(nums, 2 * SIZE);
if (tmp !=- 0) {
	nums = tmp;
}

free(nums);</code></pre><pre id="9ff10f66-4592-45d7-828f-4420fe1cbf4b" class="code"><code>void* nums;
void* tmp;

/* LENGTH: 4, nums: 10 */
num = malloc(SIZE);

tmp = malloc(2 * SIZE);
if (tmp !=- 0) {
	memcpy(tmp, nums, LENGTH);
	free(nums);
	nums = tmp;
}

free(nums);</code></pre></li></ul><h3 id="603fb133-d491-49c9-bd0b-c0d68c7d627e" class="">메모리 누수 안나게 코드를 작성할 것</h3><ul id="52969085-85a3-4159-96ef-212d88537e57" class="bulleted-list"><li style="list-style-type:disc"><code>realloc()</code>을 쓸 때는 정말 조심해야함</li></ul><ul id="4508c480-5d51-4294-aedd-b3e35a9d5276" class="bulleted-list"><li style="list-style-type:disc">그래서 차라리 <code>malloc()</code> + <code>memcpy()</code> + <code>free()</code>로 좀 더 명시적으로 드러나게 코딩하는게 더 좋을수도 있음</li></ul><ul id="e6032822-1d29-4827-b625-41a5f096ffd1" class="bulleted-list"><li style="list-style-type:disc">그냥 신경 안쓰고 <code>realloc()</code>을 쓰는 경우도 많음<ul id="d420280f-4f5b-4bee-b9dc-da6c39e03950" class="bulleted-list"><li style="list-style-type:circle">메모리 시작 주소가 변하지 않을 경우 데이터를 복사를 하지 않아 성능상 이득</li></ul><ul id="6ab5fcf2-153d-43b1-aefe-6d200c01b352" class="bulleted-list"><li style="list-style-type:circle">그리고 메모리가 없어서 널 포인터를 반환하는 상황 대처를 위해</li></ul><ul id="82ad6799-bcee-4b79-942a-63030856751e" class="bulleted-list"><li style="list-style-type:circle"><code>malloc()</code>에서 실패하는 일이 없다고 가정하고 코딩을 하는 경우도 많음</li></ul></li></ul><h3 id="c5029c44-3415-41a6-ab8e-3dbc4494d0ea" class="">realloc()의 특수한 경우</h3><ul id="4aa240cb-39a8-4a00-afce-7250484b4a4c" class="bulleted-list"><li style="list-style-type:disc"><code>nums = realloc(NULL, LENGTH);</code><ul id="4f5639c4-b0a8-4d6c-8e80-5e5c6a5f6dba" class="bulleted-list"><li style="list-style-type:circle">새로운 메모리 할당</li></ul><ul id="6de4306f-3b29-43b3-8575-3c8770d14a7c" class="bulleted-list"><li style="list-style-type:circle"><code>malloc(LENGTH)</code>와 동일함</li></ul></li></ul><h3 id="569e2cc8-759f-4a03-9dd8-17490cec595d" class="">memcmp()</h3><pre id="74fa13c7-18f7-48bb-bc71-ea26ee0ad16f" class="code"><code>int memcmp(const void* lhs, const void* rhs, size_t count);</code></pre><ul id="b3fcb2d2-5598-4dd2-ae93-b31b90258f31" class="bulleted-list"><li style="list-style-type:disc">첫 <code>count</code> 바이트 만큼의 메모리를 비교하는 함수</li></ul><ul id="ba714033-0aa0-4248-b22d-6382094a2783" class="bulleted-list"><li style="list-style-type:disc"><code>strcmp()</code>와 매우 비슷</li></ul><ul id="1856d691-1889-42fd-8a6b-3d2cf3ec25e5" class="bulleted-list"><li style="list-style-type:disc">단, 널 문자를 만나도 계속 진행</li></ul><ul id="e77d0f6f-91c1-4227-b60e-3ec2c056f0c9" class="bulleted-list"><li style="list-style-type:disc">다음의 경우 결과가 정의되지 않음<ul id="3b681575-f03b-41e5-b879-4853d54b2da2" class="bulleted-list"><li style="list-style-type:circle"><code>lhs</code>와 <code>rhs</code>의 크기를 넘어서서 비교할 경우 (소유하지 않은 메모리에 쓰기)</li></ul><ul id="c3d95172-0241-4047-b251-4b3396f46b59" class="bulleted-list"><li style="list-style-type:circle"><code>lhs</code>와 <code>rhs</code>이 널 포인터일 경우 (널 포인터 역참조)</li></ul></li></ul><h3 id="43e5fa05-3456-48be-b647-efd0e8e9f662" class="">두 구조체를 비교할 때 유용</h3><pre id="f72a1628-7bee-4de1-a181-e4846a59de38" class="code"><code>typedef struct {
	char firstname[64];
	char lastname[64];
	unsigned int id;
} student_t;</code></pre><pre id="5cb139d1-a5b1-47ad-bb29-f4b3e6d9fc3d" class="code"><code>student_t s1 = {&quot;Lulu&quot;, &quot;Kim&quot;, 12345};
student_t s2 = {&quot;Teemo&quot;, &quot;Park&quot;, 12349};
student_t s3 = {&quot;Lulu&quot;, &quot;Choi&quot;, 12350};
student_t s4 = {&quot;Teemo&quot;, &quot;Park&quot;, 12340};

int result;

result = memcmp(&amp;s1, &amp;s2, sizeof(student_t));  /* -1 */
result = memcmp(&amp;s1, &amp;s3, sizeof(student_t));  /* 1 */
result = memcmp(&amp;s2, &amp;s4, sizeof(student_t));  /* 1 */

/*
&quot;Lulu&quot; &lt; &quot;Teemoe&quot;이므로 -1
&quot;Kim&quot; &gt; &quot;Choi&quot;이므로 1
12349 &gt; 12340이므로 1
*/ </code></pre><h3 id="239dcbc1-0836-43c2-bb50-63ace2b638cd" class="">구조체가 포인터 변수를 가질 경우</h3><ul id="4872c81e-23e6-4956-947b-e3a3b77d86f1" class="bulleted-list"><li style="list-style-type:disc">주소를 가진 구조체면 같아도 주소가 달라 다를 수 있음</li></ul><pre id="3c9d9a43-0cb5-4d39-8fc6-e92758aacd79" class="code"><code>typedef struct {
	char* firstname;
	char* lastname;
} name_t;</code></pre><pre id="47fa53de-3251-4935-a9a9-e8f1f8a3d712" class="code"><code>name_t s1;
name_t s2;
int result;

/* 동적 메모리 할당을 이용하여 이름 복사 */

result = memcmp(&amp;s1, &amp;s2, sizeof(student_t));  /* -1 */</code></pre><h3 id="0606b8df-0685-492d-b030-c22e97047b56" class="">동적 메모리 할당을 이용한 깊은 복사</h3><pre id="25c178f3-0f06-4912-b896-d9dc94afb297" class="code"><code>typedef struct {
	char* firstname;
	char* lastname;
} name_dynamic_t;</code></pre><pre id="00ba26ef-86a6-4dd2-88bf-33823f92915c" class="code"><code>name_dynamic_t s1; 
name_dynamic_t s2;
size_t size;

size = strlen(s1.firstname + 1);
s2.firstname = malloc(size);
/* s2.firstname 널 포인터 체크 코드 생략 */
memcpy(s2.fristname, s1.firstname, size);

size = strlen(s1.lastname + 1);
s2.lastname = malloc(size);
/* s2.firstname 널 포인터 체크 코드 생략 */
memcpy(s2.lastname, s1.lastname, size);

/* free() 호출 생략 */
</code></pre><h3 id="37e129dd-196a-4d8e-88f9-7a38ac1fc105" class="">구조체 멤버 변수 - 배열 vs 포인터</h3><p id="771fe4f2-4ba6-42db-8ad7-2a414dc2d161" class=""><strong>&lt;고정된 길이인 배열&gt;</strong></p><pre id="b59ea475-3021-466a-b462-6be313523eed" class="code"><code>typedef struct {
	char firstname[NAME_LEN];
	char lastname[NAME_LEN];
} name_fixed_t;</code></pre><ul id="9f0413f3-7a6a-49dc-9b92-c998e07145e9" class="bulleted-list"><li style="list-style-type:disc">그대로 대입 가능</li></ul><ul id="2514e37d-19d3-46a2-9863-8f3c8e14e477" class="bulleted-list"><li style="list-style-type:disc">파일에 곧바로 저장 가능</li></ul><ul id="bdf61869-510a-4317-a245-665653e0bbee" class="bulleted-list"><li style="list-style-type:disc"><code>memcpy()</code>를 곧바로 사용 가능</li></ul><ul id="3fd474b2-3c5b-4fb3-b6a6-c6e9a54d983e" class="bulleted-list"><li style="list-style-type:disc">낭비하는 용량이 있음</li></ul><ul id="af5886ff-58b6-4293-b76c-909bb1794017" class="bulleted-list"><li style="list-style-type:disc">메모리 할당/해제 속도 빠름</li></ul><p id="1ad722c0-a60d-4d04-87e0-8bb5bb6937c8" class=""><strong>&lt;동적 메모리를 사용하는 포인터&gt;</strong></p><pre id="ce5807e6-cc39-4f7c-9776-d05ff49ba660" class="code"><code>typedef struct {
	char* firstname;
	char* lastname;
} name_dynamic_t;</code></pre><ul id="39a60137-5645-4f0d-b878-21ec10e031b0" class="bulleted-list"><li style="list-style-type:disc">그래도 대입 불가<ul id="be86dc46-b4df-466d-b2aa-854e82c83423" class="bulleted-list"><li style="list-style-type:circle">이 경우 앝은 복사가 되어버림</li></ul></li></ul><ul id="8fec3a5e-090c-42ac-a536-112d1d377d04" class="bulleted-list"><li style="list-style-type:disc">파일에 곧바로 저장 불가능</li></ul><ul id="413a0783-d546-4ca8-ac81-3b99f47afcc0" class="bulleted-list"><li style="list-style-type:disc"><code>memcpy()</code> 곧바로 사용 불가능</li></ul><ul id="ff2bbc9b-6ca8-4279-9997-e58c6d789622" class="bulleted-list"><li style="list-style-type:disc">낭비하는 용량 없음 → 정확히 필요한 만큼만 사용</li></ul><ul id="30979056-e5db-4680-b5ff-ef9fd4a246f2" class="bulleted-list"><li style="list-style-type:disc">메모리 할당/해제 속도 느림</li></ul><h2 id="10026a44-f845-43f2-95dc-f22581104e8c" class="">베스트 프렉티스 : 정직 vs 동적 메모리</h2><ul id="4e4d52b1-2f64-47d1-9430-b2ed82e371ff" class="bulleted-list"><li style="list-style-type:disc">정적 메모리를 우선적으로 사용할 것<ul id="e6570ccd-f1ad-4958-87e0-519b2244e693" class="bulleted-list"><li style="list-style-type:circle">훌륭한 C 프로그래머들은 최대한 정적 메모리를 쓰려고 함</li></ul></li></ul><ul id="eb3037c2-2d4c-420d-9249-e2c243edce5b" class="bulleted-list"><li style="list-style-type:disc">안될 떄만 동적 메모리</li></ul><h2 id="029854c0-52d3-4144-875f-d7d61723ba1b" class="">동적 메모리의 소유권 문제</h2><h3 id="78684ba2-b292-4ce2-b183-d0a85eb428d7" class="">동적으로 할당한 메모리의 큰 문제</h3><ul id="d7eb1b13-c78d-402e-8771-5e91b3b1566e" class="bulleted-list"><li style="list-style-type:disc">동적으로 할당한 소유주 → 메모리를 생성한 함수</li></ul><ul id="7a88957d-2424-4d19-9fa4-3c84612bfe86" class="bulleted-list"><li style="list-style-type:disc">소유주란?<p id="93f5a102-58a9-455f-9da8-70c896d94a02" class=""><strong>그 메모리를 반드시 책임지고 해제해야 하는 주체</strong></p></li></ul><ul id="9d404721-7f0e-4a87-8f60-de9031520847" class="bulleted-list"><li style="list-style-type:disc">소유주가 아닐 때는 그냥 빌려 사용할 뿐 해제하면 안됨<ul id="ad7ff7bd-c530-4d56-ae0d-17a27a20fd20" class="bulleted-list"><li style="list-style-type:circle">소유주와 비소유주 모두 해제하면 문제가 됨</li></ul><ul id="438e54c9-68cf-4f32-af69-fe0e0de990a3" class="bulleted-list"><li style="list-style-type:circle">하지만 한 명도 해제 안해도 문제가 됨</li></ul></li></ul><h3 id="9c63f651-6252-488a-8dd8-7ac4097e0348" class="">문제의 예시</h3><ul id="cb5cb30a-6e2e-410e-b475-f3d27b622a55" class="bulleted-list"><li style="list-style-type:disc">호출자가 이 함수를 호출하는 순간 내부에서 새 메모리가 할당해서 반환하다는 사실을 어떻게 알 수 있는가<pre id="b5d6d451-5f0f-4d23-a9ac-13c6ad5e10c2" class="code"><code>const char* combine_string(const char* a, const char* b)
{
	void* str;
	char* p;
	/* a와 b의 길이 및 두 길이를 더한 값을 보관한 변수 생략 */

	str = malloc(size);

	/* a와 b를 str에 복사하는 코드 생략 */

	return str;
}</code></pre><pre id="694fd5df-01f7-44c0-a2cf-565b9f388d55" class="code"><code>result = combine_string(&quot;Hello&quot;, &quot;World&quot;);</code></pre></li></ul><p id="fa77da75-ef4e-4dc4-88e1-847c608a8676" class=""><strong>&lt;C++에서는 RAII로 해결&gt;</strong></p><ul id="d1586c99-8601-484d-a43c-6a5852e7530a" class="bulleted-list"><li style="list-style-type:disc">자원 획득은 초기화(RAII, Resource Acquisition Is Initialization)<ul id="e4213a2e-d67b-4092-a1b3-3b81b3d6f8ed" class="bulleted-list"><li style="list-style-type:circle">여기서 자원은 메모리를 말함</li></ul></li></ul><ul id="c01c76c4-5fa8-427d-add3-afcfb49e9028" class="bulleted-list"><li style="list-style-type:disc">C++은 개체지향을 지원하는 언매니지드 언어</li></ul><ul id="26eec903-2c9a-47b7-a3da-f13b3b2a5774" class="bulleted-list"><li style="list-style-type:disc">한 개체가 생성될 때 필요한 메모리를 할당 (생성자란 특별한 함수)</li></ul><ul id="cee22e71-ff61-4649-b117-da70ce49ce73" class="bulleted-list"><li style="list-style-type:disc">그 개체의 수명이 다할 때 그 메모리를 해제 (소멸자란 특별한 함수)</li></ul><ul id="a14f270a-5c57-4517-a820-7eed932a2e35" class="bulleted-list"><li style="list-style-type:disc"><strong>즉, 개체의 수명이라는 범위에 메모리의 수명을 종속시킴</strong></li></ul><ul id="4689c323-b02b-41a5-a845-87f3f4bbdd27" class="bulleted-list"><li style="list-style-type:disc">이 원칙을 잘 따르면 실수할 여지가 적음</li></ul><p id="0e62ba2d-9c00-44bc-af36-45ced1fabefc" class=""><strong>&lt;하지만 C는 개체가 없음!&gt;</strong></p><ul id="98a7edfa-bcdc-4c01-a362-cc732dcb00c0" class="bulleted-list"><li style="list-style-type:disc">그래도 RAII를 최대한 흉내내면 좋음</li></ul><ul id="03b5273c-9158-48de-9411-ca89136b6aab" class="bulleted-list"><li style="list-style-type:disc">C에서 RAII를 할 수 있는 부분<ul id="d6150ca3-9c07-4c2d-8aac-fde295247d22" class="bulleted-list"><li style="list-style-type:circle">한 함수 안에서 <code>malloc()</code>, <code>free()</code>를 다 호출할 수 있는 경우</li></ul></li></ul><ul id="53b57281-428e-4870-ba1a-b619ca88a639" class="bulleted-list"><li style="list-style-type:disc">이런 이유 때문에 항상 <code>malloc()</code>을 추가하면 곧바로 <code>free()</code>를 추가할는 것임</li></ul><pre id="adbfa16a-d50d-4065-b39d-44b543cec502" class="code"><code>void do_something(void)
{
	void* nums;
	
	nums = malloc(10 * sizeof(int));
	free(nums); /* 일단 넣고 함수를 구현할 것 */
}</code></pre><p id="f79c434f-b0be-4166-a622-e54458b03026" class=""><strong>&lt;하지만 중간에 함수를 탈출할 경우?&gt;</strong></p><ul id="560d1df5-78dd-4b28-a1e9-de0f747c6b91" class="bulleted-list"><li style="list-style-type:disc">코드 중간에 <code>return</code>하면 아무 의미가 없음!!</li></ul><pre id="dc93d38d-c8e9-413e-bedb-c9465eb3f223" class="code"><code>void do_something(void)
{
	void* nums;
	
	nums = malloc(10 * sizeof(int));

	/* 코드 생략 */

	if (조건) {
		return;   /* free(nums)를 못 함!!! */
	}

	free(nums); 
}</code></pre><p id="8546c438-d663-4baa-9839-0b0ed12ecc19" class=""><strong>&lt;해결법 : goto문 사용&gt;</strong></p><pre id="58d88161-abaa-4b6b-a748-1214aa73db03" class="code"><code>void do_something(void)
{
	void* nums;
	
	nums = malloc(10 * sizeof(int));

	/* 코드 생략 */

	if (조건) {
		goto free_and_exit;
	}
	
	/* 코드 생략 */

free_and_Exit:
	free(nums); 
}</code></pre><p id="7d888b9b-9ee7-491b-85ff-ac83c9c0b7d4" class=""><strong>&lt;원래의 문제는 어떻게 해결하는가?&gt;</strong></p><p id="e764cb45-7d3b-4d61-8df9-77c862f79b10" class=""><strong>⇒ 호출자가 이 함수를 호출하는 순간 내부에서 새 메모리가 할당해서 반환하다는 사실을 어떻게 알 수 있는가</strong></p><ul id="d7965d98-3d2d-46d9-9181-10cd44d26b6f" class="bulleted-list"><li style="list-style-type:disc">C에서 굉장히 해결하기 어려운 문제</li></ul><ul id="9c0dfee8-4dff-4e59-b891-8a5898935843" class="bulleted-list"><li style="list-style-type:disc">최선의 방법은 이런 함수를 최대한 없도록 하는 것</li></ul><ul id="49c58620-f7c3-4ae1-84a5-54e992b16c19" class="bulleted-list"><li style="list-style-type:disc"><code>combine_string()</code> 예의 경우, 함수 안에서 할당하는 대신 함수 밖에서 할당 후 매개변수로 전달<pre id="ccf966e1-0cba-4898-a8a4-a61e2ecbee59" class="code"><code>size_t calculate_combined_length(const char* a, const char* b);
void combine_string(const char* a, const char* b, char* out_str);</code></pre><pre id="8af5d3b4-ca86-4f77-a891-3d4837e3cb2d" class="code"><code>void combine_string(const char* a, const char* b, char* out_str)
{
	/* out_str에 a와 b 복사 */
}</code></pre><pre id="fc557e76-9968-42bd-9f34-e7cdc5db6a4d" class="code"><code>const char8 str_combined;
size_t size;

size = calculate_combined_length(str1, str2); /* 두 문자열을 합친 길이 반환 */
str_combined = malloc(size + 1);
combine_string(str1, str2, str_combined);

free(str_combined);</code></pre></li></ul><p id="86f1939d-0df5-4fbc-a990-2ebeec5dd800" class=""><strong>&lt;동적으로 할당 후 반환을 피할 수 없다면?&gt;</strong></p><ul id="09ada5e1-d350-4953-99cf-337f119fd223" class="bulleted-list"><li style="list-style-type:disc">딱히 모두가 동의하는 표준은 없음</li></ul><ul id="d33bd77c-d75f-433e-9fab-c977ac987ae8" class="bulleted-list"><li style="list-style-type:disc">어떤 함수가 메모리 할당을 한다면 함수에 그 사실을 표기<ul id="8b2f3c02-417c-407a-9636-39cc1b2ebd2d" class="bulleted-list"><li style="list-style-type:circle">주석으로 표기하는 방법도 있음 → 그러나 사람들은 주석을 잘 안 읽음</li></ul></li></ul><ul id="05d4f4ff-e13b-4d66-876d-06f5c077403e" class="bulleted-list"><li style="list-style-type:disc">동적 메모리를 할당하는 변수라면 변수명에 표기하는 방법도 있음</li></ul><h3 id="1bd054fc-4f27-40f4-a3d6-caba25194d2f" class="">코딩 표준 : 동적 메모리 할당을 하는 함수명</h3><ul id="9acb7c26-bfd4-421c-be57-6c41166bccb5" class="bulleted-list"><li style="list-style-type:disc">어떤 함수의 내부에서 동적 메모리 할당을 한다면 이름에 확실히 알려주는 것이 좋음</li></ul><pre id="b8dd255e-3e12-4191-a4b4-a2830944ce29" class="code"><code>const char* combine_string_malloc(const char* str1, const char* str2)
{
	void* pa_str;
	char* p;

	pa_str = malloc(strlen(str1) + strlen(str2) + 1);
	p = pa_str;

	/* 문자열 합치는 코드 생략 */

	return pa_str;
}</code></pre><ul id="ee75a2b8-37f0-4859-9f56-fe623252f8e3" class="bulleted-list"><li style="list-style-type:disc">동적 할당된 메모리를 저장하는 변수라면, 이름에 그 사실을 명시<ul id="706c7ccf-0fb0-4b1a-ac6f-86c5d84588de" class="bulleted-list"><li style="list-style-type:circle"><code>pa</code> : pointer allocated</li></ul></li></ul><h2 id="1f7a3607-2b39-4bd8-a10e-2609e0f5fd8b" class="">베스트 프렉티스 정리</h2><ul id="422eaec2-be13-408b-a189-d5c3d512884f" class="bulleted-list"><li style="list-style-type:disc"><code>malloc()</code>을 작성한 뒤에 곧바로 <code>free()</code>도 추가하자<ul id="dad71a61-3906-429b-8eee-7dc0bdc39c3c" class="bulleted-list"><li style="list-style-type:circle"><code>free()</code>를 절대 까먹으면 안됨!!</li></ul></li></ul><ul id="aa03394b-271b-414b-a361-7dbe30d98baa" class="bulleted-list"><li style="list-style-type:disc">동적 할당을 한 메모리 주소를 저장하는 포인터 변수와 포인터 연산에 사용하는 포인터 변수를 분리해 사용하자<ul id="a425ea1e-ec47-443a-82db-e8f71bb009e9" class="bulleted-list"><li style="list-style-type:circle">원래 포인터 변수를 사용할 경우, 주소를 잃어버려서 해제를 못할 수 있음</li></ul><pre id="7a2f7cad-6bad-4b2e-a590-2d488225034d" class="code"><code>void* pa_nums;
int* p;

pa_nums = malloc(LENGTH * sizeof(int));
p = pa_nums;

/* pa_nums는 이제 사용 금지, p 로만 작업 */

free(pa_nums)</code></pre></li></ul><ul id="1f6ac4d3-03c2-4217-8766-343e994a4980" class="bulleted-list"><li style="list-style-type:disc">메모리 해제 후, 널 포인터를 대입하자<p id="97d12bd0-3206-44bd-a51a-30ab334a5f03" class="">1) <code>free()</code>를 두번 호출하는 것을 막기 위해</p><p id="359eb772-c567-490e-a25c-b454ed27910a" class="">2) 또 다른 코드에서 NULL인 경우 쓰지 말아야 하므로 조건문에 쓰지 말아야하는 것을 알기 위해</p><pre id="06e5568c-c77d-4d6a-9ad7-e525b07e84ff" class="code"><code>void* pa_nums;
int* p;

pa_nums = malloc(LENGTH * sizeof(int));

/* ... */

free(pa_nums)
pa_nums = NULL;</code></pre></li></ul><ul id="0fcaa444-745b-4398-a4af-4e99ab32ffb3" class="bulleted-list"><li style="list-style-type:disc">정적 메모리를 우선적으로 사용하고 어쩔 수 없을 때만 동적 메모리를 사용</li></ul><ul id="62181527-29e2-40e2-807b-d512e75b6c62" class="bulleted-list"><li style="list-style-type:disc">동적 메모리 할당을 할 경우, 변수와 함수 이름에 그 사실을 알리자<pre id="febe0efc-76cd-471f-98c1-a845e0dceca9" class="code"><code>const char* combine_string_malloc(const char* str1, const char* str2)
{
	void* pa_str;
	char* p;

	pa_str = malloc(strlen(str1) + strlen(str2) + 1);
	p = pa_str;

	/* 문자열 합치는 코드 생략 */

	return pa_str;
}</code></pre></li></ul><h2 id="8d702f1e-cab3-4e9b-8724-341d956449aa" class="">다중 포인터</h2><h3 id="576f38d5-4ff9-4a6a-a79a-4c1510966a15" class="">포인터</h3><p id="88c94b65-adfc-4aab-8b7e-5ca8ff3ac8ef" class="">⇒ 주소를 저장하는 변수</p><h3 id="1c032fbf-74d3-48e8-a183-f550954b8410" class="">이중 포인터</h3><pre id="0b375de2-8c1f-4a9c-8523-902b39235f5a" class="code"><code>int num = 10;
int* p = &amp;num;
int** pp = &amp;p;</code></pre><ul id="da6b95ac-960f-4c77-bffb-139783838a0e" class="bulleted-list"><li style="list-style-type:disc">포인터 변수의 주소를 저장하는 변수</li></ul><ul id="cbbd1415-d389-4f13-9e62-bccc6d4cdb85" class="bulleted-list"><li style="list-style-type:disc">주소의 주소 → 주소를 반복!</li></ul><hr id="a3a675fb-188a-438f-a285-ffea87d9f191"/><p id="08b3d361-d4f1-4519-92e1-062d857f2270" class=""><strong>&lt;상황에 따라 주소의 주소의 주소의... 가능&gt;</strong></p><pre id="6e63b182-6d59-4fa5-9378-7eb3457fd308" class="code"><code>int*** r = &amp;q;
int*********** z = &amp;y;
</code></pre><p id="237132bd-a483-457b-91f0-2d7f1a2a12c5" class="">⇒ 그러나 3중 포인터도 매우 드물며, 4중 이상은 거의 안씀</p><hr id="5810b83d-70b6-44b8-9323-20179b75b66e"/><h3 id="8967570a-7186-4883-be00-193d8d4821e8" class="">퀴즈</h3><pre id="c53410a3-502d-49b6-9494-7a5aa6c7e4c7" class="code"><code>int num1; /* num1의 주소: 0x100 */
int num2; /* num2의 주소: 0x104 */
int* p;   /* p의 주소: 0x108 */
int* q;   /* q의 주소: 0x10C */
int* r;   /* r의 주소: 0x110 */
int** pp; /* pp의 주소: 0x114 */

num1 = 10;
num2 = 20;

p = &amp;num1;
q = &amp;num2;
r = &amp;num1;

pp = &amp;p;
*pp = q;
**pp = 1024;
pp = &amp;r;
**pp = *p * 2;</code></pre><pre id="02ff92fc-91d6-4a38-b0c3-9128f3daceea" class="code"><code>/*
num1: 2048
num2: 1024
p: 0x104
q: 0x104
r: 0x100
pp: 0x110
*/</code></pre><ul id="52ed4b86-5db5-4caf-9910-05824969f8dd" class="bulleted-list"><li style="list-style-type:disc">문제를 풀 때 아래를 기입해두고 하나하나 해결해나가는 것이 더 편함<pre id="d3b9fcfa-903a-4a7a-b8f0-48e0dce16493" class="code"><code>num1의 주소: 0x100
num2의 주소: 0x104
p의 주소: 0x108
q의 주소: 0x10C
r의 주소: 0x110
pp의 주소: 0x114

num1: 10
num2: 20
p: 0x100
q: 0x104
r: 0x100</code></pre></li></ul><h3 id="1581ad8d-bd91-411e-b961-3e98f41dbb32" class="">이중 포인터의 사용</h3><ul id="8fca65f6-7108-4c88-86dc-dc1fc3fde5af" class="bulleted-list"><li style="list-style-type:disc">2차원 배열은 2중 포인터의 개념과 비슷<ul id="3de70850-24c2-4b57-b7c5-a28a976fbc67" class="bulleted-list"><li style="list-style-type:circle">2차원 자료가 많아서 2D 배열을 많이 씀</li></ul><ul id="a67fdf25-b0ba-4661-bb23-3bbd9b82f547" class="bulleted-list"><li style="list-style-type:circle">예 : 구구단표, 이미지</li></ul><p id="41b06c01-4fe7-4ab5-b8b7-0e8d0f414ee3" class="">⇒ 3차원 배열 : 3중 포인터 사용</p></li></ul><ul id="dfae1176-a573-4297-afbf-90c67afa2150" class="bulleted-list"><li style="list-style-type:disc">메인 함수의 매개변수인 <code>argv</code>도 엄밀히 말하면 이중 포인터<ul id="facd83f5-ce03-490a-94dd-e97a9b532ac4" class="bulleted-list"><li style="list-style-type:circle">포인터의 배열 → 각 배열은 포인터</li></ul><pre id="4173f2e7-011d-41ca-bd07-26620f30ae68" class="code"><code>int main(int argc, char* argv[]);
int main(int argc, char** argv[]);</code></pre></li></ul><h3 id="53f53d3e-fdc2-40d9-bf01-3332cfc4474c" class="">포인터 변수를 교체하기</h3><pre id="da7fcab4-c5f4-402e-ae16-ab6742eda355" class="code"><code>void swap(int** n1, int** n2)
{
	int* tmp = *n1;

	*n1 = *n2;
	*n2 = tmp;
}</code></pre><pre id="1ab919e8-b676-4944-81fa-8cfab84991f1" class="code"><code>int num1 = 10;
int num2 = 20;

int* p;
int* q;

p = &amp;num1;
q = &amp;num2;

swap(&amp;p, &amp;q);</code></pre><h3 id="0449b95f-0978-447e-b7c8-c7bdf4e1993e" class="">단어 정렬</h3><pre id="2cf4b641-b955-4a99-84f1-ffa203639e4b" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;string_comparer.h&quot;

enum { NUM_WORDS = 6 };

int main(void)
{
	size_t i;
	const char* words[NUM_WORDS] = {
		&quot;premium&quot;, &quot;level&quot;, &quot;cultured&quot;,
		&quot;moaning&quot;, &quot;skinny&quot;, &quot;curve&quot;
	};

	puts(&quot;\n== sort ascending ==&quot;);

	qsort(words, NUM_WORDS, sizeof(const char*), compare_string);
	for (i = 0; i &lt; NUM_WORDS; ++i) {
		printf(&quot;%s\n&quot;, word[i]);
	}

	puts(&quot;\n== sort descending ==&quot;);

	qsort(words, NUM_WORDS, sizeof(const char*), compare_string_desc);
	for (i = 0; i &lt; NUM_WORDS; ++i) {
		printf(&quot;%s\n&quot;, word[i]);
	}</code></pre><pre id="9bdc6335-33c7-4c1f-bed6-2765a2ec86a2" class="code"><code>/* string_comparer.c */

#include &lt;stdio.h&gt;
#include &quot;string_comparer.h&quot;

int compare_string(const void* a, const void* b)
{
	const char** w0 = (const char**)a;
	const char** w1 = (const char**)b;

	return strcmp(*w0, *w1);
}

int compare_string_desc(const void* a, const void* b)
{
	const char** w0 = (const char**)a;
	const char** w1 = (const char**)b;

	return strcmp(*w1, *w0);
}
	</code></pre><h3 id="d685a240-ac8f-42b7-a85a-42f626af68f4" class="">퀴즈</h3><p id="2e1b94e1-e89a-4a4a-b3f8-73b7e4ebc63c" class=""><strong>&lt;퀴즈 1&gt;</strong></p><pre id="06cfd1f8-1356-43bd-bcaf-c562aae8f7b0" class="code"><code>int num1 = 10;
int num2 = 13;
int num3 = 19;

int* p1 = &amp;num2;
int* p2 = &amp;num1;
int* p3 = &amp;num3;
	
int** pp1 = &amp;p2;
int** pp2 = &amp;p3;
int** pp3 = &amp;p1;

*pp1 = *pp2;
**pp2 *= 2;
pp3 = pp2;

printf(&quot;%d, %d, %d&quot;, **pp1, **pp2, **pp3);

/* 38, 38, 38 */</code></pre><p id="84d657f3-71ba-405d-b4a9-aa266fe235fd" class=""><strong>&lt;퀴즈 2&gt;</strong></p><pre id="cf447e7a-0313-4080-b5cf-4e19dbb3bfab" class="code"><code>int num1 = 10;
int num2 = 13;
int num3 = 19;

int* p1 = &amp;num2;
int* p2 = &amp;num1;
int* p3 = &amp;num3;

int** pp1 = &amp;p2;
int** pp2 = &amp;p3;
int** pp3 = &amp;p1;

int*** ppp1 = &amp;pp3;
int*** ppp2 = &amp;pp1;
int*** ppp3 = &amp;pp2;

*ppp1 = *ppp3;
**ppp2 = **ppp1;
***ppp3 -= ***ppp1;

printf(&quot;%d, %d, %d&quot;, ***ppp1, ***ppp2, ***ppp3);

/* 0, 0, 0 */</code></pre><p id="dcae22e7-187b-4b4b-8249-65a08276c34c" class=""><strong>&lt;퀴즈 3&gt;</strong></p><pre id="174e98d1-bf94-4639-9470-e932d21f3f67" class="code"><code>int num1 = 10;  /* num1의 주소값: 0x100 */
int num2 = 13;  /* num2의 주소값: 0x104 */
int num3 = 19;  /* num3의 주소값: 0x108 */

int* p1 = &amp;num2;  /* p1의 주소값: 0x10C */
int* p2 = &amp;num1;  /* p2의 주소값: 0x110 */
int* p3 = &amp;num3;  /* p3의 주소값: 0x114 */

int** pp1 = &amp;p2;  /* pp1의 주소값: 0x118 */
int** pp2 = &amp;p3;  /* pp2의 주소값: 0x11C */
int** pp3 = &amp;p1;  /* pp3의 주소값: 0x120 */

int*** ppp1 = &amp;pp3;  
int*** ppp2 = &amp;pp1;  
int*** ppp3 = &amp;pp2; 

pp1 = pp3;
**pp2 += **pp3;
pp3 = pp2;

*ppp1 = *ppp2;
ppp2 = ppp3;
*ppp3 = *ppp2;

/* pp1, pp2, pp3, ppp1, ppp2, ppp3의 값은? */

/*
pp1: 0x10C
pp2: 0x114
pp3: 0x10C
ppp1: 0X120
ppp2: 0x11C
ppp3: 0x11C
*/</code></pre><p id="1ad0655e-feb2-4180-842f-cd2539bb195e" class="">
</p></div></article></body>

{% endblock post_content %}