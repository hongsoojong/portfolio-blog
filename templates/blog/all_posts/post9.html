{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(6) C 스타일 문자열 / 출력</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 22, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="32dda23d-e41c-4b7f-b590-eb6c436c23ee" class="page sans"><div class="page-body"><h2 id="182ec332-ef19-4e33-8069-58336685a30d" class="">문자열의 표현과 길이</h2><h3 id="de27bd1e-1c1c-4be4-ab58-9056aad1ee4c" class="">문자열과 다른 기본 자료형의 차이</h3><ul id="8d2a77e1-3e08-4ffc-993b-5cf36da63e7e" class="bulleted-list"><li style="list-style-type:disc">기본 자료형 : 그 자료형의 크기와 범위는 고정되어 있음</li></ul><ul id="2845cafb-0fa1-48d7-894e-f6648581749c" class="bulleted-list"><li style="list-style-type:disc">문자열(문장의 크기) : 컴퓨터는 문자열을 몇 바이트로 읽어야하는지 모름<p id="355cd433-ed22-4f31-84ed-79437349dce0" class="">⇒ 문자열이 기본 자료형이 아닌 이유</p></li></ul><h3 id="ef62ab81-a86a-4c19-b5f4-2eae49f2a17b" class="">문자열의 표현</h3><ul id="94ebff80-6e03-4043-a475-0ee6e26364d7" class="bulleted-list"><li style="list-style-type:disc">여러 가지 글자(문자)가 모인 것</li></ul><ul id="085c6486-7a94-44b7-be16-469c29a25cf8" class="bulleted-list"><li style="list-style-type:disc">공백조차 글자!</li></ul><ul id="f7bf5857-9c87-46af-8360-99a9c1e7fc03" class="bulleted-list"><li style="list-style-type:disc">&#x27;여러 개&#x27;의 문자를 표현하려면 ⇒ 배열</li></ul><ul id="96505aac-13aa-4be9-a393-362872ef6421" class="bulleted-list"><li style="list-style-type:disc">따라서 <code>char str[글자수]</code>로 표현 가능</li></ul><ul id="22dd3e4d-130a-4926-800a-f477b0949ca7" class="bulleted-list"><li style="list-style-type:disc">하지만 배열은 길이를 구할 수 없으므로 그 길이를 프로그래머가 따로 기억해둬야함</li></ul><h3 id="80e40736-c4bc-40a0-a12b-c68f3fb9ad4c" class="">문자열 관리 시 길이의 문제</h3><ul id="a1bb22af-8a9b-46ae-aa93-32aa0f3be3d6" class="bulleted-list"><li style="list-style-type:disc">배열의 길이를 저장하는 변수를 만들어 관리할 경우 여러가지 실수들이 발생할 수 있음</li></ul><pre id="d28f4277-e610-4c1b-823b-1777a98812d0" class="code"><code>void print_string(void)
    {
        char chars[] = &quot;Pointer is the best!&quot;;
        const size_t NUM_CHARS = 20;
    
        size_t i;
        for (i = 0; i &lt; NUM_CHARS; ++i) {
            printf(&quot;%c&quot;, chars[i]);
        }
    }
    
    /* Pointer is the best! */</code></pre><pre id="bbc804b5-970f-43a9-96aa-c3099beaf6cc" class="code"><code>void print_string(void)
    {
        char chars[] = &quot;I want to be the best C programmer&quot;;   /* 문자열 변경 */
        const size_t NUM_CHARS = 20;                           /* 배열의 길이 변경 안함 */
    
        size_t i;
        for (i = 0; i &lt; NUM_CHARS; ++i) {
            printf(&quot;%c&quot;, chars[i]);
        }
    }
    
    /* I want to be the best */</code></pre><pre id="7f22fe2e-569f-46d7-a11a-551f1716e616" class="code"><code>void print_string(void)
    {
        char chars[] = &quot;I want to be the best C programmer&quot;;   /* 문자열 변경 */
        const size_t NUM_CHARS = 33;                           /* 배열의 길 오류 */
    
        size_t i;
        for (i = 0; i &lt; NUM_CHARS; ++i) {
            printf(&quot;%c&quot;, chars[i]);
        }
    }
    
    /* I want to be the best C programme */</code></pre><h3 id="f16c72de-9189-4413-acc5-6ea5d78d8bf4" class="">문자열 길이 문제 해결방법 1 : 길이를 배열 첫 위치에 저장</h3><ul id="517e0849-8648-4f7e-9401-d1dedc5ed80c" class="bulleted-list"><li style="list-style-type:disc">첫 메모리 위치에 문자열 길이를 저장하고, 실제 문자열이 뒤 따라오게 함<ol type="1" id="055043b0-333e-4c69-9e35-eb5eecbf1633" class="numbered-list" start="1"><li><code>unsigned char</code>로 길이를 저장하기엔 너무 짧음 → 최대 255자</li></ol><ol type="1" id="5a7fd628-ced1-4957-9aa0-bee6b5b279a3" class="numbered-list" start="2"><li><code>int</code>로 길이를 저장하고, 그 뒤의 문자들은 char로 저장</li></ol></li></ul><ul id="c3a18c7a-9694-4146-b267-f441423993d8" class="bulleted-list"><li style="list-style-type:disc">첫 주소만 봐도 총 글자수를 알 수 있음</li></ul><ul id="a2af4a0e-a70d-43d9-b0b4-e72c26e26645" class="bulleted-list"><li style="list-style-type:disc">다른 언어들은 보통 이 방식을 이용하여 문자열의 길이 저장하기 때문에 문자열의 크기를 바로 알 수 있었음<pre id="01bd11b1-a738-4dcc-834b-17594679c4c3" class="code"><code>C#
    string message = &quot;Hello&quot;;
    Console.WriteLine($&quot;message len: {message.Length}&quot;);</code></pre></li></ul><ul id="a374d528-079d-4254-9a6f-bb27ba742237" class="bulleted-list"><li style="list-style-type:disc">단점<ul id="db312313-fbe9-41be-ba68-9e4088128491" class="bulleted-list"><li style="list-style-type:circle">글자 하나가 1바이트인데 길이 저장에 4바이트를 쓰는 것은 비효율적 → 이러한 방식은 클래스 또는 구조체에서 쓰는 방법</li></ul><ul id="819267a6-600a-4888-b52a-1f71a7e6b34d" class="bulleted-list"><li style="list-style-type:circle">순수 C코드로 어떻게 작성할지 애매함<p id="79469aa1-70c1-4ed6-bf30-0d45d58b95e8" class="">첫 데이터는 <code>int*</code>로 캐스팅해서 읽고 그 다음부터는 <code>char*</code>로 읽어야함</p><p id="cc3d0887-d8d6-4919-98e2-c243f42225d7" class="">물론 디스크로부터 이진파일을 통째로 메모리에 읽어오면 이런 식으로 접근하기는 함</p><p id="d03f3d6d-3a02-426a-9a5a-ee528f91b4b4" class="">그러나 이걸 언어 기본으로 한다는 생각 자체가 힘듬</p><pre id="38896b36-e322-4384-a26a-d686f3569529" class="code"><code>char array[9]; /* 길이 5와 문자열 &quot;Hello가 적혀있음 */
    
    int* len = (int*)&amp;array[0];
    char* str = &amp;array[4];</code></pre></li></ul></li></ul><h3 id="493c5141-574d-4719-b113-27ea2815cd85" class="">문자열 길이 문제 해결방법 2 : 문자열이 끝나는 위치를 표시</h3><ul id="7287f811-339e-4671-a992-35c3dd811ccd" class="bulleted-list"><li style="list-style-type:disc">그냥 <code>char[]</code>만 쓰되 그 문자열이 끝나는 위치에 특수한 문자를 두는 방법<p id="0ade2076-74b9-47bc-b813-b2c30d11811f" class="">⇒ 배열에서 값을 찾을 수 없으면 존재할 수 없는 색인 -1을 반환하는 방식과 마찬가지</p><pre id="122f96ca-bd68-4c24-9dc1-f6aa7cdbc541" class="code"><code>size_t index_of(const char* str, char c)
    {
        /* str 안에 c가 있으면 해당 색인 */
    
        /* 없으면 -1 */
        return -1&#x27;
    }</code></pre></li></ul><ul id="48999577-8a56-4fc0-87ad-056bc8df6e0d" class="bulleted-list"><li style="list-style-type:disc">아스키코드 중에 화면에 출력되지 않는 특수한 문자들이 있음<p id="5c6b5411-228e-4fda-9432-d4125fc9d6fa" class="">⇒ 제어 문자(control character) : 0~31, 126</p></li></ul><ul id="93da7504-521e-44f2-ad92-860797e24ca3" class="bulleted-list"><li style="list-style-type:disc">그 중 하나가 바로 0<p id="e0bd60f6-253d-401f-be6e-c35201783832" class="">⇒ <strong>널 문자(null character, 널 캐릭터)</strong>라고 불림</p><p id="a446d2c0-a0e1-4c7b-9738-badefc69cf1b" class="">
    </p><pre id="287100d4-9054-4add-8208-04633f7abc63" class="code"><code>char null_char = &#x27;\0&#x27;;</code></pre><ul id="d866d144-d881-4644-8f7c-4565ace7adc3" class="bulleted-list"><li style="list-style-type:circle">0은 숫자 영</li></ul><ul id="cbe78237-301a-41b9-b45c-07a7bb748b82" class="bulleted-list"><li style="list-style-type:circle">\는 이스케이프 문자</li></ul><ul id="8682fe6c-4920-468f-959e-80cc18cb294e" class="bulleted-list"><li style="list-style-type:circle">아스키코드로 0이니 <code>char null_char = 0;</code>으로 작성은 가능하지만 읽기 쉽게 &#x27;<code>\0</code>&#x27;으로 써주는 것이 좋음</li></ul></li></ul><h2 id="071d12f3-fec3-4a36-abb1-1cda5477f98d" class="">C 스타일 문자열</h2><ul id="da4561c9-0083-4cb6-a0d9-126221ad719a" class="bulleted-list"><li style="list-style-type:disc"><code>char[]</code>로만 구성</li></ul><ul id="c4b8d2d8-114d-40fd-826c-7a160619eee8" class="bulleted-list"><li style="list-style-type:disc">문자열이 끝나는 곳에 널 문자를 붙임</li></ul><ul id="7f454fc3-50d2-41c9-879b-d0c49af2cbed" class="bulleted-list"><li style="list-style-type:disc"><strong>아래 두 코드는 저장 위치 외에는 동일</strong><pre id="260875e0-a034-45cf-92d5-9e8a526d63c4" class="code"><code>char str1[] = &quot;abc&quot;;  /* 스택에 &quot;abc&quot; 저장 */
    char* str2 = &quot;abc&quot;;   /* 데이터 섹션에 &quot;abc&quot; 저장 */</code></pre><p id="6228d223-a154-4e68-b0d9-2c18fed4fe01" class=""><strong>⇒ 문자열 뒤에 별도로 &#x27;</strong><strong><code>\0</code></strong><strong>&#x27;을 넣지 않아도 컴파일러가 알아서 넣어줌</strong></p><p id="c33fd412-c733-495d-9170-07b049eabf0f" class=""><strong>⇒ </strong><strong><code>char*</code></strong><strong>를 이용할 땐 데이터 섹션에 배열이 들어가므로 반드시 </strong><strong><code>const</code></strong><strong>를 써주는 것이 좋음</strong></p></li></ul><ul id="b8044e6f-7825-484d-98f3-df5b2679abc1" class="bulleted-list"><li style="list-style-type:disc">아래의 경우 &#x27;<code>\0</code>&#x27;을 넣어주지 않음<pre id="74e8a902-4a9a-4dea-8707-15d27c082923" class="code"><code>char str[] = { &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; };</code></pre><p id="0c160d25-807a-4d45-810b-15014725e19d" class="">⇒ 이 경우는 보통 문자열이 아닌 charater를 배열로 쓸 때 사용</p></li></ul><h3 id="e6a8f7ca-7bd0-4924-bdf9-e3d8976b1f35" class="">C 스타일 문자열 예시</h3><pre id="725aa1ff-3474-4716-b57f-ef80daaf2396" class="code"><code>const char str[] = &quot;HONG&quot;;
    printf(&quot;str length: %d\n&quot;, sizeof(str));
    
    /* str length : 5 */</code></pre><ul id="af0cdca7-e999-49ff-ac56-82015ec03a15" class="bulleted-list"><li style="list-style-type:disc">문자열의 길이는 4</li></ul><ul id="42bdd97b-ad98-491f-82c5-e5db7707cef6" class="bulleted-list"><li style="list-style-type:disc">배열의 길이는 최소한 5 (언제나 배열에 널 문자도 포함되어 있음)<p id="e4b05384-466b-436c-bb9d-1a6b1e49c5ac" class="">⇒ 최소한 : 배열을 실제 크기보다 크게 잡고 널 문자를 마지막에 넣는 경우가 흔함</p></li></ul><h3 id="8d7cb4a4-9df4-4ca4-820f-2669d9b9bbf7" class="">C 스타일 문자열의 장단점</h3><ul id="1838528c-a810-4c60-a2f8-1c06100bcb05" class="bulleted-list"><li style="list-style-type:disc">장점<ul id="89d699d3-747f-4ae1-9c85-c3734adb2023" class="bulleted-list"><li style="list-style-type:circle">가장 최소한의 메모리</li></ul><ul id="e2292105-e4cf-422b-8569-1f718e28c291" class="bulleted-list"><li style="list-style-type:circle">한 가지의 데이터형으로 문자열과 길이를 다 표현</li></ul></li></ul><ul id="7f89114a-88e3-4948-91ae-e06ada268c32" class="bulleted-list"><li style="list-style-type:disc">단점 <ul id="7834aa9b-3e39-44f9-bf5e-e2a77b1d0bea" class="bulleted-list"><li style="list-style-type:circle">어떤 문자열의 길이를 알려면 배열을 끝까지 훑어야함. O(N)</li></ul></li></ul><h2 id="d04a8e1f-a122-49bd-bda8-45de5f0b7cdc" class="">문자열 길이 구하기</h2><p id="1f04a0cd-d909-4505-a303-c66c5ce2ce07" class="">⇒ 스스로 작성할 수 있어야함! 매우 흔한 기초 면접문제! 못 맞추면 곧바로 탈락각..</p><h3 id="72ad50a8-76cc-4a01-ab3e-fe9ab49ebd56" class="">문자열 길이를 위한 기본 개념</h3><p id="6d246c99-5fa9-4c56-b587-3583289c4531" class="">1) char 배열의 요소를 처음부터 차례로 읽음</p><p id="a9659b10-8bb0-46aa-a689-aa25fdd672af" class="">2) 널 문자를 만나면 멈춤</p><p id="00a9ac54-02af-46ab-b3e0-2dd9c236ac54" class="">3) 여태까지 총 몇 개의 char를 방문했는지 카운트하여 반환<div class="indented"><pre id="6b13e640-8a83-4abc-8ab0-26fd27d91066" class="code"><code>size_t get_string_length(const char* str)
    {
        size_t i;
        for (i = 0; str[i] != &#x27;\0&#x27;; ++i) {
        }
        
        return i;
    }</code></pre><p id="5456f029-7fc1-4cf2-aa7b-45ae64a47c58" class="">⇒ 이 경우 반복문의 매 회차마다 시작주소 + i 만큼 점프</p><pre id="0616eb16-0e88-4072-948c-71a0ea238b8e" class="code"><code>/* 코드 1 */
    
    size_t get_string_length(const char* str)
    {
        const char* p = str;
    
        while (*p++ != &#x27;\0&#x27;) {
        }
        
        return p - str - 1;         /* p에서 시작위치(str)을 빼줌, -1은 널 캐릭터 */
    }
    
    /* 코드 2 */
    
    size_t get_string_length(const char* str)
    {
        size_t count = 0;
        const char* p = str;
    
        while (*p++ != &#x27;\0&#x27;) {
            ++count;
        }
        
        return count;
    }</code></pre><p id="8b71527a-290e-4492-bb4b-ab97a05f65a7" class="">⇒ 포인터를 이용한다면 조금 더 효율적인 코드 작성 가능</p></div></p><h3 id="2c1f869d-4cbe-4b9f-b9be-cc9af8618555" class="">문자열 길이 함수 : strlen()</h3><pre id="6e71f33b-3e2e-4221-ac35-f93c3d427ca5" class="code"><code>size_t strlen(const char* str);</code></pre><ul id="9a0bf6f9-02a6-4b4e-85b0-87e6cc4fe4ba" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>를 인클루드하면 사용할 수 있음</li></ul><ul id="7adfd6b3-21eb-4adf-bb2f-c9cc2a03855d" class="bulleted-list"><li style="list-style-type:disc">위에서 만든 코드와 거의 유사함</li></ul><h3 id="a72bc13a-0803-4b83-a9d5-810b1557b894" class="">strlen 함수 사용시 가능한 실수 예제</h3><pre id="5612ab05-d665-4d97-b94f-37e1baa47dbe" class="code"><code>char str[] = { &#x27;P&#x27;, &#x27;O&#x27;, &#x27;C&#x27;, &#x27;U&#x27; }
    size_t len;
    
    len = strlen(str);
    printf(&quot;%d\n&quot;, len);
    
    /* 19 -&gt; 잘못된 값 */</code></pre><pre id="23d62af9-ae27-4424-8ad2-ecd1e5b76a04" class="code"><code>#define BUFFER_LENGTH (4)
    
    char str[BUFFER_LENTH];
    size_t len;
    
    str[0] = &#x27;P&#x27;;
    str[1] = &#x27;O&#x27;;
    str[2] = &#x27;C&#x27;;
    str[3] = &#x27;U&#x27;;
    
    len = strlen(str);
    printf(&quot;%d\n&quot;, len);
    
    /* 13 -&gt; 잘못된 값 */</code></pre><p id="819b14ea-05eb-4180-85d9-8d614086134e" class="">⇒ 문자열의 맨 끝이 &#x27;<code>\0</code>&#x27;으로 끝나지 않아서 발생하는 문제들임</p><ul id="cd74abb4-8a7a-4e8f-a713-b999d83e820a" class="bulleted-list"><li style="list-style-type:disc">외부에서 들어오는 문자열을 읽을 땐 조심해서 읽어야함</li></ul><ul id="387cad64-75a4-46a4-8976-80041672fc4c" class="bulleted-list"><li style="list-style-type:disc">C11의 <code>strlen_s()</code> 함수가 이 문제을 해결하기도 함</li></ul><ul id="bd3a76ed-0f8b-47cc-8a30-049f4c38d346" class="bulleted-list"><li style="list-style-type:disc"><code>strlen(str)</code>은 그냥 읽는거니 안전할 수도 있음 → 물론 아닐 수도 있음<p id="75a9059f-fb55-489f-9f38-07709ba071c9" class="">⇒ 나중에 &#x27;<code>/0</code>&#x27;이 나오지 않아 하드웨어가 보호하는 메모리를 읽는 경우 심각한 오류가 발생</p></li></ul><h2 id="ac0994aa-3f7b-4c18-9aa0-a54fd12f4705" class="">문자열의 비교 : compare_string()</h2><pre id="a052956d-3f52-4366-840b-9f35a724b206" class="code"><code>_______ compare_string(cost char* str0, const char* str1);</code></pre><ul id="0eb3d6fb-83ee-40af-ac66-bf7754ce72c7" class="bulleted-list"><li style="list-style-type:disc">두 문자열 비교를 위한 매개변수는 두 문자열 포인터</li></ul><ul id="f8159bb5-3b9f-4fed-835d-37cbfd5497c2" class="bulleted-list"><li style="list-style-type:disc">반환형은 아직 미정</li></ul><ul id="ddd39cc1-f89d-4fc9-ae9e-a7148f8e8b05" class="bulleted-list"><li style="list-style-type:disc">단순히 같다/틀리다를 비교하는 것이 아님</li></ul><ul id="394fe42d-5b33-4aa3-b912-3f5d614f6fc1" class="bulleted-list"><li style="list-style-type:disc">사전식 순서(lexicographical order)로 &#x27;어떤 문자의 아스키코드가 더 작냐/크냐/같냐/&#x27;를 판별</li></ul><h3 id="d480a1d7-55f4-4dac-923b-0825cc3e6a7e" class="">사전식 순서의 예</h3><p id="fc380c79-c920-4e79-803b-94a5818f4cad" class="">1) ABCD는 ABCE보다 작음</p><p id="c50fc274-6eca-4caa-b6b3-1d2bd2fa646c" class="">2) abcd는 ABCD보다 큼</p><p id="546a0067-86a4-4ef4-a114-3909e7e8753f" class="">3) ABC는 ABCEFG보다 작음<div class="indented"><p id="92493080-15a3-4faa-9208-4db198895302" class="">Why? 길이가 짧음 (ABC의 숨겨진 마지막 문자인 널문자와 ABCEFG의 E와 비교한다고 생각 가능)</p></div></p><p id="12681e45-1dca-455e-b569-64163ebb961d" class="">4) abcd는 abcd와 같음</p><h3 id="7bd661b4-4452-4628-99cb-9eac724a6a16" class="">compare_string()의 반환값</h3><pre id="90a6c42a-34f9-4c5c-a657-e3939143a7e6" class="code"><code>int compare_string(const char* str0, const char* str1);</code></pre><ul id="5e0d867d-0424-4b9f-90fd-c4db376e7be2" class="bulleted-list"><li style="list-style-type:disc">같으면 0</li></ul><ul id="faf5d888-d25c-44cb-9e97-15e02364964c" class="bulleted-list"><li style="list-style-type:disc">좌항이 작으면 &lt; 0</li></ul><ul id="6f290a87-87c8-4a98-830a-31df26a32e77" class="bulleted-list"><li style="list-style-type:disc">좌항이 크면 &gt; 0</li></ul><ul id="e8b13aa9-4afd-47c4-86ca-bccd92acb3f3" class="bulleted-list"><li style="list-style-type:disc">음수도 반환하니 반환형은 int</li></ul><pre id="bc2d4be7-717c-46e3-9811-646a2a6334d7" class="code"><code>const char* str1 = &quot;AB&quot;;
    const char* str2 = &quot;AC&quot;;
    int result = compare_string(str1, str2);</code></pre><p id="61723654-a873-4f4b-b2c0-2261ba675a7f" class="">1) 두 문자열에서 문자를 하나씩 (c0, c1) 읽음</p><p id="a23a9a16-b9f4-4911-a0d1-0b20abb7bc2d" class="">2) 두 문자를 비교</p><ul id="ae90d58e-ee2a-4de0-981f-550e438edf28" class="bulleted-list"><li style="list-style-type:disc">c0이 c1보다 작으면 음수로 반환</li></ul><ul id="b1991ae0-9519-450e-bed4-9acdc954d7f4" class="bulleted-list"><li style="list-style-type:disc">c0이 c1보다 크면 양수로 반환</li></ul><ul id="b4ca5640-a140-4ee2-8f8f-21df1b72e024" class="bulleted-list"><li style="list-style-type:disc">(c0과 c1이 같고) 널 문자면 0을 반환</li></ul><p id="3a9b0a54-f919-4420-908b-a37a0b0a164b" class="">3) 다음 문자로 이동 후, 1번 단계로 돌아감</p><h3 id="76ee06d2-9d6d-4c5a-a5d6-b1343dab5b52" class="">더 효율적인 문자열 비교 함수 작성하기</h3><pre id="456c5896-4da6-4b49-939b-db8f7a640187" class="code"><code>/* 방법 1 */
    
    int compare_string(const char* str0, const char* str1)
    {
        while (*str0 != &#x27;\0&#x27; &amp;&amp; *str0 == *str1) {               
        /* *str0 != &#x27;\0&#x27;과 *str1 != &#x27;\0&#x27; 둘 중 하나만 넣어도 조건이 성립됨 */
            ++str0;
            ++str1;
        }
    
        return *str0 - *str1
    }</code></pre><pre id="a2d91723-bfe5-4bec-a666-d3958bf684b1" class="code"><code>/* 방법 2 */
    
    int compare_string(const char* str0, const char* str1)
    {
        while (*str0 != &#x27;\0&#x27; &amp;&amp; *str0 == *str1) {
            ++str0;
            ++str1;
        }
    
        if (*str0 == *str1) {
            return 0;
        }
    
        return *str0 &gt; *str1 ? 1 : -1;
    }</code></pre><ul id="fac11328-5597-4c47-96f9-1537da7e3043" class="bulleted-list"><li style="list-style-type:disc">문자열 비교 함수는 왠지 if문이 많을 것 같지만 간단하게 작성이 가능함</li></ul><pre id="d6638989-d24d-44f9-b30f-b09de45e7e51" class="code"><code>int compare_string(const char* str0, const char* str1)
    {
        size_t i;
        size_t len0 = strlen(str0);
        size_t len1 = strlen(str1);
    
        if (len0 != len1) {
            for (i = 0; i &lt; min(len0, len1); ++i) {
                /* 달라지면 str0[i] - str1[i] 반환 */
            }
            /* len0, len1에 따라 -1 또는 1 반환 */
        }
    
    
        for (i = 0; i &lt; len0; ++i) {
            /* 달라지면 str0[i] - str1[i] 반환 */
        }
        return 0;
    }</code></pre><ul id="9d3ed654-391c-456a-abff-c5a67faa4abb" class="bulleted-list"><li style="list-style-type:disc">위의 코드는 <code>strlen()</code>을 구하는 과정에서 for문을 사용하기 때문에 불필요하게 for문을 여러 번 돌려 원하는 반환값을 구해냄 → 한번의 for문으로 가능한 것을 굳이 느리게 할 필요없음</li></ul><h3 id="6ca20535-a5e3-40c7-bdf9-05fc31102bc3" class="">문자열 비교 함수 1 : strcmp()</h3><pre id="6efbe15a-cf92-49b8-9180-d99a0110e53a" class="code"><code>int strcmp(const char* lhs, const char* rhs);</code></pre><ul id="b208fae5-3e18-4f63-aecd-46689a290056" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>를 인클루드하면 사용할 수 있음</li></ul><pre id="67537e1e-9303-4520-8e94-6498433a35b5" class="code"><code>#include &lt;string.h&gt;
    
    const char* str1 = &quot;AB&quot;;
    const char* str2 = &quot;AD&quot;;
    int result = strcmp(str0, str1);</code></pre><h3 id="c0387ae3-1076-49ad-9301-9aa056a1b0bc" class="">문자열 비교 함수 2 : strncmp()</h3><pre id="299d6d92-d8a0-422a-90a9-5f6975b60c32" class="code"><code>int strncmp(const char* lhs, const char* rhs, size_t count);</code></pre><ul id="b6084a00-f0e4-488b-9a79-e547fbbeca18" class="bulleted-list"><li style="list-style-type:disc">최대 n문자까지만 비교</li></ul><h3 id="3b83d428-7e3b-493d-81a2-cff10815c813" class="">대소문자 구분 없는 문자열 비교</h3><pre id="0342a4c2-91a9-4efc-b1eb-fa89b9d817fb" class="code"><code>#incldue &lt;ctype.h&gt;
    
    #include &quot;string_utils.h&quot;
    
    int string_case_insensitive_compare(const char* str0, const char* str1)
    {
        int c1;
        int c2;
    
        c1 = tolower(*str0);
        c2 = tolower(*str1);
    
        while (c1 != &#x27;\0&#x27; &amp;&amp; c1 == c2) {
            c1 = tolower(*++str0);
            c2 = tolower(*++str1);
        }
        
        if (c1 == c2) {
            return 0;
        }
        
        return c1 &gt; c2 ? 1 : -1;
    }</code></pre><h2 id="eb2f69a5-c139-4653-a057-aab9f08e2998" class="">문자열 복사</h2><pre id="3d53c745-7a7e-41bd-8558-fb603288c9ee" class="code"><code>void copy_string(char* dest, const char* src)
    {
        while (*src != &#x27;\0&#x27;) {
            *dest++ = *src++;
        }
        
        *dest = &#x27;\0&#x27;;
    }
    
    /* 다른 함수 */
    const char* str1 = &quot;Pope&quot;;
    char str2[5];
    
    copy_string(str2, str1);</code></pre><h3 id="72c73122-5f3e-47b9-9920-2b84576737ba" class="">문자열 복사 함수 1 : strcpy()</h3><pre id="fa270789-fbed-47fe-946b-fc3bf1e99b64" class="code"><code>char* strcpy(char* dest, const char* src);</code></pre><ul id="ac989b5b-2af4-417c-a82b-ccf397e2c507" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>를 인클루드하면 사용할 수 있음</li></ul><ul id="b01e163a-eeae-4be6-a394-9cb8a1b66e13" class="bulleted-list"><li style="list-style-type:disc">반환값 <code>char*</code>는 <code>dest</code>를 반환 → 왜 그런지는 알 수 없음, 실제로 아무도 안 씀</li></ul><ul id="1249e77b-aa49-44ec-bd11-12c3caec10f8" class="bulleted-list"><li style="list-style-type:disc">C11에서 나온 <code>strcpy_s()</code>는 <code>errno_t</code>를 반환<pre id="84f7f19c-5545-41d4-913c-8eb7a27f2e46" class="code"><code>/* C11 */
    errno_t strcpy_s(char *restrict dest, resize_t destsz, const char *restrict src);</code></pre></li></ul><h3 id="11485e3f-425a-4808-9837-3aa72474f529" class="">dest가 src보다 짧으면</h3><pre id="9e3de373-6f3c-4888-a1b6-e45b53601a84" class="code"><code>const char* str1 = &quot;Pope&quot;;
    char str2[3];
    
    string_copy(str2, str1);</code></pre><ul id="cb84b959-1ec0-454f-aa59-271461c6f9bf" class="bulleted-list"><li style="list-style-type:disc">남은 메모리에 덮어써버림 → 매우 위험한 함수</li></ul><ul id="4291d8ed-52a4-4ed1-af2c-62b4939adc65" class="bulleted-list"><li style="list-style-type:disc">단, <code>src</code>와 <code>dest</code>의 크기가 확실하게 통제 가능하다면 안전</li></ul><ul id="786cf181-9161-41e7-91a8-fa3fce517021" class="bulleted-list"><li style="list-style-type:disc">C11에서 이보다 안전한 <code>strcpy_s()</code>라는 함수가 나옴</li></ul><h3 id="b1f18f22-928f-4a73-8d57-c9aad1948209" class="">문자열 복사 함수 2 : strncpy()</h3><p id="aab2d765-c21e-4586-a37e-aac77e411840" class="">⇒ C89에서 그나마 안전한 문자열 복사 함수</p><pre id="4fa641e8-2307-45c7-ad4e-50cbad2563ac" class="code"><code>char* strncpy(char* dest, const char* src, size_t count);</code></pre><ul id="9b5ed791-da63-4c08-a67e-05f3f248bcdb" class="bulleted-list"><li style="list-style-type:disc">최대 count만큼 복사 / 널 문자를 먼저 만나면 그 전에 끝냄</li></ul><ul id="e00ff6db-2483-4478-9fd5-39e53c407d0e" class="bulleted-list"><li style="list-style-type:disc">src가 count보다 짧으면 <strong>남은걸 다 0 (&#x27;</strong><strong><code>\0</code></strong><strong>&#x27;)으로 채워줌</strong></li></ul><ul id="6ac54f3f-e114-4124-8fc9-263ccd56ddb1" class="bulleted-list"><li style="list-style-type:disc">src가 count보다 길거나 같다면 count만큼 복사함 → 널 문자 붙일 곳 없음</li></ul><pre id="53328fd6-e177-491f-95ff-b8fd71489772" class="code"><code>strncpy(dest, src, DEST_SIZE);
    dest[DEST_SIZE -1] = &#x27;\0&#x27;;</code></pre><ul id="97307c46-52cf-4933-89c0-4751888d22f4" class="bulleted-list"><li style="list-style-type:disc"><strong>비교적 안전한 프로그래밍을 위해 언제나 코드 한 줄을 추가</strong></li></ul><ul id="4815e380-6fc9-4aeb-89b7-8caafd75a862" class="bulleted-list"><li style="list-style-type:disc">0이 앞에 붙으면 어차피 멈춤</li></ul><ul id="efcd22b7-6faa-4751-99bb-50439e67763b" class="bulleted-list"><li style="list-style-type:disc">안 붙었으면 맨 마지막에 널 문자를 붙여줌</li></ul><h3 id="12829681-7e49-441c-9838-38bae453c459" class="">정리 : strcpy()와 strncpy()</h3><ol type="1" id="5f522c24-8639-48ad-8852-c309d1cbe4ae" class="numbered-list" start="1"><li><code>strcpy()</code><ul id="4e5e78eb-ed45-42c6-ae84-4248f514674a" class="bulleted-list"><li style="list-style-type:disc">위험할 수 있는 함수</li></ul><ul id="1e861eff-2800-424c-9892-69d44548f9e3" class="bulleted-list"><li style="list-style-type:disc">dest 크기 &lt; src 크기 : 잘못된 메모리 쓰기 발생</li></ul><ul id="ba35b264-c1ce-49ab-8bb3-7c599ca52f15" class="bulleted-list"><li style="list-style-type:disc">두 크기를 확실히 통제 가능하다면 안전</li></ul></li></ol><ol type="1" id="16aa3036-b5ff-4af9-87dc-fed34b20e8b4" class="numbered-list" start="2"><li><code>strncpy()</code><ul id="e97c3e43-6f04-4f81-8a31-074008ec3c66" class="bulleted-list"><li style="list-style-type:disc">strcpy( )보다 안전</li></ul><ul id="4a766d77-d12a-4593-8163-4a8fd48e6c02" class="bulleted-list"><li style="list-style-type:disc"><strong>덜 빠름 → dest의 남은 요소를 0으로 채우기 때문</strong></li></ul><ul id="6213df10-266b-43a1-817f-bf614c02a700" class="bulleted-list"><li style="list-style-type:disc">여전히 위험한 경우가 있음<p id="0df84664-c6c0-4056-8c1d-0ebe831a0efd" class=""><strong>count보다 src가 긴 경우 : 다 복사하고 널 문자가 없음 → 프로그래머가 널 문자를 넣어주는 한줄 코드가 필요함</strong></p></li></ul></li></ol><h2 id="8d436912-154d-4110-b90b-2459780c0e4a" class="">문자열 합치기</h2><h3 id="1bb5f36a-53a8-4cec-90af-7ee1215b4a9a" class="">문자열 합치기 함수 1 : strcat()</h3><pre id="1b9892aa-9d73-420e-b77e-23117b84437e" class="code"><code>char* strcat(char* dest, const char* scrc);</code></pre><ul id="768eedea-0c28-4219-8f00-e6f07925fa3a" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>안에 있음</li></ul><ul id="4fbc1520-0b8f-4705-8620-551d24879693" class="bulleted-list"><li style="list-style-type:disc"><code>src</code>의 문자열을 <code>dest</code> 뒤에 덧붙이는 함수 (<code>dest</code>의 널 문자 위치부터 <code>src</code>의 문자열 추가)<p id="728e169f-3641-440a-b84d-1a61e17d50b1" class="">⇒ <code>dest</code>의 널 문자가 <code>src[0]</code>로 교체</p></li></ul><ul id="139ecf47-da79-40d7-9612-9bac003729d6" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code>의 길이가 충분해야함<p id="c4c5f003-37f3-49f6-bc04-6232c7a3d4e1" class="">⇒ 이 길이를 넘어 쓸 경우 정의되지 않은 결과 발생</p></li></ul><h3 id="51c2bfcf-56b6-49df-94b3-9c48375099d0" class="">문자열 합치기 함수 2 : strncat()</h3><pre id="3395b254-9d91-43e4-9bb5-79b5ae61a2a4" class="code"><code>char* strncat(char* dest, const char* src, size_t count);</code></pre><ul id="d51b7dab-f825-43cd-8338-be06c9d62467" class="bulleted-list"><li style="list-style-type:disc"><code>strcat()</code>보다 조금 더 안전한 함수</li></ul><ul id="e660d715-3f6d-4006-bfe0-7ee9e9c4ec48" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>안에 있음</li></ul><ul id="34c2d64e-927f-4751-b076-f867e50f059a" class="bulleted-list"><li style="list-style-type:disc"><strong>최대 count의 수만큼 </strong><code>src</code><strong>문자열</strong>을 <code>dest</code> 뒤에 덧붙이는 함수</li></ul><ul id="93a13cec-d7ab-427b-8295-386795f476f6" class="bulleted-list"><li style="list-style-type:disc">count개의 문자를 복사한 뒤, 널 문자를 가장 마지막에 붙여줌<p id="0fc6c5b0-cdb4-48f0-be53-9d3a72f54d38" class="">⇒ 따라서 <strong>최대 count +1 개</strong>의 문자를 덮어씀</p></li></ul><pre id="490a336d-d27e-42b8-9d18-c7afd7e9df15" class="code"><code>#define DEST_COUNT (20)
    
    const char* src = &quot;HONG&quot;;
    char dest[DEST_COUNT] = &quot;HI &quot;;
    
    strncat(dest, src, DEST_COUNT - strlen(dest) - 1);</code></pre><ul id="85f2807b-1d70-4821-bd10-d9ed595c2d3e" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code>의 길이보다 길게 쓰면 마찬가지로 정의되지 않은 결과 발생<ul id="64d8dcff-3991-4e60-977d-90b1558634f9" class="bulleted-list"><li style="list-style-type:circle">그러나 count로 이러한 경우가 발생하지 않도록 프로그래머가 제어 가능</li></ul><ul id="90bffa4b-c8fa-49b1-9ff1-8082d418724e" class="bulleted-list"><li style="list-style-type:circle">따라서 <code>strcat()</code>보다는 조금 더 안전</li></ul></li></ul><h3 id="6f84c963-298f-4b1f-8f87-83596e9dd29f" class="">정리 : strcat()와 strncat()</h3><ol type="1" id="2c47b7ab-659a-4cdf-b1bc-c60e98869bcf" class="numbered-list" start="1"><li><code>strcat()</code><ul id="2b31fa3e-de65-4b22-82c4-9e8b533f49cd" class="bulleted-list"><li style="list-style-type:disc">위험할 수 있는 함수</li></ul><ul id="9d8c9fc9-2f6a-4367-877f-b56ce80dd259" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code>의 남아있는 공간 &lt; <code>src</code>의 크기 → 정의되지 않은 결과 발생</li></ul><ul id="321397f0-2672-495c-8e37-dee3db43fc9b" class="bulleted-list"><li style="list-style-type:disc">두 크기를 확실히 통제할 수 있다면 안전</li></ul></li></ol><ol type="1" id="7912cd5d-ba84-443b-8821-850ed05766e1" class="numbered-list" start="2"><li><code>strncat()</code><ul id="6b9c1c85-20f3-4b02-ae74-73d966854655" class="bulleted-list"><li style="list-style-type:disc"><code>strcat()</code>보다 안전 → count로 얼만큼 붙일지 제어 가능</li></ul><ul id="76e51653-5bc0-4cf0-9d40-06db16253add" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code>의 남아있는 공간 &lt; count의 크기 → 정의되지 않은 결과 발생</li></ul></li></ol><p id="2fc0adc5-825b-40f5-9088-f2bcb9bbb055" class="">⇒ C11에서 이보다 안전한 <code>strcat_s()</code>, <code>strncat_s()</code> 함수가 있음</p><h3 id="589e875a-93c3-4cd3-9c65-722ea0b9028e" class="">문자열 버퍼를 이용한 출력</h3><pre id="d9c08262-f00f-4324-8321-2f21b4116cc3" class="code"><code>#include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    
    #include &quot;buffered_print.h&quot;
    
    #define BUFFER_LENGTH (32)
    
    static size_t s_buffer_index = 0u;
    static char s_buffer[BUFFER_LENGTH];
    
    void buffered_print(const char* src)
    {
        size_t num_left;
        const char* p = src;
    
        num_left = strlen(src);
    
        while (num_left &gt; 0) {
            size_t copy_count = BUFFER_LENGTH -1 - s_buffer_index;
            
            const int buffer_emthy = s_buffer_indes == 0;
    
            if (num_left &lt; copy_count) {
                copy_count = num_left;
            }
            
            s_buffer_index += copy_count;
            num_left -= copy_count;
    
            if (buffer_emthy) {
                strncpy(s_buffer, p, copy_count);
                s_buffer[s_buffer_index] = &#x27;\0&#x27;;
            } else {
                strncat(s_buffer, p, copy_count);
            }
            
            p += copy_count;
    
            if (s_buffer_indes == BUFFER_LENGTH -1 ) {
                printf(&quot;%s\n&quot;, s_buffer);
                s_buffer_index = 0;
            }
        }
    }</code></pre><h2 id="abffedb1-2189-4105-a831-7bde1a64cc9c" class="">문자열 찾기</h2><h3 id="37499dcb-b587-4240-8a3f-42a54d3b46df" class="">없는 문자열을 찾는 경우</h3><pre id="97670978-6df5-4bf9-8122-80a3b2eccc4b" class="code"><code>#include &lt;string.h&gt;
    
    int main(void)
    {
        char msg[] = &quot;I love string! I love C! I love programming!&quot;;
        
        char* result = strstr(msg, &quot;int&quot;);
        printf(&quot;result: %s\n&quot;, result);
    
        return 0;
    }</code></pre><pre id="9b103d31-b908-41df-996c-2bb9c9e5d5fb" class="code"><code>#include &lt;string.h&gt;
    
    int main(void)
    {
        char msg[] = &quot;I love string! I love C! I love programming!&quot;;
        
        char* result = strstr(msg, &quot;int&quot;);
        printf(&quot;result: %s\n&quot;, result == NULL ? &quot;(null)&quot; : result);
    
        return 0;
    }</code></pre><h3 id="4bd5eb18-a3de-43f2-8a68-9ebbb252a182" class="">존재하는 문자열을 찾는 경우</h3><pre id="fb3a8971-9ef0-43ef-a78e-a26a1e9918ea" class="code"><code>#include &lt;string.h&gt;
    
    int main(void)
    {
        char msg[] = &quot;I love string! I love C! I love programming!&quot;;
    
        char* result = strstr(msg, &quot;string&quot;);
        printf(&quot;result: %s\n&quot;, result == NULL ? &quot;(null)&quot; : result);
    
        return 0;
    }</code></pre><h3 id="062769b5-ce2f-4b88-90d0-20507680f478" class="">문자열 속에서 문자열 찾기</h3><pre id="52e7c486-c9b3-457c-849b-005a10bb4091" class="code"><code>char* strstr(const char* str, const char* substr);</code></pre><ul id="d5546215-13f3-4be0-a2de-23d4f33ccdd7" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;string.h&gt;</code>안에 있음</li></ul><ul id="c079d5c5-d075-43d0-816d-ba8c9470e437" class="bulleted-list"><li style="list-style-type:disc">반환값 : <code>char</code> 포인터<ul id="c742ce20-80e4-4ac8-afaa-8b7c17a8f7bb" class="bulleted-list"><li style="list-style-type:circle"><code>substr</code>이 <code>str</code>에 있다면 : 해당 <code>substr</code>이 시작하는 주소</li></ul><ul id="f33b59df-953b-498e-85d6-5adbac2af7d5" class="bulleted-list"><li style="list-style-type:circle">substr이 str에 없다면 : 널 포인터(NULL)</li></ul></li></ul><h3 id="03af76d8-4b9f-4ba5-a32e-fc9a089adf48" class="">문자열 찾기의 주소반환</h3><ul id="311d403b-ffce-4b5d-a7dd-4c6fb313d2e6" class="bulleted-list"><li style="list-style-type:disc">C#의 <code>string.IndexOf()</code>처럼 문자열의 색인을 반환하지 않고, 그렇다고 찾은 위치부터 문자열을 새로 만들어 주는것도 아닌 <strong>찾은 위치의 주소</strong>를 알려줌<p id="3ee52b0a-ddaf-462e-a9a2-f6a62b846a4d" class="">⇒ Why? <strong>새로운 문자열을 만들어 반환할 경우 메모리 관리 측면에서 효율적이지 못하고 실수할 수 있음</strong></p></li></ul><ul id="bf3b9e7a-a044-4cd3-8325-e98e71a94867" class="bulleted-list"><li style="list-style-type:disc">새 문자열을 반환하려면 메모리 어딘가에 그 문자열을 복사해야함<ul id="f8dfce54-463d-49e2-bc04-50f016157691" class="bulleted-list"><li style="list-style-type:circle">복사하는 위치가 <strong>스택</strong>이면 <pre id="97563085-2369-4203-8846-c00688e8279e" class="code"><code>char* strstr(const char* str, const char* substr)
    {
        /* 코드 생략 */
        char result[] = str에서_찾은_substr_부터_나머지; /* &quot;string! I love C!&quot; */
    
        return result;   /* 함수가 끝나는 순간 유효하지 않음 */
    }
    
    char msg[] = &quot;I love string! I love C!&quot;;
    char* result = strstr(msg, &quot;string&quot;);  /* 유효하지 않은 주소를 받음 */</code></pre><p id="a4910a20-ef88-4187-b4cc-f619fc15ca68" class="">⇒ 함수가 끝나면 사라짐 </p><p id="5cfb6667-ab8b-4cea-8bdb-53307984c52d" class="">⇒ 반환값이 더이상 유효하지 않은 메모리 주소</p></li></ul><ul id="53284706-c439-4b73-a05d-5f2167deb32c" class="bulleted-list"><li style="list-style-type:circle">복사하는 위치가 <strong>힙</strong>이면 (동적메모리 할당) <pre id="2e7b024f-d3d1-40a9-ab34-d47b545ad2f6" class="code"><code>char* strstr(const char* str, const char* substr)
    {
        /* 코드 생략 */
        char* result = malloc();   /* OS에게 메모리 할당 요청. 매우 단순화시킨 예 */
        /* result에 &quot;string! I love C!&quot; 복사 */
        return result;   
    }
    
    char msg[] = &quot;I love string! I love C!&quot;;
    char* result = strstr(msg, &quot;string&quot;);   /* 유효한 주소를 받음 */
    free(result);                           /* 더이상 사용 안하면 반드시 호출해야 함 */</code></pre><p id="328acc46-0354-4668-af58-be1d7149bee5" class="">⇒ 메모리 할당을 운영체제에게 부탁해야하므로 느림</p><p id="ebc8c48c-ca59-4dfa-9987-f43af2d26a51" class="">⇒ 더이상 사용하지 안 할 경우 프로그래머가 직접 메모리 해제 함수를 호출해야하는데 깜빡 잊고 하지 않을 수도 있음</p></li></ul></li></ul><ul id="c98edbbe-8225-4103-98e0-3a46b8799bca" class="bulleted-list"><li style="list-style-type:disc">그냥 원본에서 찾고자 하는 문자열이 시작하는 주소를 반환하는 것로 간단하게 해결</li></ul><ul id="168e2cfa-9d9a-4533-9347-b818550e753f" class="bulleted-list"><li style="list-style-type:disc">추가적으로 메모리를 쓰지도 않고, 사람이 저지를 수 있는 실수도 줄일 수 있음</li></ul><h2 id="56470354-d51c-4055-b0ea-5f3e839ff0bd" class="">문자열 토큰화</h2><pre id="2cebfc3b-ac5d-4056-9937-01d9e44ee781" class="code"><code>char* strtok(char* str, const char* delims);</code></pre><ul id="57dec821-af4f-4dff-a90f-adc6de8f49c5" class="bulleted-list"><li style="list-style-type:disc">C의 토큰화 함수는 지금까지 본 문자열 함수처럼 <strong>새로운 메모리에 할당 안함</strong></li></ul><pre id="cbc583c7-9d47-402f-9f77-8c69e9daea90" class="code"><code>char msg[] = &quot;Hi, there. Hello. Bye&quot;;
    const char delims[] = &quot;,. &quot;
    
    char* token = strtok(msg, delims);
    while (token != NULL) {
        printf(&quot;%s\n&quot;, token);
        token = strtok(NULL, delims);
    }
    
    /*
    Hi
    there
    Hello
    Bye
    */</code></pre><ul id="6772a638-d672-464d-ab06-44a9b72ade02" class="bulleted-list"><li style="list-style-type:disc">토큰화를 시작하려면 문자열(msg)를 <code>strtok()</code>에 넣음</li></ul><ul id="d9928637-c8f9-4a05-a6da-0f5185e85df9" class="bulleted-list"><li style="list-style-type:disc">그 msg의 다음 토큰을 구하려면 대신 <code>NULL</code></li></ul><ul id="1cf854ef-ca51-4745-94aa-048add056ca7" class="bulleted-list"><li style="list-style-type:disc">더 이상 토큰이 없다면 <code>strtok()</code>은 <code>NULL</code>을 반환</li></ul><ul id="40058bba-53bf-4d08-913d-c6896a96db43" class="bulleted-list"><li style="list-style-type:disc">두 가지 포인트<p id="3a7c5fda-b3a3-4fb5-b5c7-7fd9663259bf" class="">1) 토큰화 하는 문자열은 <code>const</code>가 아님! → <strong>원본이 바뀜</strong></p><p id="2f3ad1b9-7c59-4071-8358-92640efbf04f" class="">2) 함수 매개변수로 <code>NULL</code>이 들어올 때 그 전에 받았던 msg를 사용하니 이건 어딘가에 저장되어 있어야 함</p></li></ul><ul id="8765c375-168f-41ae-adda-b25598e5692d" class="bulleted-list"><li style="list-style-type:disc">C11에 안전한 버전의 함수가 들어옴 → <code>strtok_s()</code></li></ul><h2 id="3ecd7b33-09c3-45ba-b18c-b56b8c985e2b" class="">&lt;string.h&gt;에 있는 문자열 함수들</h2><ul id="b60d90dd-b543-425e-afe5-5dd650fdc216" class="bulleted-list"><li style="list-style-type:disc"><code>strlen()</code></li></ul><ul id="554e2500-72b1-486a-805b-b326d8109a58" class="bulleted-list"><li style="list-style-type:disc"><code>strcmp()</code> / <code>strncmp()</code></li></ul><ul id="5539da74-6d50-48c4-aa06-cc359db46b5a" class="bulleted-list"><li style="list-style-type:disc"><code>strcpy()</code> / <code>strncpy()</code></li></ul><ul id="42056b54-7ac2-47e8-95a7-405b783c3bc9" class="bulleted-list"><li style="list-style-type:disc"><code>strstr()</code></li></ul><ul id="da1a3ae5-64a8-487e-9ed5-553672d4958b" class="bulleted-list"><li style="list-style-type:disc"><code>strcat()</code> / <code>strncat()</code></li></ul><ul id="c5cb2b80-c74b-4515-b023-63a967e110b9" class="bulleted-list"><li style="list-style-type:disc"><code>strtok()</code></li></ul><ul id="edde905d-b1cb-46cb-92ee-22386aa95d9f" class="bulleted-list"><li style="list-style-type:disc">그 외 다수</li></ul><h2 id="e87760ca-c042-4e5c-86cc-5412600427c1" class="">C 문자열 함수들의 특징</h2><ul id="6345c1c8-2bd5-488d-b60f-3d98eb3fbac7" class="bulleted-list"><li style="list-style-type:disc">꽤 많은 함수들이 문자열을 절대 변경하지 않음!<p id="64e4ce3d-e717-41e5-8291-ccf365f5c3f6" class="">⇒ <code>const char*</code> 표시 필요</p></li></ul><ul id="9804f7c2-017f-4227-9b78-4580231c4aa6" class="bulleted-list"><li style="list-style-type:disc">문자열을 변경하더라도 원본은 변경하지 않으려 함 → 사본만 변경<p id="4aadd71a-d2d7-4fd3-9dae-1def335f9a41" class="">⇒ 예외 : <code>strtok()</code> → 원본을 지키려면 호출하는 함수에서 사본을 만든 뒤 <code>strtok()</code> 호출해야함</p></li></ul><ul id="6c618735-8034-4a30-8bb4-8bc66b13d72e" class="bulleted-list"><li style="list-style-type:disc">절대 새로운 문자열(즉, 연속된 <code>char</code>)을 만들어주지 않음</li></ul><h2 id="c9944e44-5f9a-4ea3-a2db-91e743657d91" class="">문자열을 대문자 또는 소문자로 바꾸기</h2><pre id="1f0592fc-dea5-44e5-a0df-f69b9eb2fb7d" class="code"><code>#include &quot;string_utils.h&quot;
    
    int is_alpha(int c)
    {
        return (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;);
    }
    
    int to_upper(int c)
    {
        if (is_alpha(c)) {
            return c &amp; ~0x20;
        }
        
        return c;
    }
    
    int to_lower(int c)
    {
        if (is_alpha(c)) {
            return c | 0x20;
        }
        
        return c;
    }
    
    void string_toupper(char* str)
    {
        while (*str != &#x27;\0&#x27;) {
            *str = to_upper(*str);
            ++str;
        }
    }
    
    void string_tolower(char* str)
    {
        while (*str != &#x27;\0&#x27;) {
            *str = to_lower(*str);
            ++str;
        }
    }</code></pre><pre id="7997112d-8c30-4968-91ad-47862412e193" class="code"><code>return c &amp; ~0x20;</code></pre><ul id="d9545446-1d2a-461b-8987-345c6ef021a2" class="bulleted-list"><li style="list-style-type:disc">비트마스킹 코드</li></ul><ul id="ffb22d62-d82e-44eb-8702-49018e4c46a1" class="bulleted-list"><li style="list-style-type:disc">0x20은 십진수 32 → 이것은 아스키 값으로 동일한 대문자와 소문자 간 차이 (예 : A와 a)</li></ul><ul id="963c3fd4-08ec-41bf-8d52-c75e11d49f4d" class="bulleted-list"><li style="list-style-type:disc">c &amp; ~0x20은 c로부터 32를 빼는 것을 의미함<p id="949f4ff3-5f19-4ba8-bb54-bdc9a639cc24" class="">1) a의 비트패턴 (<code>110 0001</code>) / z의 비트패턴 (<code>111 1010</code>)</p><p id="14de9609-6197-4734-b87e-06d002f7dac5" class="">2) a와 z 사이에 있는 모든 알파벳은 <code>110 0001</code>와 <code>111 1010</code> 사이의 값</p><p id="1ee27a7d-d898-4adc-b184-805c49774fb3" class="">3) 32의 비트패턴 (<code>10 0000</code>)</p><p id="ba55500f-154c-4db3-8781-0167037b906e" class="">4) 따라서 이 숫자를 빼버리면 오른쪽으로부터 6번째ㅉ 비트를 지우는 것과 마찬가지</p><p id="006ef31d-3609-405d-96fc-90cd4e6300f0" class="">5) <code>10 0000</code>을 뒤집으면 <code>01 1111</code>이 되고 이것을 c와 비트연산 <code>&amp;</code>를 하면 6번째 비트가 지워짐</p></li></ul><h2 id="ac9684a4-6369-4b33-8a2e-44d0d3c1de21" class="">출력(Output)</h2><ul id="952a553c-328a-42b4-b519-6d7cf9456472" class="bulleted-list"><li style="list-style-type:disc">프로그램에서 프로그램 외부로 데이터를 보여주는 행위</li></ul><ul id="e32149e0-21bc-466f-9d2f-d0ec428d5332" class="bulleted-list"><li style="list-style-type:disc">프로그램이 어떤 데이터를 출력할지 아니까 괴상한 데이터들이 없음<p id="8c2dd880-4d59-419e-9ce0-a78aaf3d07d1" class="">⇒ 입력보다 쉬움</p></li></ul><h2 id="cfd21af3-a158-4386-8e7e-ad067571d703" class="">서식 지정(formatted) 출력</h2><ul id="3a784ede-f8d8-420e-94e7-0ab1ad87e15c" class="bulleted-list"><li style="list-style-type:disc">C에서 출력을 논할때 가장 기본이 되는 함수</li></ul><ul id="9a513742-f0a7-4db7-b478-1917a1ff0f20" class="bulleted-list"><li style="list-style-type:disc">세 가지 종류<p id="71a5b2c4-5ef1-4b0d-863b-a76cb6a58ff1" class="">1) <code>printf()</code> : 콘솔창(stdout)에 출력</p><p id="ccd0f253-d001-4fad-8c13-62484e5c57b2" class="">2) <code>fprintf()</code> : 스트림에 출력 (f; file)</p><p id="afffc67b-9aed-4840-91bb-6a37274786a2" class="">3) <code>sprintf()</code> : 문자열에 출력 (s; stream)</p></li></ul><ul id="173da6df-2bdf-4fc8-9786-81546d1a03a4" class="bulleted-list"><li style="list-style-type:disc"><code>fprintf()</code>와 <code>sprintf()</code>는 <code>printf()</code>와 작동법 동일<p id="d158dea2-026e-4609-bea5-dc0eef5db43e" class="">⇒ 첫 번째 매개변수로 &#x27;출력할 곳&#x27;을 넣어주는 것이 유일한 차이점</p></li></ul><pre id="26581155-7595-400c-9ff8-4bb5d3cdc65d" class="code"><code>const char* msg = &quot;Hello HONG&quot;;
    
    /* 동일한 결과 */
    fprintf(stdout, &quot;%s\n&quot;, msg);
    printf(&quot;%s\n&quot;, msg);</code></pre><h3 id="17008201-0410-4032-b541-d805129c5ae8" class="">printf()의 첫 번째 매개변수는 문자열</h3><pre id="5ea2adec-74ba-4180-86d8-2b9e5e9e9661" class="code"><code>int score = 0;
    char ch = &#x27;j&#x27;;
    float pi = 3.14f;
    const char* name = &quot;Caty&quot;;
    
    printf(&quot;Hello POCU&quot;);         /* 컴파일 */
    printf(score);                /* 컴파일 오류 */
    printf(ch);                   /* 컴파일 오류 */
    printf(pi);                   /* 컴파일 오류 */
    printf(name);                 /* 컴파일 */</code></pre><ul id="594605fd-6b24-427f-bca6-616742ac2e59" class="bulleted-list"><li style="list-style-type:disc"><code>printf()</code>는 그냥 <code>int</code>형 변수를 넣는다고 <code>int</code>를 출력해주지 않음<p id="843df624-1b55-4380-83ba-22ea715044eb" class="">⇒ 함수 오버로딩 없음</p></li></ul><ul id="66d7d629-f2c2-4d0f-967c-12513f97be00" class="bulleted-list"><li style="list-style-type:disc"><strong>따라서 </strong><strong><code>printf()</code></strong><strong>는 무조건 첫 번째 인자로 문자열을 받아야함</strong></li></ul><h2 id="a4669dca-a5eb-49ab-b9ab-a2dbb06377bb" class="">서식 문자열(format string)</h2><pre id="546614d9-2734-4fff-b0ac-57ae1ef19409" class="code"><code>printf(&quot;Hello POCU&quot;);                                /* 일반 문자열 */
    printf(&quot;%d&quot;, score);                                 /* 서식 문자열: 정수 출력 */
    printf(&quot;%c&quot;, ch);                                    /* 서식 문자열: 문자 출력 */
    printf(&quot;%f&quot;, pi);                                    /* 서식 문자열: 부동소수점 출력 */  
    printf(&quot;%s&quot;, name);                                  /* 서식 문자열: 문자열 출력 */
    printf(&quot;Hi, %s\nYour score is %d\n&quot;, name, score);   /* 서식 문자열: 혼합 출력 */</code></pre><ul id="8639ad71-4f81-46b7-9390-45a4ededc6a0" class="bulleted-list"><li style="list-style-type:disc"><strong><code>printf()</code></strong><strong>는 일반 문자열 혹은 서식 문자열을 매개변수로 받음</strong></li></ul><ul id="2b287c0b-9e66-4324-83b5-1777422adf07" class="bulleted-list"><li style="list-style-type:disc">서식 문자열<ul id="1a0ab41d-0bd2-46cd-8543-f724b2760f8a" class="bulleted-list"><li style="list-style-type:circle"><code>%</code>로 시작하는 문자열</li></ul><ul id="7fd50bc7-7400-473a-ac6e-58205db2567a" class="bulleted-list"><li style="list-style-type:circle">소수점 이하 자리수, 자릿수 정렬, 어떤 데이터(숫자, 문자)를 출력할지 등을 알려주는 문자열</li></ul><ul id="f058c4f6-68ee-40b9-a111-3848adf5061d" class="bulleted-list"><li style="list-style-type:circle">하나 이상의 데이터가 들어갈 수 있음</li></ul><ul id="2858cfd4-d3fd-4d8f-a1d6-8a3f94efd9d0" class="bulleted-list"><li style="list-style-type:circle">이 때, 서식 지정자의 순서와 동일한 순서로 데이터들을 <code>printf()</code>의 추가 매개변수로 전달</li></ul></li></ul><h3 id="5d0e0a1c-f18c-4146-97ea-87cf5bd56f4c" class="">일반적인 서식 문자열 형식</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3a7de339-cb42-4376-9e77-3ef5bfc681ec"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>% [ 플래그 ] [ 너비 ] [ .숫자 정밀도 | .문자열 최소/최대 출력 개수 ] [ 길이 ] 서식 지정자</strong></div></figure><ul id="d05986f2-cbd0-43b7-b55b-358de67ea199" class="bulleted-list"><li style="list-style-type:disc">일반적으로 &#x27;<code>%</code>&#x27; 뒤에 최대 4개의 지정자를 가질 수 있음<p id="79b718e0-3824-41f7-a3eb-9082ec607d5e" class="">1) 플래그 (선택)</p><p id="e4b78644-d612-4ae4-b331-45efe3340a82" class="">2) 너비 (선택)</p><p id="dd9e3234-df1b-4fbb-bdb6-c15d22a83ce2" class="">3) 정밀도 (선택)</p><ul id="670d0739-2e41-4bb0-92f2-d45a34da2e6d" class="bulleted-list"><li style="list-style-type:circle">숫자 정밀도</li></ul><ul id="9e1ba638-2843-4776-9efd-12a3ecfeb0e2" class="bulleted-list"><li style="list-style-type:circle">문자열 최소/최대 출력 개수</li></ul><p id="935e5c95-efb1-4403-9c1f-beb20abfa0b3" class="">4) 길이 (선택)</p><p id="113b79b6-3d52-4212-a49a-044e04faf1c4" class="">5) 서식 지정자 <strong>(필수)</strong><div class="indented"><p id="8d0ba6de-4365-4410-b47b-b4de29f11097" class="">⇒ 반드시 순서를 지켜 작성해야 함</p></div></p></li></ul><h3 id="ebb8402e-ddd7-4ed5-9852-d6ee123d3511" class="">서식 지정자</h3><div id="6531c591-21e7-48dc-8ea9-31b67461c649" class="collection-content"><h4 class="collection-title"></h4><table class="collection-content"><thead><tr><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesTitle"><path d="M7.73943662,8.6971831 C7.77640845,8.7834507 7.81338028,8.8943662 7.81338028,9.00528169 C7.81338028,9.49823944 7.40669014,9.89260563 6.91373239,9.89260563 C6.53169014,9.89260563 6.19894366,9.64612676 6.08802817,9.30105634 L5.75528169,8.33978873 L2.05809859,8.33978873 L1.72535211,9.30105634 C1.61443662,9.64612676 1.2693662,9.89260563 0.887323944,9.89260563 C0.394366197,9.89260563 0,9.49823944 0,9.00528169 C0,8.8943662 0.0246478873,8.7834507 0.0616197183,8.6971831 L2.46478873,2.48591549 C2.68661972,1.90669014 3.24119718,1.5 3.90669014,1.5 C4.55985915,1.5 5.12676056,1.90669014 5.34859155,2.48591549 L7.73943662,8.6971831 Z M2.60035211,6.82394366 L5.21302817,6.82394366 L3.90669014,3.10211268 L2.60035211,6.82394366 Z M11.3996479,3.70598592 C12.7552817,3.70598592 14,4.24823944 14,5.96126761 L14,9.07922535 C14,9.52288732 13.6549296,9.89260563 13.2112676,9.89260563 C12.8169014,9.89260563 12.471831,9.59683099 12.4225352,9.19014085 C12.028169,9.6584507 11.3257042,9.95422535 10.5492958,9.95422535 C9.60035211,9.95422535 8.47887324,9.31338028 8.47887324,7.98239437 C8.47887324,6.58978873 9.60035211,6.08450704 10.5492958,6.08450704 C11.3380282,6.08450704 12.040493,6.33098592 12.4348592,6.81161972 L12.4348592,5.98591549 C12.4348592,5.38204225 11.9172535,4.98767606 11.1285211,4.98767606 C10.6602113,4.98767606 10.2411972,5.11091549 9.80985915,5.38204225 C9.72359155,5.43133803 9.61267606,5.46830986 9.50176056,5.46830986 C9.18133803,5.46830986 8.91021127,5.1971831 8.91021127,4.86443662 C8.91021127,4.64260563 9.0334507,4.44542254 9.19366197,4.34683099 C9.87147887,3.90316901 10.6232394,3.70598592 11.3996479,3.70598592 Z M11.1778169,8.8943662 C11.6830986,8.8943662 12.1760563,8.72183099 12.4348592,8.37676056 L12.4348592,7.63732394 C12.1760563,7.29225352 11.6830986,7.11971831 11.1778169,7.11971831 C10.5616197,7.11971831 10.056338,7.45246479 10.056338,8.0193662 C10.056338,8.57394366 10.5616197,8.8943662 11.1778169,8.8943662 Z M0.65625,11.125 L13.34375,11.125 C13.7061869,11.125 14,11.4188131 14,11.78125 C14,12.1436869 13.7061869,12.4375 13.34375,12.4375 L0.65625,12.4375 C0.293813133,12.4375 4.43857149e-17,12.1436869 0,11.78125 C-4.43857149e-17,11.4188131 0.293813133,11.125 0.65625,11.125 Z"></path></svg></span>서식 지정자</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesMultipleSelect"><path d="M4,3 C4,2.447715 4.447715,2 5,2 L12,2 C12.5523,2 13,2.447716 13,3 C13,3.55228 12.5523,4 12,4 L5,4 C4.447715,4 4,3.55228 4,3 Z M4,7 C4,6.447715 4.447715,6 5,6 L12,6 C12.5523,6 13,6.447716 13,7 C13,7.55228 12.5523,8 12,8 L5,8 C4.447715,8 4,7.55228 4,7 Z M4,11 C4,10.447715 4.447715,10 5,10 L12,10 C12.5523,10 13,10.447716 13,11 C13,11.55228 12.5523,12 12,12 L5,12 C4.447715,12 4,11.55228 4,11 Z M2,4 C1.44771525,4 1,3.55228475 1,3 C1,2.44771525 1.44771525,2 2,2 C2.55228475,2 3,2.44771525 3,3 C3,3.55228475 2.55228475,4 2,4 Z M2,8 C1.44771525,8 1,7.55228475 1,7 C1,6.44771525 1.44771525,6 2,6 C2.55228475,6 3,6.44771525 3,7 C3,7.55228475 2.55228475,8 2,8 Z M2,12 C1.44771525,12 1,11.5522847 1,11 C1,10.4477153 1.44771525,10 2,10 C2.55228475,10 3,10.4477153 3,11 C3,11.5522847 2.55228475,12 2,12 Z"></path></svg></span>태그</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>설명</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>코드</th></tr></thead><tbody><tr id="d89c9452-5d06-434d-b17a-e0f1ac74005e"><td class="cell-title"><a href="https://www.notion.so/d89c94525d06434db17ae0f1ac74005e">%</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">&#x27;%&#x27;를 출력</td><td class="cell-`A:|">printf(&quot;%%/n&quot;);</td></tr><tr id="9b52c19b-91e1-4f05-a53b-28f73f36daa6"><td class="cell-title"><a href="https://www.notion.so/c-9b52c19b91e14f05a53b28f73f36daa6">c</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">문자(char)를 출력</td><td class="cell-`A:|">printf(&quot;%c\n&quot;, &#x27;D&#x27;);</td></tr><tr id="7a338543-46a8-480a-8bd9-39f9ad630992"><td class="cell-title"><a href="https://www.notion.so/s-7a33854346a8480a8bd939f9ad630992">s</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">문자열(char[])를 출력</td><td class="cell-`A:|">printf(&quot;%s/n&quot;, &quot;Hong&quot;);</td></tr><tr id="b0b38b32-600f-48fb-a898-1da7a169cf50"><td class="cell-title"><a href="https://www.notion.so/d-b0b38b32600f48fba8981da7a169cf50">d</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부호있는 정수 출력</td><td class="cell-`A:|">printf(&quot;%d/n&quot;, -10);</td></tr><tr id="0517eb2a-666e-4299-8ffa-b066e4d84aaf"><td class="cell-title"><a href="https://www.notion.so/u-0517eb2a666e42998ffab066e4d84aaf">u</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부호없는 정수 출력</td><td class="cell-`A:|">printf(&quot;%u/n&quot;, 10);</td></tr><tr id="46022ee6-b96f-480f-b76f-626dca5313e3"><td class="cell-title"><a href="https://www.notion.so/o-46022ee6b96f480fb76f626dca5313e3">o</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부호없는 정수를 8진수로 출력, 숫자 앞에 0을 <strong>안 붙여줌</strong></td><td class="cell-`A:|">printf(&quot;%o/n&quot;, 10);</td></tr><tr id="a3bf0516-91f3-4248-9852-fef5d17db535"><td class="cell-title"><a href="https://www.notion.so/x-a3bf051691f342489852fef5d17db535">x</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부호없는 정수를 16진수(소문자)로 출력, 숫자 앞에 0x을 <strong>안 붙여줌</strong></td><td class="cell-`A:|">printf(&quot;%x/n&quot;, 10);</td></tr><tr id="55bc50fa-a95f-4af7-98b4-29b17054d907"><td class="cell-title"><a href="https://www.notion.so/X-55bc50faa95f4af798b429b17054d907">X</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부호없는 정수를 16진수(대문자)로 출력, 숫자 앞에 0X을 <strong>안 붙여줌</strong></td><td class="cell-`A:|">printf(&quot;%X/n&quot;, 10);</td></tr><tr id="c0abb5a2-f46d-4b2e-8968-e14abb20d5bf"><td class="cell-title"><a href="https://www.notion.so/f-c0abb5a2f46d4b2e8968e14abb20d5bf">f</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부동소수점 출력</td><td class="cell-`A:|">printf(&quot;%f/n&quot;, 3.14);</td></tr><tr id="785c7094-48f4-450d-9411-6f120f9123dd"><td class="cell-title"><a href="https://www.notion.so/e-E-785c709448f4450d94116f120f9123dd">e/E</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">부동소수점을 지수표기법으로 출력</td><td class="cell-`A:|">printf(&quot;%e/n&quot;, 10); / printf(&quot;%E/n&quot;, 10);</td></tr><tr id="6f76cde7-2cae-43f4-85b5-8b36fa86ec79"><td class="cell-title"><a href="https://www.notion.so/p-6f76cde72cae43f485b58b36fa86ec79">p</a></td><td class="cell-g~LV"></td><td class="cell-{E`M">포인터값을 출력</td><td class="cell-`A:|">printf(&quot;%p/n&quot;, (void*)name);</td></tr></tbody></table></div><ul id="15fc3272-264f-40e9-888d-47fddee235a5" class="bulleted-list"><li style="list-style-type:disc">서식 문자라고도 함</li></ul><ul id="c6f2aa66-a8e0-4126-b714-e681770ecd55" class="bulleted-list"><li style="list-style-type:disc">&#x27;<code>%</code>&#x27;가 서식 문자열에서 사용 중이므로 출력하려면 어쩔 수 없이 반복</li></ul><ul id="6de244ac-37aa-4976-8e84-84561b60ecfe" class="bulleted-list"><li style="list-style-type:disc">&quot;<code>%s</code>&quot; 쓸바엔 그냥 문자열로 곧바로 <code>printf()</code>해도 됨<p id="b137242a-acaf-4486-81bc-bee5415a5c96" class="">⇒ 단 문자열 두 개 합치거나 문자열 + 숫자 합쳐서 출력할 땐 유용함</p><pre id="1d26abe0-862a-4ea6-9fb4-f90afe9e010c" class="code"><code>printf(name); /* const char* name = &quot;HONG&quot;; */
    printf(&quot;%s&quot;, name);
    printf(&quot;Hello, %s\nYour score is %d\n&quot;, name, score);</code></pre></li></ul><ul id="66c85626-7e3e-4f3b-a367-310185ab352f" class="bulleted-list"><li style="list-style-type:disc">&quot;<code>%u</code>&quot;에 부호있는 수를 넣을 경우, 해당 수의 비트패턴에 해당하는 부호없는 수가 출력</li></ul><ul id="aeabc725-879c-446a-be72-48f6552259d9" class="bulleted-list"><li style="list-style-type:disc">&quot;<code>%X</code>&quot;는 있는데 &quot;<code>%O</code>&quot;가 없는 이유<p id="81cb77fd-4cae-4342-9cd9-f6ea70cf934e" class="">⇒ 8진수는 숫자로만 이루어져 있기 때문</p></li></ul><ul id="52d30fcf-03e8-4f4c-99c1-abffd7b35bef" class="bulleted-list"><li style="list-style-type:disc">&quot;<code>%p</code>&quot;는 주소를 출력하는데 <code>void*</code>만 받음<p id="a24ddf37-c641-455e-8e79-f3894787e615" class="">⇒ 모든 주소는 어차피 길이가 같다고 했으니 어떤 포인터를 <code>void*</code>로 캐스팅해도 안전</p></li></ul><h3 id="10bbaa0e-f7bb-4fed-8c4c-49bbab34797f" class="">플래그</h3><div id="d7e81e20-9b3e-4f8c-aaa4-ab6cd85a0101" class="collection-content"><h4 class="collection-title"></h4><table class="collection-content"><thead><tr><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesTitle"><path d="M7.73943662,8.6971831 C7.77640845,8.7834507 7.81338028,8.8943662 7.81338028,9.00528169 C7.81338028,9.49823944 7.40669014,9.89260563 6.91373239,9.89260563 C6.53169014,9.89260563 6.19894366,9.64612676 6.08802817,9.30105634 L5.75528169,8.33978873 L2.05809859,8.33978873 L1.72535211,9.30105634 C1.61443662,9.64612676 1.2693662,9.89260563 0.887323944,9.89260563 C0.394366197,9.89260563 0,9.49823944 0,9.00528169 C0,8.8943662 0.0246478873,8.7834507 0.0616197183,8.6971831 L2.46478873,2.48591549 C2.68661972,1.90669014 3.24119718,1.5 3.90669014,1.5 C4.55985915,1.5 5.12676056,1.90669014 5.34859155,2.48591549 L7.73943662,8.6971831 Z M2.60035211,6.82394366 L5.21302817,6.82394366 L3.90669014,3.10211268 L2.60035211,6.82394366 Z M11.3996479,3.70598592 C12.7552817,3.70598592 14,4.24823944 14,5.96126761 L14,9.07922535 C14,9.52288732 13.6549296,9.89260563 13.2112676,9.89260563 C12.8169014,9.89260563 12.471831,9.59683099 12.4225352,9.19014085 C12.028169,9.6584507 11.3257042,9.95422535 10.5492958,9.95422535 C9.60035211,9.95422535 8.47887324,9.31338028 8.47887324,7.98239437 C8.47887324,6.58978873 9.60035211,6.08450704 10.5492958,6.08450704 C11.3380282,6.08450704 12.040493,6.33098592 12.4348592,6.81161972 L12.4348592,5.98591549 C12.4348592,5.38204225 11.9172535,4.98767606 11.1285211,4.98767606 C10.6602113,4.98767606 10.2411972,5.11091549 9.80985915,5.38204225 C9.72359155,5.43133803 9.61267606,5.46830986 9.50176056,5.46830986 C9.18133803,5.46830986 8.91021127,5.1971831 8.91021127,4.86443662 C8.91021127,4.64260563 9.0334507,4.44542254 9.19366197,4.34683099 C9.87147887,3.90316901 10.6232394,3.70598592 11.3996479,3.70598592 Z M11.1778169,8.8943662 C11.6830986,8.8943662 12.1760563,8.72183099 12.4348592,8.37676056 L12.4348592,7.63732394 C12.1760563,7.29225352 11.6830986,7.11971831 11.1778169,7.11971831 C10.5616197,7.11971831 10.056338,7.45246479 10.056338,8.0193662 C10.056338,8.57394366 10.5616197,8.8943662 11.1778169,8.8943662 Z M0.65625,11.125 L13.34375,11.125 C13.7061869,11.125 14,11.4188131 14,11.78125 C14,12.1436869 13.7061869,12.4375 13.34375,12.4375 L0.65625,12.4375 C0.293813133,12.4375 4.43857149e-17,12.1436869 0,11.78125 C-4.43857149e-17,11.4188131 0.293813133,11.125 0.65625,11.125 Z"></path></svg></span>플래그</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>설명</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>코드</th></tr></thead><tbody><tr id="64f64a09-c35e-487f-964d-305005eee0c3"><td class="cell-title"><a href="https://www.notion.so/64f64a09c35e487f964d305005eee0c3">-</a></td><td class="cell-r[|C">왼쪽 정렬</td><td class="cell-aWM@">printf(&quot;%-5d/n&quot;, number);</td></tr><tr id="68217d0c-df81-49eb-a64f-82c521d55ef2"><td class="cell-title"><a href="https://www.notion.so/0-68217d0cdf8149eba64f82c521d55ef2">0</a></td><td class="cell-r[|C">빈 공백을 0으로 채워줌</td><td class="cell-aWM@">printf(&quot;%05d/n&quot;, number);</td></tr><tr id="93f8580f-afc7-453c-bf11-86d3c850541f"><td class="cell-title"><a href="https://www.notion.so/93f8580fafc7453cbf1186d3c850541f">+</a></td><td class="cell-r[|C">항상 부호(+/-)를 표시</td><td class="cell-aWM@">printf(&quot;%+5d/n&quot;, number);</td></tr><tr id="72af49de-4fec-4b9f-8ee6-e30099c0e652"><td class="cell-title"><a href="https://www.notion.so/72af49de4fec4b9f8ee6e30099c0e652">공백</a></td><td class="cell-r[|C">양수인 경우에도 부호칸을 비워둠</td><td class="cell-aWM@">printf(&quot;% d/n&quot;, number);</td></tr><tr id="e5d95705-8737-4c56-80f9-66a7f7c863e5"><td class="cell-title"><a href="https://www.notion.so/o-e5d9570587374c5680f966a7f7c863e5">#o</a></td><td class="cell-r[|C">부호없는 정수를 8진수로 출력, 숫자 앞에 항상 &#x27;0&#x27;이 붙음</td><td class="cell-aWM@">printf(&quot;%#o/n&quot;, number);</td></tr><tr id="95f9650c-be4f-4d64-ac4a-653d1efd3bc1"><td class="cell-title"><a href="https://www.notion.so/x-95f9650cbe4f4d64ac4a653d1efd3bc1">#x</a></td><td class="cell-r[|C">부호없는 정수를 16진수(소문자)로 출력, 숫자 앞에 항상 &#x27;0x&#x27;이 붙음</td><td class="cell-aWM@">printf(&quot;%#x/n&quot;, number);</td></tr><tr id="c65f14a5-27b8-47c2-9367-81f8ee8975ae"><td class="cell-title"><a href="https://www.notion.so/X-c65f14a527b847c2936781f8ee8975ae">#X</a></td><td class="cell-r[|C">부호없는 정수를 16진수(대문자)로 출력, 숫자 앞에 항상 &#x27;0x&#x27;이 붙음</td><td class="cell-aWM@">printf(&quot;%#X/n&quot;, number);</td></tr></tbody></table></div><ul id="cc30ccd4-5ac8-4956-92eb-19e40af67d0a" class="bulleted-list"><li style="list-style-type:disc">&#x27;<code>-</code>&#x27; : 왼쪽 정렬 (기본은 오른쪽 정렬)</li></ul><ul id="8551d63f-650f-4711-ab6f-10f1f1a570ce" class="bulleted-list"><li style="list-style-type:disc">&#x27;<code> </code>&#x27; : &#x27;<code>+</code>&#x27;가 있을 경우 무시됨</li></ul><ul id="bfdd41a7-927a-48a3-aba4-ab5fcd844530" class="bulleted-list"><li style="list-style-type:disc">&#x27;<code>+</code>&#x27; : 기본은 음수 기호만 출력</li></ul><ul id="b6b17c30-8a57-4c79-8f47-640e7a035223" class="bulleted-list"><li style="list-style-type:disc">&#x27;<code>0</code>&#x27; : &#x27;-&#x27;가 있을 경우 무시됨</li></ul><ul id="579a3ab7-82ca-453c-93bd-b29b53923ce2" class="bulleted-list"><li style="list-style-type:disc">&#x27;<code>#</code>&#x27;<ul id="91cbac6b-44e3-45b6-a065-69a3a36cbb59" class="bulleted-list"><li style="list-style-type:circle">어디에 붙이냐에 따라 의미가 달라지며, 그나마 유용한 곳은 <code>x</code>나 <code>X</code>에 붙일 때</li></ul><ul id="22c161f5-2dca-4be3-81a4-2ef9f673b7e2" class="bulleted-list"><li style="list-style-type:circle">&quot;<code>#x/X/o</code>&quot;를 쓸때는 다른 플래그나 서식 지정자 &#x27;d&#x27;를 붙이지 않음<p id="d175d053-b132-462d-be6b-a7333c5a6479" class="">⇒ &#x27;<code>-</code>&#x27;는 붙일 수 있으나 의미 없음</p></li></ul></li></ul><h3 id="d6b4ea34-2b20-4694-8063-06d254ff83ff" class="">정밀도</h3><ul id="6d9f935d-c6ac-4035-83e0-6c0b1155d3d5" class="bulleted-list"><li style="list-style-type:disc">서식 지정자 &#x27;<code>f</code>&#x27;와 함께 사용<ul id="b91a44ed-1dca-4c5b-9aca-14cc4bb22f85" class="bulleted-list"><li style="list-style-type:circle">최소 너비. 소수점 아랫자리 수</li></ul><ul id="0f1b0260-a26b-4caf-a86b-dc1e0c29111f" class="bulleted-list"><li style="list-style-type:circle">(소수점 포함) 원래 숫자의 너비보다 최소 너비가 크면 공백으로 채움</li></ul><ul id="e847c76b-bc35-4434-af66-5c0ddf722321" class="bulleted-list"><li style="list-style-type:circle">(소수점 포함하지 않음) 원래 숫자의 소수점 아랫자리 수보다 소수점 아랫자리수가 크면 0으로 채움</li></ul><ul id="a8c0a001-c090-4292-b89c-5afa2f864c28" class="bulleted-list"><li style="list-style-type:circle">기본 수수점 아랫자리 수 : 6</li></ul></li></ul><ul id="94ee5ea8-b8a3-4b6e-89c1-366fc469ebfb" class="bulleted-list"><li style="list-style-type:disc">서식 지정자 &#x27;<code>s</code>&#x27;도 함께 사용<ul id="59a093c7-0e48-4483-9e9a-4baccbfd0f0d" class="bulleted-list"><li style="list-style-type:circle">최소너비.최대너비</li></ul><ul id="e4f52334-707e-4119-b467-483679b0925d" class="bulleted-list"><li style="list-style-type:circle">출력할 문자열의 길이가 최소 너비보다 작으면 왼쪽을 공백으로 채움</li></ul><ul id="3558b9c5-4fe8-4419-9aaa-fc230f125159" class="bulleted-list"><li style="list-style-type:circle">출력할 문자열의 길이가 최대 너비보다 크면 자름</li></ul></li></ul><h3 id="1465a748-acdd-416d-80b5-fa292108e6d2" class="">길이 수정자(length modifier)</h3><div id="65b286a7-06fd-410e-832b-5c55aaa5d162" class="collection-content"><h4 class="collection-title"></h4><table class="collection-content"><thead><tr><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesTitle"><path d="M7.73943662,8.6971831 C7.77640845,8.7834507 7.81338028,8.8943662 7.81338028,9.00528169 C7.81338028,9.49823944 7.40669014,9.89260563 6.91373239,9.89260563 C6.53169014,9.89260563 6.19894366,9.64612676 6.08802817,9.30105634 L5.75528169,8.33978873 L2.05809859,8.33978873 L1.72535211,9.30105634 C1.61443662,9.64612676 1.2693662,9.89260563 0.887323944,9.89260563 C0.394366197,9.89260563 0,9.49823944 0,9.00528169 C0,8.8943662 0.0246478873,8.7834507 0.0616197183,8.6971831 L2.46478873,2.48591549 C2.68661972,1.90669014 3.24119718,1.5 3.90669014,1.5 C4.55985915,1.5 5.12676056,1.90669014 5.34859155,2.48591549 L7.73943662,8.6971831 Z M2.60035211,6.82394366 L5.21302817,6.82394366 L3.90669014,3.10211268 L2.60035211,6.82394366 Z M11.3996479,3.70598592 C12.7552817,3.70598592 14,4.24823944 14,5.96126761 L14,9.07922535 C14,9.52288732 13.6549296,9.89260563 13.2112676,9.89260563 C12.8169014,9.89260563 12.471831,9.59683099 12.4225352,9.19014085 C12.028169,9.6584507 11.3257042,9.95422535 10.5492958,9.95422535 C9.60035211,9.95422535 8.47887324,9.31338028 8.47887324,7.98239437 C8.47887324,6.58978873 9.60035211,6.08450704 10.5492958,6.08450704 C11.3380282,6.08450704 12.040493,6.33098592 12.4348592,6.81161972 L12.4348592,5.98591549 C12.4348592,5.38204225 11.9172535,4.98767606 11.1285211,4.98767606 C10.6602113,4.98767606 10.2411972,5.11091549 9.80985915,5.38204225 C9.72359155,5.43133803 9.61267606,5.46830986 9.50176056,5.46830986 C9.18133803,5.46830986 8.91021127,5.1971831 8.91021127,4.86443662 C8.91021127,4.64260563 9.0334507,4.44542254 9.19366197,4.34683099 C9.87147887,3.90316901 10.6232394,3.70598592 11.3996479,3.70598592 Z M11.1778169,8.8943662 C11.6830986,8.8943662 12.1760563,8.72183099 12.4348592,8.37676056 L12.4348592,7.63732394 C12.1760563,7.29225352 11.6830986,7.11971831 11.1778169,7.11971831 C10.5616197,7.11971831 10.056338,7.45246479 10.056338,8.0193662 C10.056338,8.57394366 10.5616197,8.8943662 11.1778169,8.8943662 Z M0.65625,11.125 L13.34375,11.125 C13.7061869,11.125 14,11.4188131 14,11.78125 C14,12.1436869 13.7061869,12.4375 13.34375,12.4375 L0.65625,12.4375 C0.293813133,12.4375 4.43857149e-17,12.1436869 0,11.78125 C-4.43857149e-17,11.4188131 0.293813133,11.125 0.65625,11.125 Z"></path></svg></span>길이 수정자</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>서식 지정자</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>자료형</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>코드</th></tr></thead><tbody><tr id="488f0876-acd8-40f0-82f1-1ba3f1df5678"><td class="cell-title"><a href="https://www.notion.so/488f0876acd840f082f11ba3f1df5678">제목 없음</a></td><td class="cell-TrS@">d</td><td class="cell-bMI&gt;">int</td><td class="cell-Xcx&gt;">printf(&quot;%d/n&quot;, number);</td></tr><tr id="b2e1cd01-9b26-4762-9f0a-3b07fa84562c"><td class="cell-title"><a href="https://www.notion.so/l-b2e1cd019b2647629f0a3b07fa84562c">l</a></td><td class="cell-TrS@">d</td><td class="cell-bMI&gt;">long int</td><td class="cell-Xcx&gt;">printf(&quot;%ld/n&quot;, number);</td></tr><tr id="a32a2919-8d1d-4d2d-b379-d67581c32992"><td class="cell-title"><a href="https://www.notion.so/a32a29198d1d4d2db379d67581c32992">제목 없음</a></td><td class="cell-TrS@">f</td><td class="cell-bMI&gt;">double</td><td class="cell-Xcx&gt;">printf(&quot;%f/n&quot;, number);</td></tr><tr id="e56a0d43-1a0b-4360-845f-f3ee9c095d33"><td class="cell-title"><a href="https://www.notion.so/L-e56a0d431a0b4360845ff3ee9c095d33">L</a></td><td class="cell-TrS@">f</td><td class="cell-bMI&gt;">long double</td><td class="cell-Xcx&gt;">printf(&quot;%lf/n&quot;, number);</td></tr></tbody></table></div><ul id="0402eb22-5c57-4286-a349-b8b8a8337d3b" class="bulleted-list"><li style="list-style-type:disc">인자의 바이트 크기를 지정해줌</li></ul><ul id="8f9ef5ad-ef7b-49cc-8a19-5114bfd083e7" class="bulleted-list"><li style="list-style-type:disc">몇 가지가 있지만 &#x27;<code>l</code>&#x27;(소문자 L)과 &#x27;<code>L</code>&#x27;이 그나마 유용함<ul id="1367dd02-f1c9-4e5e-9208-febd665b8a57" class="bulleted-list"><li style="list-style-type:circle">하지만 최근 플랫폼에선 별 의미가 없음</li></ul><ul id="16487cbb-f725-406c-aafb-e939513d5d79" class="bulleted-list"><li style="list-style-type:circle"><code>int</code> == <code>long int</code>, <code>double</code> == <code>long double</code>인 경우가 보통</li></ul><ul id="c70a476e-57f8-48ed-977e-4eb66e404e02" class="bulleted-list"><li style="list-style-type:circle">설사 위의 경우가 아니더라도 <code>long doubl</code>e은 잘 사용하지 않음</li></ul><pre id="c38f161c-bad8-4455-a7fb-183cc86b5a91" class="code"><code>int num1 = 100;
    long int num2 = 100;
    double num3 = 10.12345678;
    long double num4 = 10.12345678;
    
    printf(&quot;int: %d, size: %d\n, num1, sizeof(num1));
    printf(&quot;long int: %ld, size: %d\n, num2, sizeof(num2));
    printf(&quot;double: %f, size: %d\n, num3, sizeof(num3));
    printf(&quot;long double: %Lf, size: %d\n, num4, sizeof(num4));
    
    /* int : 100, size : 4 */
    /* long int : 100, size : 4 */
    /* double : 10.12345678, size : 8 */
    /* long double : 10.12345678, size : 8 */</code></pre></li></ul><h3 id="a406660b-c724-4584-8efb-735524ce8780" class="">퀴즈</h3><pre id="09e877fb-d872-4ebd-9054-4b56dfb33694" class="code"><code>int num1 = 250;
    float num2 = 250.123456f;
    
    printf(&quot;%8X\n&quot;, num1);
    printf(&quot;%8o\n&quot;, num1);
    printf(&quot;%+8.2f\n&quot;, num2);
    
    /*
    - : 공백
    ------FA
    -----372
    -+250.12
    */</code></pre><h3 id="fb7dbd40-6713-47f8-8c0e-77bcbd0b994a" class="">ASCII 표 그리기</h3><pre id="d8d51483-f43f-405e-87ed-fbeb24bb1e2e" class="code"><code>#include &lt;stdio.h&gt;
    
    #include &quot;print_ascii_table.h&quot;
    
    void print_ascii_table(void)
    {
        const int MIN_ASCII = 32&#x27;
        const int MAX_ASCII = 126;
        const int NUM_CHARS = MAS_ASCII - MIN_ASCII + 1;
        const int NUM_COLS = 3;
        const int NUM_ROWS = (NUM_CHARS + NUM_COLS - 1) / NUM_COLS;
        
        int r;
        int ch;
    
        printf(&quot;Dec Hex Char\tDec Hex Char\tDec Hex Char\n);
    
        for (r = 0; r &lt; NUM_ROWS - 1; ++r) {
            ch = MIN_ASCII + r;
            printf(&quot;03d %#X %c\t&quot;, ch, ch, ch);
    
            ch += NUM_ROWS;
            printf(&quot;03d %#X %c\t&quot;, ch, ch, ch);
    
            ch += NUM_ROWS;
            printf(&quot;03d %#X %c\t&quot;, ch, ch, ch);
        }
    
        /* last row doesn&#x27;t have all columns */
        for (ch = MIN_ASCII + r; ch &lt;= MAX_ASCII; ch += NUM_ROWS) {
            printf(&quot;03d %#X %c\t&quot;, ch, ch, ch);
        }
    }</code></pre><h3 id="b3a40dc3-90eb-4838-b8ce-b62f79567538" class="">바이트 단위 변환 표</h3><pre id="753eae47-d4c0-424c-b0bc-a9ff917da3c1" class="code"><code>#include &lt;stdio.h&gt;
    
    #include &quot;byte_conversion_chart.h&quot;
    
    #define SCALE (1024.0f)
    
    #define BYTE (1.0f)
    #define KB (SCALE = BYTE)
    #define MB (SCALE = KB)
    #define GB (SCALE = MB)
    #define TB (SCALE = GB)
    #define PB (SCALE = TB)
    
    #define LENGTH (6)
    
    static const char* const DATA_STORAGE_NAMES[LENGTH] = 
        (&quot;Byte&quot;, &quot;Kilobytle&quot;, &quot;Megabyte&quot;, &quot;Gigabyte&quot;, &quot;Terabyte&quot;, &quot;Petabyte&quot;);
    
    void print_byte_conversion_chart(void)
    {
        double divisor = 1.0;
        size_t i;
    
        printf(&quot;%9s&quot;, &quot;&quot;);
    
        for (i = 0; i &lt; LENGTH; ++i) {
            printf(&quot;%17s &quot;, DATA_STORAGE_NAMES[i]);
        }
    
        printf(&quot;\n%4s&quot;, &quot;&quot;);
    
        for (i = 0; i &lt; LENGTH; ++i) {
            printf(&quot;%s %17.15f %17.12f %17.9f %17.6f %17.3f %17.0f\n&quot;,
                DATA_STORAGE_NAMES[i], BYTE / divisor, KB / divisor, 
                MB / divisor, , GB / divisor, TB / divisor, PB / divisor);
            
            divisor *= SCALE;
        }
    }
    
    void print_byte_conversion_chart_scientific(void)   /* 지수표기법 */
    {
        double divisor = 1.0;
        size_t i;
    
        printf(&quot;%9s&quot;, &quot;&quot;);
    
        for (i = 0; i &lt; LENGTH; ++i) {
            printf(&quot;%17s &quot;, DATA_STORAGE_NAMES[i]);
        }
    
        printf(&quot;\n%4s&quot;, &quot;&quot;);
    
        for (i = 0; i &lt; LENGTH; ++i) {
            printf(&quot;%s %17.2e %17.2e %17.2e %17.2e %17.2e %17.2e\n&quot;,
                DATA_STORAGE_NAMES[i], BYTE / divisor, KB / divisor, 
                MB / divisor, , GB / divisor, TB / divisor, PB / divisor);
            
            divisor *= SCALE;
        }
    }</code></pre><h3 id="7f259754-a03d-4340-b060-69be0192de20" class="">서식 문자열이 필요한 이유</h3><ul id="e338a679-0ff0-4fe7-933b-cad65531600f" class="bulleted-list"><li style="list-style-type:disc"><strong>일단 오버로딩 없음 ⇒ </strong><strong><code>printf(int)</code></strong><strong>, </strong><strong><code>printf(char)</code></strong><strong> 불가능</strong></li></ul><ul id="40cded19-2945-423f-9108-e0f56a2290aa" class="bulleted-list"><li style="list-style-type:disc">임시 문자열 등을 자동으로 생성 안 해줌<pre id="6d3f8ffc-fd4e-4d9a-bddf-1b713f54e0b4" class="code"><code>printf(&quot;Hello, &quot; + name + &quot;\nYour score is &quot; + score); /* 컴파일 오류 */</code></pre></li></ul><ul id="f9daf29a-9f38-4b51-a481-98aa04fb3598" class="bulleted-list"><li style="list-style-type:disc">물론 <code>strcat()</code>을 이용해서 프로그래머가 직접 임시 문자열을 관리할 수 있음</li></ul><ul id="e30873cf-5014-4110-8360-bae625235c17" class="bulleted-list"><li style="list-style-type:disc">서식 문자열은 추가 메모리 할당 없이 있는 자료형을 출력스트림에 문자들로 출력해줌</li></ul><h2 id="06f5a2fb-38ca-4f15-8ac8-46617bc0b17f" class="">fprintf()</h2><pre id="bc403fae-8d31-48b6-9bb8-b3d50e3a9097" class="code"><code>const char* name = &quot;HONG&quot;;
    fprintf(stdout, &quot;Hello, %s\n&quot;, name);</code></pre><ul id="b1bd0590-052b-4925-b871-5269aa94a06d" class="bulleted-list"><li style="list-style-type:disc">스트림을 사용</li></ul><ul id="593f419b-ead3-429e-a126-be2baf7d9689" class="bulleted-list"><li style="list-style-type:disc">보통 프로그램이 실행할 때 기본적으로 3개의 스트림을 줌<p id="673b5abd-891e-43b0-bc33-c4501b85ac91" class=""><strong>1) stdout (콘솔 출력)</strong></p><ul id="3cb12d33-cf89-4531-9c0d-468072d42605" class="bulleted-list"><li style="list-style-type:circle">이제까지 계속 봐왔던 콘솔 스트림</li></ul><ul id="1bb88a0a-4c84-4b99-80a4-691bf11d1dfb" class="bulleted-list"><li style="list-style-type:circle">라인 버퍼링(line buffering) 사용</li></ul><p id="969e2b67-de02-4e30-ac84-dd9b3a1e2b70" class=""><strong>2) stdin (콘솔 입력)</strong></p><p id="543be19f-b0ac-4ed3-a8a8-d953f5a893e9" class=""><strong>3) stderr (콘솔 출력; 오류 메세지를 출력하는 스트림)</strong><div class="indented"><p id="00e15bfb-bc82-4a9b-a022-530aa6c6a40b" class="">⇒ 이 3개의 스트림을 표준 스트림(standard stream)이라 함</p></div></p></li></ul><ul id="feab7653-5751-4689-87b6-a53b61f064ba" class="bulleted-list"><li style="list-style-type:disc">모든 출력 스트림에 사용 가능<p id="5f72c941-1795-4689-9864-ca3b7294f15a" class="">⇒ 첫 인자로 들어가는 스트림만 달라지고, 나머지는 매개변수 그대로</p></li></ul><hr id="42e7cde5-bf65-40d0-9dfb-17b36a72d772"/><p id="fdc74a8b-1328-4506-ba0c-371388283a2b" class=""><strong>&lt;버퍼링&gt;</strong></p><ul id="610714c4-1cf3-4e29-b8d8-57d1cddcb826" class="bulleted-list"><li style="list-style-type:disc">출력할 내용이 있어도 곧바로 출력하지 않고 쌓아둠</li></ul><ul id="203c4ed2-3492-46ee-a124-429e73bc28d0" class="bulleted-list"><li style="list-style-type:disc">어느정도 버퍼가 차면 그제서야 출력</li></ul><p id="eb32bb3e-8dfb-4203-8d7d-937375a1edcd" class="">&lt;<strong>버퍼링의 종류&gt;</strong></p><ul id="28d52e92-692d-4b4d-a5bf-95b2e7783e5e" class="bulleted-list"><li style="list-style-type:disc"><strong>풀 버퍼링(full buffering)</strong><p id="29f80768-d2f9-4e51-97e2-ce85db9a8dfc" class="">⇒ 버퍼가 가득 차면 비움</p><p id="6d00562e-a490-484c-ade7-a7b2382e2948" class="">⇒ 강제로 버퍼를 비우고 싶다면 fflush(stdout);을 호출하면 됨</p></li></ul><ul id="c88cd664-b580-4b4c-83f2-d56cde270cba" class="bulleted-list"><li style="list-style-type:disc"><strong>라인 버퍼링(line buffering)</strong><p id="138e61eb-de34-4042-9493-5c252be66a53" class="">⇒ 1) 버퍼가 꽉 차거나 2) 버퍼에 &#x27;/n&#x27;가 들어오면 버퍼를 비움</p><p id="58ab21ac-21fe-41da-9d0d-af25d376cdc5" class="">⇒ 강제로 버퍼를 비우고 싶다면 fflush(stdout);을 호출하면 됨</p></li></ul><ul id="4d2ee58f-4d1e-4266-8bfa-e3f98d393a3d" class="bulleted-list"><li style="list-style-type:disc"><strong>버퍼링 없음(no buffering)</strong><p id="8c2b508c-61bc-4dff-ad67-d86f75130418" class="">⇒ 버퍼를 사용하지 않음</p></li></ul><ul id="336878a4-5483-4ff5-9f91-b81593faf8d0" class="bulleted-list"><li style="list-style-type:disc">표준에서 stdout, stderr, stdin의 버퍼링 종류를 지정하지 않음 (구현에 따라 다를 수 있음)</li></ul><hr id="ab34a1d6-d468-4259-8182-f4d9093943a2"/><h2 id="39f957b8-eafa-418b-919f-5827365a1bcd" class="">sprintf()</h2><pre id="0e2f5e51-9e47-491a-8a0e-0068e19f4e33" class="code"><code>int sprintf(char* buffer, const char* format, ...);</code></pre><ul id="5cbd6cbd-d4cc-49fb-b3ad-712887ae6143" class="bulleted-list"><li style="list-style-type:disc">C에 문자열 스트림은 없지만 그 대신 <code>sprintf()</code>가 있음</li></ul><ul id="08560590-1735-4231-9e0e-598b7c5020d3" class="bulleted-list"><li style="list-style-type:disc">그냥 <code>char</code> 배열에 출력</li></ul><ul id="13eaefb0-f147-44f9-8657-14cb850efa56" class="bulleted-list"><li style="list-style-type:disc">굉장히 많이 쓰임 → 심지어 C++에서 string 클래스가 있는데도 이걸 대신 많이 씀<p id="42696f9b-7b17-45b0-ae45-ad049f4b3352" class="">Why? 속도 때문 (가장 빨리 문자열을 조작하는 함수는 C 함수)</p></li></ul><ul id="6da4cdda-f088-4b50-975c-baa0c0f90499" class="bulleted-list"><li style="list-style-type:disc">다만 프로그래머가 충분히 큰 버퍼를 잡아주지 않으면 위험함</li></ul><pre id="3df63592-2a26-4a71-a47a-dbe2c7be54bb" class="code"><code>char buffer[100];
    int score = 100;
    const char* name = &quot;Rachel&quot;;
    
    sprintf(buffer, &quot;%s: %d&quot;, name, score);
    
    printf(%s\n&quot;, buffer);
    
    /* Rachel: 100 */</code></pre><ul id="df96a963-9b8f-477e-bc91-254fe6dbe14d" class="bulleted-list"><li style="list-style-type:disc">안전하지 않음 ⇒ <code>strcpy()</code>, <code>strcat()</code>와 같은 이유</li></ul><ul id="19c5d404-29b6-4dd6-9948-cda2bcd70916" class="bulleted-list"><li style="list-style-type:disc">안전하게 돌아가게 하기 위한 n이 들어가는 함수<ol type="a" id="3717db45-9bc9-40b0-8f1f-a643cb431f0d" class="numbered-list" start="1"><li>C89에는 없음</li></ol><ol type="a" id="cecc1738-a07b-4818-b66b-b7f682218449" class="numbered-list" start="2"><li>C99에 들어옴 → <code>snprintf()</code></li></ol></li></ul><ul id="ece3bdef-9f55-4319-a951-e907eacec56d" class="bulleted-list"><li style="list-style-type:disc">대신 표준은 아니지만 컴파일러마다 다르게 제공하는 함수가 있음<ol type="a" id="0e506e5b-c66c-4c0a-8751-53bfad2d20e4" class="numbered-list" start="1"><li>예 :  마이크로소프트 비주얼 C의 <code>_snprintf()</code></li></ol><ol type="a" id="300cca95-b2f6-4eba-89d9-8261edb2af2b" class="numbered-list" start="2"><li>그러나 표준이 아니라서 작동하는 방법이 다름</li></ol></li></ul><h2 id="017760a8-b532-4593-a643-1da84b83950c" class="">기타 출력 함수</h2><h3 id="49294798-ea50-4408-9d91-12fc3aa840b9" class="">puts()</h3><pre id="58eea44c-ff2f-49e3-814e-33e7d349557b" class="code"><code>int puts(const char* str);
    int fputs(const char* str, FILE* stream);</code></pre><ul id="1a8b5b9c-3844-4f73-ae62-59634f382eaf" class="bulleted-list"><li style="list-style-type:disc"><strong>문자열을 stdout에 출력</strong></li></ul><ul id="bdfd00e2-f59b-4724-bab9-093932a0566d" class="bulleted-list"><li style="list-style-type:disc"><code>fputs(str, stdout)</code>와 매우 비슷</li></ul><h3 id="4865c11c-c032-4f95-b90b-aa0a3c1c9b3a" class="">putchar()</h3><pre id="4b32587e-0215-4560-a51f-eda4eb86ee79" class="code"><code>int putchar(int ch);
    int fputc(int ch, FILE* stream);</code></pre><ul id="ef9581b5-a1b4-4d73-90a4-5ff8536011f0" class="bulleted-list"><li style="list-style-type:disc"><strong>문자를 stdout에 출력</strong></li></ul><ul id="77e85e6c-db2c-408d-9b96-0a2f59c3038d" class="bulleted-list"><li style="list-style-type:disc"><code>fputc(ch, stdout)</code>과 같음</li></ul><p id="9ed45605-5fcc-4d60-a470-95d375151849" class="">
    </p><p id="3ac26b4a-82fb-413a-9072-ec8e1713a110" class="">
    </p></div></article></body>

{% endblock post_content %}