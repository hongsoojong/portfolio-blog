{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(1) 사용자 모두로 구현되는 기능</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Oct 12, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="14859276-fd57-4533-9e7d-634a670bf0f8" class="page sans"><div class="page-body"><h2 id="1b5c997f-b7c3-4ab4-b3a6-dccd98b9057b" class="">CPU에는 두 가지 모드가 존재함</h2><p id="ce223018-53c5-412d-acdb-8c9798bc008e" class="">1) 유저모드 : 어플리케이션 프로그램이 수행되는 모드</p><p id="480fa991-b882-40c4-8e30-b86c5caa04a7" class=""><strong>⇒ 유저가 접근할 수 있는 영역을 제한적으로 두고, 프로그램의 자원에 함부로 침범하지 못하는 모드</strong></p><p id="8ac4c33a-6e27-4e7a-b078-47dde714b361" class="">2) 커널모드 : 프로그램이 수행되다가 인터럽트가 걸려 운영체제가 호출되어 수행되는 모</p><p id="80f40d0e-c017-4a40-8c4f-11731b273d43" class=""><strong>⇒ 모든 자원(드라이버, 메모리, CPU 등)에 접근, 명령을 할 수 있음</strong></p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f707d27f-7882-429e-bb3e-778fa0ed8e5d"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>컴퓨터 과학에서 커널(Kernel)은 운영체제의 핵심 부분으로서, 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러가지 서비스(보안/자원관리/추상화)를 제공한다.</strong></div></figure><p id="0e68c4ca-3c73-4c57-85f9-de23d509881a" class="">⇒ 운영체제의 커널은 이러한 <span style="border-bottom:0.05em solid"><strong>자원을 효율적으로 관리</strong></span>하기위해서 <strong>CPU 스케줄링, 메모리관리, 입출력관리, 파일시스템 관리 등의 업무</strong>를 수행함</p><h2 id="0f844960-18b9-403c-b2cf-fa72459d086e" class="">유저모드와 커널모드의 구분</h2><ul id="bc8519d3-451f-43cc-988f-31bdbec1ecf3" class="bulleted-list"><li style="list-style-type:disc">커널 모드와 사용자 모드를 구분하기 위해 하드웨어 적으로 CPU 내부에 모드 비트(mode bit)를 사용함. <span style="border-bottom:0.05em solid">모드 비트가 0으로 세팅되어 있으면 커널 모드</span>로서 모든 명령을 수행할 수 있고, <span style="border-bottom:0.05em solid">모드 비트가 1로 세팅되어 있으면 사용자 모드</span>로서 제한된 명령만을 수행할 수 있음</li></ul><ul id="1a1d4eae-2e71-44db-8045-f19dc3d25f4c" class="bulleted-list"><li style="list-style-type:disc">그렇기 때문에 CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드 비트는 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행하게 됨</li></ul><h2 id="5f4c236e-7bd4-4214-843d-87733f605df6" class="">두 가지 모드가 존재하는 이유 ⇒ <mark class="highlight-red">I/O protection</mark></h2><ul id="7fd6f58f-9ab2-46db-b58c-e943c8d0e98d" class="bulleted-list"><li style="list-style-type:disc">예를 들면 하드디스크에 있는 내용을 지우는 어플리케이션 프로그램을 개발하여, 이것이 직접적으로 I/O 장치에 접근이 가능하다면 I/O 데이터의 보호가 이루어지지 않아 큰 문제가 발생할 수 있음</li></ul><ul id="69c09dce-0fc4-4366-87c9-c9dc19a5e868" class="bulleted-list"><li style="list-style-type:disc">이러한 상황을 방지하기 위해 어플리케이션 프로그램들은 직접 I/O에 접근할 수 없으며, 운영체제를 통해서만 I/O 장치를 사용할 수 있음<p id="af00dd91-e504-4860-81a2-ec0e4fa428ce" class=""><strong>⇒ 어떤 프로그램이 특정 디스크의 데이터를 요청하면 운영체제가 그 장치를 구동시켜 파일을 읽은 후 해당 어플리케이션 프로그램에 전달함</strong></p></li></ul><ul id="6d809d68-8c02-4bdb-b434-25fa7f84e2a0" class="bulleted-list"><li style="list-style-type:disc">또한 어셈블리어로 이루어진 어플리케이션 프로그램의 경우 운영체제의 도움없이 하드웨어에 직접적으로 명령을 내리는 것을 방지하기 위해 CPU가 해당 명령어는 실행하면 안된다는 판단이 필요함. 이를 위해 CPU에 유저모드, 커널모드 두 가지 모드가 존재함</li></ul><h2 id="a5561a62-4323-46ca-830b-80801e4d5025" class="">시스템 콜</h2><ul id="4b387171-eaf9-4f84-9a6a-5ff68d6a0d62" class="bulleted-list"><li style="list-style-type:disc">프로세스는 프로세스의 생성이나 하드웨어의 조적 등 커널의 도움이 필요한 경우 시스템 콜을 통해 커널에 처리를 요청함</li></ul><ul id="a6ec5210-5f40-43c2-bcc4-641539c04a3f" class="bulleted-list"><li style="list-style-type:disc">시스템 콜의 종류<ul id="6fe78cb9-8800-4a2c-8f53-feaebfd30208" class="bulleted-list"><li style="list-style-type:circle">프로세스 생성, 삭제</li></ul><ul id="92a455e9-88cb-40fd-9ae3-29679d47dff9" class="bulleted-list"><li style="list-style-type:circle">메모리 확보, 해제</li></ul><ul id="0f10046f-681c-470f-aaec-f0f87edb9b2e" class="bulleted-list"><li style="list-style-type:circle">프로세스 간 통신</li></ul><ul id="43181f3c-4109-462f-9f57-106ca4a94088" class="bulleted-list"><li style="list-style-type:circle">네트워크</li></ul><ul id="42e0486c-9744-4de2-989d-2ef4f23e5614" class="bulleted-list"><li style="list-style-type:circle">파일시스템 다루기</li></ul><ul id="3dd1dbba-5ff8-4682-b4c4-606496b3bc4b" class="bulleted-list"><li style="list-style-type:circle">파일 다루기(디바이스 접근)</li></ul></li></ul><h2 id="aab888ca-2843-4378-96e1-1bb23cc3e28a" class="">CPU의 모드 변경</h2><ul id="00479935-61af-4278-ad13-e2908d39a907" class="bulleted-list"><li style="list-style-type:disc">프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트가 발생함. 인터럽트 이벤트가 발생하면 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 우해 커널은 동작하기 시작함. 요청한 내용이 끝나면 커널 내의 시스템 콜 처리가 종료되어 다시 사용자모드로 전환되어 포로세스의 동작을 계속 진행함</li></ul><ul id="eaa884d2-d39a-42a2-994b-6e9aa34626a9" class="bulleted-list"><li style="list-style-type:disc">커널은 프로세스가 요청한 내용을 처리하기 전에 프로세스의 요구가 유효한지 먼저 확인함 → 요구사항이 맞지 않는다면 시스템 콜 실패 처리</li></ul><ul id="147ac5f4-0183-4567-a946-bdff1a765ab6" class="block-color-red bulleted-list"><li style="list-style-type:disc"><strong>유저모드가 시스템 콜을 통하지 않고 직접 CPU 모드에 변경하는 방법은 없음 (만약 그런 방법이 있다면 커널이 존재하더라도 사용자가 마음대로 하드웨어를 다룰 수 있어 문제가 됨)</strong></li></ul><h2 id="834e8372-6bee-44a8-8491-2023801ec000" class="">시스템 콜의 wrapper 함수</h2><ul id="c60b1ca0-78f7-4eb2-9f13-6db51e42e2af" class="bulleted-list"><li style="list-style-type:disc">리눅스에는 프로그램 작성을 도와주기 위해 프로세스 대부분에 필요한 여러 라이브러리 함수가 있음</li></ul><ul id="8a8e5c80-211e-4311-9eca-56ea93fdac82" class="bulleted-list"><li style="list-style-type:disc">시스템 콜은 보통의 함수 호출과는 다르게 C 언어 등의 고급 언어에서는 직접 호출이 불가능함. 아키텍쳐에 의존하는 어셈블리 코드를 사용해 호출해야함</li></ul><ul id="34bbffc3-617c-4cd7-875b-93e4ccc3dcd7" class="bulleted-list"><li style="list-style-type:disc">만약 OS의 도움이 없다면 각 프로그램은 시스템 콜을 호출할 때마다 아키텍쳐에 의존하는 어셈블리 언어를 써서 고급언어로부터 어셈블리 코드를 호출해야함(어셈블리 언어로 써진 시스템 콜 호출 프로그램). 이 방식은 프로그램을 작성하는데 오래 걸릴 뿐만 아니라 다른 아키텍쳐에도 사용할 수 없어 이식성도 매우 낮거나 이식할 수 없는 경우도 있음</li></ul><ul id="c9571ad8-7284-4db3-b5f4-f00561732acc" class="bulleted-list"><li style="list-style-type:disc">이러한 문제를 해결하기 위해 OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공함.  이를 시스템 콜 wrapper라고 함. 고급언어로 써진 사용자 프로그램부터는 각 언어에 대응하여 준비된 시스템 콜 wrapper 함수만 호출하면 됨</li></ul><h2 id="319566e5-8ee9-464a-bfe2-ebb281ab67ec" class="">표준 C 라이브러리</h2><ul id="95cd2b26-199b-4d3f-b1cc-be0474796200" class="bulleted-list"><li style="list-style-type:disc">C 언어에는 ISO에 의해 정해진 표준 라이브러리가 있음. 리눅스에도 이 표준 C 라이브러리가 제공되고 있으며, 보통은 GNU 프로젝트가 제공하는 glibc를 표준 C 라이브러리로 사용하고 있음. 대부분의 C  프로그램은 glibc를 링크하고 있음</li></ul><ul id="f50e6df1-75d3-4314-ac12-b2f18334f85c" class="bulleted-list"><li style="list-style-type:disc">glibc는 시스템 콜 wrapper 함수를 포함함</li></ul><h2 id="675f871f-99b1-4ba9-ac9d-e67c52c21dcb" class="">OS가 제공하는 프로그램</h2><ul id="d9849996-9486-40bd-90c9-fcc1278df48d" class="bulleted-list"><li style="list-style-type:disc">OS가 제공하는 프로그램은 OS가 제공하는 라이브러리와 마찬가지로 대부분의 프로그램이 필요로 하며, OS 동작을 변경시키는 프로그램도 OS의 일부로 포함됨<ul id="3a9251cb-0be0-4ede-89d5-634ce49b3bcf" class="bulleted-list"><li style="list-style-type:circle">시스템 초기화 : init</li></ul><ul id="3d6a467c-2d87-46f2-bca6-1b167e5b59e0" class="bulleted-list"><li style="list-style-type:circle">OS의 동작을 바꿈 : sysctl, nice, sync</li></ul><ul id="d4308b03-934f-49b9-9398-9631746eb27c" class="bulleted-list"><li style="list-style-type:circle">파일 관련 : touch, mkdir</li></ul><ul id="dbcb646b-dda7-4afe-9106-b20f48df3313" class="bulleted-list"><li style="list-style-type:circle">텍스트 데이터 가공 : grep, sort, uniq</li></ul><ul id="2e9a9118-b507-49cc-bdcb-93a14e710512" class="bulleted-list"><li style="list-style-type:circle">성능 측정 : sar, iostat</li></ul><ul id="f9df6aeb-ae23-4bbe-b8ba-197a6c8c24df" class="bulleted-list"><li style="list-style-type:circle">스크립트 언어 실행 환경 : perl, python, ruby</li></ul><ul id="d32da50e-70d2-448a-9f4c-7b5621240f0f" class="bulleted-list"><li style="list-style-type:circle">셀 : bash</li></ul><ul id="cd6a1632-d9f2-4155-bb0c-4c23d00aa126" class="bulleted-list"><li style="list-style-type:circle">윈도우 시스템 : X</li></ul><p id="6ae48dd5-d3cc-4dce-b3ff-118178398510" class="">
</p></li></ul></div></article></body>

{% endblock post_content %}