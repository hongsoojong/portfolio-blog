{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(15) C11</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Oct 05, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="6ccd15d7-6c9b-41a8-ab2e-f5c803d0d803" class="page sans"><div class="page-body"><h3 id="cc3ca2d1-c1d8-443e-8034-b2d6539db99f" class="">C11에 추가된 내용</h3><ul id="1670753e-fb35-4cb7-8f60-947e850c8f63" class="bulleted-list"><li style="list-style-type:disc">유니코드 지원 추가</li></ul><ul id="589bb65d-4857-47f3-a46b-4febc734be3d" class="bulleted-list"><li style="list-style-type:disc">보다 안전한 <code>xxx_s</code> 함수들</li></ul><ul id="1a3753f9-f636-42f2-8995-94264a3f82d6" class="bulleted-list"><li style="list-style-type:disc">Type-Generic 함수 만들기</li></ul><ul id="116c96c7-bd39-422f-a57d-612c3ff29654" class="bulleted-list"><li style="list-style-type:disc">정적 어서트</li></ul><ul id="9d6c3aee-2844-4f6e-b301-519cc36dc0c9" class="bulleted-list"><li style="list-style-type:disc"><code>_Noreturn</code></li></ul><ul id="7c531dea-bc9a-4a4d-82bf-e72fc31a9100" class="bulleted-list"><li style="list-style-type:disc">메모리 정렬</li></ul><ul id="a53fa869-cf23-49e1-9fff-40ca73b82423" class="bulleted-list"><li style="list-style-type:disc"><code>_Alignas</code></li></ul><ul id="6f74e257-8b17-40c1-850c-1d216d773577" class="bulleted-list"><li style="list-style-type:disc"><code>_Alignof</code></li></ul><ul id="5c544006-b441-423c-b6dc-92d04432ca00" class="bulleted-list"><li style="list-style-type:disc"><code>aligned_alloc()</code></li></ul><ul id="2560c4ae-0295-4e93-b09c-194dc06d543a" class="bulleted-list"><li style="list-style-type:disc">이름 없는 <code>struct</code>와 공용체</li></ul><ul id="101c50d9-ae81-4963-a9b6-b4dd0d4d3304" class="bulleted-list"><li style="list-style-type:disc">멀티스레딩</li></ul><h2 id="8faef48f-725a-446e-900c-65dd60df79d9" class="">유니코드 지원</h2><h3 id="13294f97-43f8-4e1d-b6c4-955c8b89c0c5" class="">역사적으로 사용한 방법</h3><ul id="c733a2ed-3db8-4c2f-a1d3-4980696b231a" class="bulleted-list"><li style="list-style-type:disc">목표 : A 컴퓨터에서 만든 파일을 B 컴퓨터에서 열기</li></ul><ul id="c0689f88-f9e4-4a0b-ad24-610bea0579ca" class="bulleted-list"><li style="list-style-type:disc">할 수 있는 것<ul id="f9412b02-608c-4fcb-987f-43f5f6a81131" class="bulleted-list"><li style="list-style-type:circle">와이드 문자 ↔ 멀티바이트 문자 간 변환이 가능</li></ul></li></ul><ul id="b053eb2d-0061-45a5-b46c-4b277c4646ad" class="bulleted-list"><li style="list-style-type:disc">할 수 없는 것<ul id="553c5834-ab6a-4bd0-9ca6-2115025d88d1" class="bulleted-list"><li style="list-style-type:circle">A 컴퓨터의 멀티바이트 문자를 B 컴퓨터의 멀티바이트 문자로 바로 변환 (인코딩이 다를 수도 있음)</li></ul></li></ul><ul id="7964d1de-c2e8-4c18-9e58-39a7adcf6890" class="bulleted-list"><li style="list-style-type:disc">취한 방법<ul id="958b1c73-4e10-412e-89b1-334e6a7a9019" class="bulleted-list"><li style="list-style-type:circle">A 컴퓨터의 멀티바이트 문자를 와이드 문자로 변환해서 저장</li></ul><ul id="a8301831-cb14-4ab6-aefa-baa3f4802d9c" class="bulleted-list"><li style="list-style-type:circle">B 컴퓨터에서 와이드 문자를 읽은 뒤 자신의 멀티바이트 문자로 변환 후 출력</li></ul></li></ul><ul id="c45eff29-ba8a-41a7-9d4a-5785be5d830a" class="bulleted-list"><li style="list-style-type:disc">하지만 두 플랫폼의 와이드 문자의 인코딩 또는 크기가 다르면 망함<p id="e28001a9-9cdc-4443-867e-889b6feda996" class="">⇒ 이미 시장 점유율이 가장 높은 두 운영체제가 서로 다른 와이드 문자 인코딩 방법을 사용함</p></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="67862daa-42ce-4815-a888-a5dac9a4635d"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>크기나 인코딩이 다를 수 있는 </strong><code><strong>wchar_t</strong></code><strong>말고 크기가 딱 정해진 UTF-32나 (별로지만) UTF-16을 쓸 수는 없을까?</strong></div></figure><p id="c89ddda8-f09c-4ba2-a0eb-4fb5c8c72d98" class="">⇒ C11에서는 그게 가능해짐<div class="indented"><p id="803b9c2e-6385-4efe-afd0-83d3262d5c12" class="">단, 선택적인 기능! 그래도 C11을 지원하는 플랫폼/컴파일러가 이 기능을 지원 안 할 이유가 없음</p></div></p><h3 id="6efdc97c-7405-4c06-a014-06ed3700bb24" class="">UTF-16과 UTF-32를 표현하는 자료형</h3><ul id="464003b2-716c-44a1-abf5-e40132e9d629" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;uchar.h&gt;</code>에 아래 두 매크로가 선언되어 있으면 사용 가능<pre id="457e8346-4d4a-4dfe-bc92-e3769825db1b" class="code"><code>#define __STDC_UTF_16__
#define __STDC_UTF_32__</code></pre></li></ul><ul id="542cba02-c6b2-4012-a431-5241f356af33" class="bulleted-list"><li style="list-style-type:disc"><code>char16_t</code> : UTF-16으로 인코딩된 값을 저장<ul id="02aaf5c2-0d50-4217-93d6-96fdee7bbf32" class="bulleted-list"><li style="list-style-type:circle">리터럴 : <code>u&quot;문자열&quot;</code>, <code>&quot;\unnnn&quot;</code></li></ul></li></ul><ul id="7be42e3c-f523-416b-8ae0-71e4a45df006" class="bulleted-list"><li style="list-style-type:disc"><code>char32_t</code> : UTF-32로 인코딩된 값을 저장<ul id="ede8977e-17b5-48d1-80ba-c479b282ce64" class="bulleted-list"><li style="list-style-type:circle">리터럴 : <code>U&quot;문자열&quot;</code>, <code>&quot;\Unnnnnnnn&quot;</code></li></ul></li></ul><p id="9a375004-ff8d-48fe-98b5-f2755248057b" class=""><strong>&lt;예시&gt;</strong></p><pre id="635db2d1-76b5-4194-b93b-6f46ed73bc92" class="code"><code>char16_t msg1[] = u&quot;포큐&quot;
char16_t msg2[] = u&quot;\uD3EC\uD050&quot;;

char32_t msg[3] = U&quot;포큐&quot;
char32_t msg4[] = U&quot;\U0000d3ec\U0000d050&quot;;

const char* utf16_str = u&quot;포프&quot;         // 컴파일 오류 (char pointer 불가능)
const char16_t utf16_str[] = u&quot;포프&quot;    // 컴파일 됨</code></pre><p id="117b140b-865e-4f31-b5e5-42761681f1fc" class=""><strong>&lt;바로 출력할 수 있을까&gt;</strong></p><ul id="96e6761d-348d-4e0b-a74f-1fab5ab08a71" class="bulleted-list"><li style="list-style-type:disc">당연히 바로 출력하면 제대로 안나옴<pre id="b5a21516-aa54-41d1-a8da-014a6bcece61" class="code"><code>const char16_t utf16_str[] = u&quot;포프&quot;;

printf(&quot;utf16: %s\n&quot;, utf16_str);  // 잘못된 결과 출력</code></pre><p id="3d263a4c-7777-4329-b814-2038738d570d" class="">⇒ 사용자 출력은 무조건 멀티바이트!!</p></li></ul><p id="f18c3a47-bc41-412a-bfcd-d9a2080fe941" class=""><strong>&lt;멀티바이트 문자로 변환 뒤 출력&gt;</strong></p><ul id="2fbd5cb3-2fb4-4b56-821c-7f694ae686fc" class="bulleted-list"><li style="list-style-type:disc"><code>c16rtomb()</code>, <code>c32rtomb()</code></li></ul><ul id="a0e22d8d-a2f5-4a17-868a-904d65d2d27e" class="bulleted-list"><li style="list-style-type:disc">한 문자씩 변환 (문자열 변환 함수는 없음)</li></ul><ul id="91a36945-5470-4683-9670-71a0b5c4ad9c" class="bulleted-list"><li style="list-style-type:disc">반대로 멀티바이트 문자를 UTF-16/32로 변환하는 함수도 있음<ul id="c1c48bc7-77d3-4dc2-bcda-bcaff4362a7b" class="bulleted-list"><li style="list-style-type:circle"><code>mbrtoc16()</code> </li></ul><ul id="919a9ea3-d720-4a09-b86e-754da992d8f7" class="bulleted-list"><li style="list-style-type:circle"><code>mbrtoc32()</code></li></ul></li></ul><p id="12758db4-0360-4d93-9158-a1aaac3fcf12" class=""><strong>&lt;멀티바이트 문자로 변환 뒤 출력하기 예&gt;</strong></p><pre id="db795bc9-0db0-45a9-b6e9-b0cdc87b0859" class="code"><code>const char16_t utf16_str[] = u&quot;포프&quot;;
mbstate_t state = { 0, };
char buffer[64];
char* p = buffer;

for (size_t i = 0; i &lt; ARRAY_LENGTH(utf16_str); ++i) P
	size_t num_bytes = c16rtomb(p, utf16_str[i], &amp;state);
	if ((size_t)-1 == num_bytes) {
		break;
	}
	
	p += num_bytes;
}</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8c46c363-bdfb-4ef3-baac-c44748411505"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>UTF-16이 있으면 wchar_t의 문제를 극복할 수 있음!</strong></div></figure><p id="e599b284-a88a-4757-89af-1e08e43cc8df" class=""><strong>&lt;UTF-16, UTF-32를 사용하면&gt;</strong></p><ul id="69431511-aa9f-43ad-88f9-4f8436aac73d" class="bulleted-list"><li style="list-style-type:disc"><code>wchar_t</code>를 사용할 경우<p id="ffb3ce79-8c4d-4299-992a-d744ada9ee0e" class="">파일(<code>wchar_t</code> 인코딩) &gt; <code>wchar_t</code> &gt; 멀티바이트 문자 &gt; 입출력</p></li></ul><ul id="1ceb90fa-9d71-4373-afba-45be4d69d94d" class="bulleted-list"><li style="list-style-type:disc"><code>char16_t/char32_t</code>를 사용할 경우<p id="9789d2fc-a055-4431-8a4e-3979c536bc89" class="">파일(<code>UTF-16/32</code>) &gt; <code>UTF-16/32</code> &gt; 멀티바이트 문자 &gt; 입출력</p></li></ul><ul id="d288a98c-4989-4870-8c2e-71c0e5023045" class="bulleted-list"><li style="list-style-type:disc">즉 포팅이 불가능한 <code>wchar_t</code>를 대체 가능</li></ul><ul id="bea2435a-eacf-4da5-a0d6-19f9832949d2" class="bulleted-list"><li style="list-style-type:disc"><code>wchar_t</code>없이 유니코드 문자를 멀티바이트 문자로 곧바로 변환</li></ul><p id="58bf659c-1e2d-4cb0-aeea-a00a36cf51b8" class=""><strong>&lt;단, 아직도 </strong><code><strong>wchar_t</strong></code><strong>를 써야할 일들은 있음&gt;</strong></p><ul id="3d23ca8e-0b41-4bb7-ad02-8d2f4a4e3279" class="bulleted-list"><li style="list-style-type:disc">운영체제 함수들이 매개변수로 와이드 문자열을 요구</li></ul><p id="36671383-e489-47bf-8361-182f3a31f122" class=""><strong>&lt;Why not UTF-8??&gt;</strong></p><ul id="e90e26ed-782e-4acd-bec4-3f1329ec0906" class="bulleted-list"><li style="list-style-type:disc">C11에서는 아직 못 씀</li></ul><ul id="fdd64e48-9952-4bbb-bf35-c3319d74ce33" class="bulleted-list"><li style="list-style-type:disc">그러나 C22에 넣자고 제안된 상태</li></ul><ul id="d6de4c5e-eaee-489b-9b5f-97442984eabb" class="bulleted-list"><li style="list-style-type:disc">들어온다면 <code>char8_t</code>가 될 것으로 예상 → 역시<code>__STDC_UTF_8__</code> 매크로도 정의될 것임</li></ul><h2 id="8f6364a6-96a3-45bc-86b8-5b30d7460414" class="">다국어 지원 접근 방법</h2><h3 id="0cd0827f-ec23-4008-8de2-e5048fdfde86" class="">다국어 지원의 기본 원칙</h3><ul id="7e8aff80-a34f-41b0-a68b-7fd2c5b6a0ed" class="bulleted-list"><li style="list-style-type:disc">기본 원칙<p id="13827ec3-a45b-405f-9c25-93bec5817683" class="">1) 사용자에게 보여주지 않을 경우 문자열은 전부 아스키로 저장하자</p><p id="4c1dcbb8-fe9a-4f3b-a25b-269477e6088d" class="">2) 다국어 지원은 사용자에게 보여줄 문자열만 하자</p><p id="14fa1278-7368-4671-a175-ea0fcfec4d47" class="">3) 파일로 저장할 때는 공통된 인코딩이 좋다 (요즘 시대의 최선은 UTF-8_</p></li></ul><ul id="1f4ecf52-8ca5-4fd4-9c16-b74a845d1829" class="bulleted-list"><li style="list-style-type:disc">가장 편한 건 ICU 라이브러리를 쓰는 것</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d44361e6-1e9e-4555-8c14-ec90ba1b9538"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>ICU를 사용할 수 없다면 이제부터 설명할 방법 중 하나를 사용하면 됨! 우선 순위에 따라 정리할 예정이며 앞의 방법을 사용할 수 있다면 뒤 방법은 신경쓰지 않아도 됨 → UTF-8로 파일을 저장한다는 가정</strong></div></figure><h3 id="6a1dd8f3-320b-4302-8ba0-293487ab045e" class="">(1) 최상의 시나리오 (C89 이상)</h3><ul id="d5c590b2-3454-46c4-bdc9-02da97ecb61d" class="bulleted-list"><li style="list-style-type:disc">사용자의 환경을 무조건 UTF-8로 만들자<ul id="b8651576-4394-4af6-81f4-ecc66ff124d0" class="bulleted-list"><li style="list-style-type:circle">사실상 회사에서 사용할 때만 가능</li></ul></li></ul><ul id="d1caeb7a-57a7-4023-ab9a-3aff5e11e921" class="bulleted-list"><li style="list-style-type:disc">멀티바이트 문자도 UTF-8 인코딩이니 그대로 저장</li></ul><ul id="12f49980-552a-467a-9c8c-a66ac2b4573b" class="bulleted-list"><li style="list-style-type:disc">다시 파일을 읽어서 보여줄 때도 UTF-8이므로 그대로 멀티바이트 문자로 출력</li></ul><ul id="9cd4f6a8-5a33-4199-a181-d5480f58fb8b" class="bulleted-list"><li style="list-style-type:disc">어느 방향도 변환 없음</li></ul><ul id="d18e1b4b-6f92-4d11-bc90-530c28cdfc62" class="bulleted-list"><li style="list-style-type:disc">파일(UTF-8) &gt; 멀티바이트 문자(UTF-8) &gt; 입출력(UTF-8)</li></ul><h3 id="02814b38-7679-4d56-a6c7-1106e84ceb92" class="">(2) wchar_t가 UTF-32인 경우 (C89 이상)</h3><ul id="9587df1e-bd5c-46bc-aeba-8ec8612057b1" class="bulleted-list"><li style="list-style-type:disc">멀티바이트 문자를 와이드 문자로 변환</li></ul><ul id="83045c44-4151-4df7-a843-a3af8d39ebd4" class="bulleted-list"><li style="list-style-type:disc">와이드 문자가 UTF-8니 코드 포인트가 그대로 4바이트에 저장되어 있음</li></ul><ul id="45fb573b-ece4-4838-bc5a-3a9f8ec1b333" class="bulleted-list"><li style="list-style-type:disc">이걸 직접 장성한 UTF-8 변환 함수를 사용해서 UTF-8로 변환 뒤 파일로 저장</li></ul><ul id="8725aacd-9bc3-47b0-8435-c7a38927af05" class="bulleted-list"><li style="list-style-type:disc">파일을 열 때는 그냥 반대 과정을 거침</li></ul><ul id="d21004b5-5a64-485d-9d13-464df9aa76be" class="bulleted-list"><li style="list-style-type:disc">각 방향 당 변환 두 번</li></ul><ul id="faecfb00-f08a-495c-8f3d-09d360ef9b13" class="bulleted-list"><li style="list-style-type:disc">파일(UTF-8) &gt; UTF-8 &gt; (자체 제작 함수 사용) &gt; 와이드 문자(UTF-32) &gt; (C 함수 사용) &gt; 멀티바이트 문자(??) &gt; 입출력(??)</li></ul><h3 id="d2454677-d5ef-40a2-91d9-2939861bf0d3" class="">(3) char32_t가 UTF-32인 경우 (C11 이상)</h3><ul id="1e45a450-244d-4505-9ee3-672bc45e1043" class="bulleted-list"><li style="list-style-type:disc">멀티바이트 문자를 <code>char32_t</code>로 변환</li></ul><ul id="d0e7aadc-3643-4403-87a1-ee244d656e93" class="bulleted-list"><li style="list-style-type:disc">UTF-32니 코드 포인트가 그대로 4바이트로 저장되어 있음</li></ul><ul id="0c28cbdf-571e-47d6-a82b-5b662668578d" class="bulleted-list"><li style="list-style-type:disc">이걸 직접 작성한 UTF-8 변환 함수를 사용해서 UTF-7로 변환 뒤 파일로 저장</li></ul><ul id="29bc0a16-4fe5-45c8-abd7-dcbd2cf47008" class="bulleted-list"><li style="list-style-type:disc">파일을 열 때는 그냥 반대 과정을 거침</li></ul><ul id="d20c508e-e8c0-4acd-8f06-c71421da5da1" class="bulleted-list"><li style="list-style-type:disc">각 방향 당 변환은 두 번</li></ul><ul id="69540ba5-4163-4e30-8701-94489f7f136c" class="bulleted-list"><li style="list-style-type:disc">파일(UTF-8) &gt; UTF-8 &gt; (자체 제작 함수 사용) &gt; <code>char32_t</code> &gt; (C 함수 사용) &gt; 멀티바이트 문자(??) &gt; 입출력(??)</li></ul><h3 id="1f9376ba-7001-4ab3-a3f4-42c0dbe89836" class="">(4) char8_t가 UTF-8인 경우 (C22 이상)</h3><ul id="be5c3463-bf71-441e-8f90-084802ec3436" class="bulleted-list"><li style="list-style-type:disc">멀티바이트 문자를 <code>char8_t</code>로 변환</li></ul><ul id="488fe0f3-c6e2-40c1-9880-8a43c0ff78b1" class="bulleted-list"><li style="list-style-type:disc">이걸 그대로 파일로 저장</li></ul><ul id="bc9de206-278a-45fa-aa1b-2d314f83398d" class="bulleted-list"><li style="list-style-type:disc">파일을 열 때는 그냥 반대 과정을 거침</li></ul><ul id="1e659c42-647e-43d6-8918-7782fb05b340" class="bulleted-list"><li style="list-style-type:disc">각 방향 당 변환 한 번!</li></ul><ul id="b040d4a5-a61f-4d05-ab29-83d83de566a5" class="bulleted-list"><li style="list-style-type:disc">파일(UTF-8) &gt; <code>char8_t</code> &gt; (C 함수 사용) &gt; 멀티바이트 문자(??) &gt; 입출력(??)</li></ul><h2 id="d7122874-27de-4884-a907-faef513456a2" class="">새로운 안전한(?) 함수</h2><h3 id="e205c641-50db-4465-a0a5-7760e3a512a4" class="">경계 점검(bounds-check) 함수</h3><ul id="b29943b3-602a-4706-aca0-8374154dc323" class="bulleted-list"><li style="list-style-type:disc">경계 점검 : 올바르게 메모리에 접근하는지 확인하는 것</li></ul><ul id="16d0cecf-661e-4c83-9fdb-fbc1b1c85258" class="bulleted-list"><li style="list-style-type:disc">예 :<ul id="71020598-dfc4-4c76-8947-57d583b29e10" class="bulleted-list"><li style="list-style-type:circle">사용할 배열 색인이 실제 배열의 범위 안에 있는지</li></ul><ul id="33bb653f-23b2-4d8b-934b-14d935dbec8f" class="bulleted-list"><li style="list-style-type:circle">변수에 저정할 갑싱 변수형이 허용하는 범위 안에 있는지</li></ul><ul id="8d2f1b0d-160f-4a19-b751-1f6fdee2fd29" class="bulleted-list"><li style="list-style-type:circle">등</li></ul></li></ul><ul id="a846ab60-9dac-42be-aeb5-3e7435a2e8c2" class="bulleted-list"><li style="list-style-type:disc">이것저것 검사하다보니 속도가 느려질 수 있음</li></ul><ul id="239edc5c-6c7b-4124-b551-59c5ffca805c" class="bulleted-list"><li style="list-style-type:disc">기존의 C 함수들은 이런 검사를 해주지 않음 (성능이 우선)</li></ul><ul id="cafe7132-0517-4ca3-ad67-2cecb140698e" class="bulleted-list"><li style="list-style-type:disc">C11은 안전한 메모리 접근을 보장하기 위해 경계 점검을 하는 함수를 다수 추가</li></ul><p id="fce025ef-6024-4696-8edd-84d9b4aeccb7" class=""><strong>&lt;하지만 논란이 많은 기능&gt;</strong></p><ul id="8f65143e-f325-4519-b865-108aad126647" class="bulleted-list"><li style="list-style-type:disc">반드시 구현해야하는 함수가 아님<ul id="0e96d3f9-5f7c-484f-9ec1-c4d28b8435e0" class="bulleted-list"><li style="list-style-type:circle">GCC의 경우 구현 안함</li></ul></li></ul><ul id="fcc5675c-4d77-4bd4-b419-c92f41950ab5" class="bulleted-list"><li style="list-style-type:disc">심지어 다음 버전에서 퇴출하자라는 제안이 올라옴</li></ul><h3 id="e0aa67a1-f925-4b86-b6ee-ea0013de0d62" class=""><strong>경계 점검 함수 사용하기</strong></h3><ul id="6fcaa82a-adb3-428e-8d4d-6be9701ad40e" class="bulleted-list"><li style="list-style-type:disc">다음의 매크로를 정의되어 있으면 이 기능을 지원하느 컴파일러<pre id="4128976c-29ca-4ba0-8e35-de5aa76ea5b4" class="code"><code>#define __STDC_LIB_EXT1__</code></pre></li></ul><ul id="46516b44-0329-431b-af4a-aaa97281ab0e" class="bulleted-list"><li style="list-style-type:disc">이 함수들을 활성화시키려면 다음의 매크로를 선언해야함<ul id="4003baa6-dce4-46e1-bc3f-eeabbb6bac2d" class="bulleted-list"><li style="list-style-type:circle">주의 : 관련 헤더파일을 인클루드하기 전에 선언할 것</li></ul><pre id="5a0cb5e3-2a58-46fb-8baf-a731c378f15f" class="code"><code>#define __STDC_WANT_LIB_EXT1__1</code></pre></li></ul><h3 id="7d7dd425-f98e-4665-978f-855ec11b0b2d" class=""><strong>경계 점검 함수들 (일부)</strong></h3><ul id="c612b5ef-e1b7-4b9d-8f39-99dc8782368b" class="bulleted-list"><li style="list-style-type:disc"><code>fprintf_s()</code> / <code>printf_s()</code></li></ul><ul id="d08fa3f6-be85-40d0-9c12-0d599d058479" class="bulleted-list"><li style="list-style-type:disc"><code>gets_s()</code></li></ul><ul id="aa0554c0-3042-450b-b84f-c8d0894f16fe" class="bulleted-list"><li style="list-style-type:disc"><code>sprint_()</code> / <code>snprintf_s()</code></li></ul><ul id="0a1d7075-84b8-4bb3-bc59-2fcd9c9bf891" class="bulleted-list"><li style="list-style-type:disc"><code>fopen_s()</code></li></ul><ul id="5d2b5343-9f15-4176-9a35-bfe76e24cec3" class="bulleted-list"><li style="list-style-type:disc"><code>strcpy_s()</code> / <code>strncpy_s()</code></li></ul><ul id="a140d600-03a7-473c-834c-0381053ecb53" class="bulleted-list"><li style="list-style-type:disc">등</li></ul><h3 id="f43a71c4-2dfd-47c5-8bd4-834f470ffbb0" class="">경계 점검 관련 변수 및 매크로</h3><ul id="fc57f36d-bb67-40b9-a151-508a7c0a494f" class="bulleted-list"><li style="list-style-type:disc"><code>errno_t</code><ul id="2bfa6391-6e56-4730-9e2f-fdf2f47ece0e" class="bulleted-list"><li style="list-style-type:circle">함수의 반환값으로 사용</li></ul><ul id="d14f720e-c942-416e-8b2a-46a763518a05" class="bulleted-list"><li style="list-style-type:circle">0이면 성공 아니면 실패</li></ul></li></ul><ul id="e9ad1be6-65c4-4fe9-952f-f66303760369" class="bulleted-list"><li style="list-style-type:disc"><code>rsize_t</code><ul id="906ea4cb-d1a9-4716-a312-8e3a7f97dad5" class="bulleted-list"><li style="list-style-type:circle"><code>size_t</code>와 같은 형을 typedef한 것 → 하는 일도 같음</li></ul><ul id="c58e4fa4-7452-41f0-aa0f-07629ebe6ccf" class="bulleted-list"><li style="list-style-type:circle">스스로 경계를 검사하라는 함수라는 사실을 표시하기 위해 사용</li></ul></li></ul><ul id="7010b8a8-6343-4a65-8831-fe81e19d464d" class="bulleted-list"><li style="list-style-type:disc"><code>RSIZE_MAX</code><ul id="24c5de34-b1a0-441d-8e19-929c52d26f4f" class="bulleted-list"><li style="list-style-type:circle">경계 점검 함수에서 허용하는 버퍼의 최대 크기</li></ul><ul id="25e5c8ae-fb1d-43b3-8e98-f78d172a204d" class="bulleted-list"><li style="list-style-type:circle">상수일 수도 있고 실행 중에 변하는 변수일 수도 있음</li></ul></li></ul><h3 id="e06a8a0a-bc43-42ee-a993-67695027dae8" class="">gets_s()</h3><p id="a73cc1fc-d61e-4cf7-a3c6-aa2b4e044268" class=""><strong>&lt;</strong><code><strong>gets()</strong></code><strong>가 제거됨&gt;</strong></p><ul id="83fb5f3a-a535-4c7e-92d0-167c2c1dbf24" class="bulleted-list"><li style="list-style-type:disc">C11에서부터 완전히 제거됨</li></ul><ul id="d0d6d2d9-de84-4d04-aeff-74565a3c2c22" class="bulleted-list"><li style="list-style-type:disc">후방 호환성을 중시하는 C에서 함수를 제거하는 일은 매우 드문 일</li></ul><ul id="a45795f0-97e5-4cf7-87b0-754d7e5fef12" class="bulleted-list"><li style="list-style-type:disc">그만큼 위험한 함수 (버퍼 오버플로의 가능성)</li></ul><ul id="cd04195f-0b06-43ad-8d03-4dd96a9f5db7" class="bulleted-list"><li style="list-style-type:disc">기본적으로 <code>fgets()</code>를 쓰면 됨</li></ul><ul id="776a0ea3-cf08-4670-a9e0-3ed8ff9b859b" class="bulleted-list"><li style="list-style-type:disc"><code>_s</code> 함수를 좀 더 안전하게 쓰려면 <code>gets_s()</code><strong>&lt;</strong></li></ul><p id="fb303603-8794-44b8-bce7-696b6e6256e9" class=""><strong>&lt;</strong><code><strong>gets_s()</strong></code><strong>&gt;</strong></p><pre id="d58d183e-8258-48da-9237-649aa4430307" class="code"><code>char* gets_s*char* str, rsize_t n);</code></pre><ul id="f8666ff9-3b45-4828-a7aa-5f3997d87a25" class="bulleted-list"><li style="list-style-type:disc"><code>str</code>에 n-1개의 문자까지 저장</li></ul><ul id="71579d65-b074-481d-aeb3-6360d53f49e4" class="bulleted-list"><li style="list-style-type:disc">언제나 마지막에 널 문자를 붙여줌</li></ul><ul id="37ee60ec-a05a-4f13-a2a6-6efc399b7658" class="bulleted-list"><li style="list-style-type:disc">실행 중에 다음과 같은 오류를 감지함<ul id="4174525a-4646-4e7d-82fd-ba09b886443d" class="bulleted-list"><li style="list-style-type:circle">n이 0이거나 <code>RSIZE_MAZ</code>보다 클 경우</li></ul><ul id="7e8b32f9-9741-45a9-bb2f-3c3a50f6c092" class="bulleted-list"><li style="list-style-type:circle"><code>str</code>이 널 포인터인 경우</li></ul><ul id="7057beca-a77a-42df-8ac5-ccc0327a3657" class="bulleted-list"><li style="list-style-type:circle">n-1개의 문자를 저장한 후에 줄바꿈이나 <code>EOF</code>가 발생하지 않을 때</li></ul></li></ul><ul id="af2676b3-594b-48a7-b2d0-cda44fa0da80" class="bulleted-list"><li style="list-style-type:disc">오류가 감지되면?<p id="ca5edbd7-8ec2-40ee-8287-8bed7c63ed78" class="">1) <code>stdin</code>으로부터 내용을 읽고 줄바꿈이나 <code>EOF</code>를 만날 떄까지 문자를 버림</p><p id="80342b76-dfa1-42f1-8aac-e99cd20c719c" class="">2) 그 뒤에 등록된 핸들러(handler) 함수를 호출함</p></li></ul><h3 id="1e88775c-c565-4ce2-bfc0-40453b7f6988" class="">sprintf_s(), snprintf_s()</h3><pre id="d14fe177-52de-4920-970d-d0895ba19b0d" class="code"><code>int sprintf_s(char* restrict buffer, rsize_t bufsz, const char* restrict format, ...);</code></pre><ul id="1ef998af-16d5-4991-9e22-3136c4b53d6f" class="bulleted-list"><li style="list-style-type:disc"><code>snprintf_s()</code>도 매개변수 목록은 같음</li></ul><ul id="61c792d1-4f9e-4209-b183-975d04d17416" class="bulleted-list"><li style="list-style-type:disc">실행 중 다음과 같은 오류들을 감지함<ul id="b73a40b4-a082-491c-9535-16178399541e" class="bulleted-list"><li style="list-style-type:circle"><code>format</code>이나 <code>buffer</code>가 널 포인터일 경우</li></ul><ul id="2dea8726-1e5e-4926-96de-e5fe671f5901" class="bulleted-list"><li style="list-style-type:circle"><code>bufsz</code>의 크기가 0이거나 <code>RSIZE_MAX</code>보다 클 경우</li></ul><ul id="ad9ea113-0d02-4395-8ea3-a0e3ca970cb3" class="bulleted-list"><li style="list-style-type:circle"><code>format</code> 안에 있는 &#x27;<code>%s</code>&#x27;에 대응하는 인자가 널 포인터일 경우</li></ul><ul id="8221c2c9-1c3d-4bdf-a77a-d28692ebb5af" class="bulleted-list"><li style="list-style-type:circle"><code>(sprintf_s) buffer</code>에 저장될 문자열의 길이가 <code>bufsz</code>보다 큰 경우</li></ul></li></ul><h3 id="f87a903a-3bfe-423c-81a3-674dd25e61d2" class="">fopen_s()</h3><pre id="c69f9a13-0360-4aa7-8b50-1f2ed1b029c2" class="code"><code>errno_t fopen_S(FILE* restrict* restrict streamptr, cont char* restrict filename, const char* restrict mode);</code></pre><ul id="9422a077-c682-40f2-8a86-10ce262ac438" class="bulleted-list"><li style="list-style-type:disc">이 함수로 파일을 열면 (&quot;<code>w</code>&quot;나 &quot;<code>a</code>&quot; 모드)( 배타적으로 파일 사용<ul id="c42e53d0-0fa5-4642-9089-bdef51d0074e" class="bulleted-list"><li style="list-style-type:circle">즉, 다른 프로그램이 동시에 이 파일에 접근 불가</li></ul></li></ul><ul id="946765c7-cf9a-430f-8216-5cf9258bba65" class="bulleted-list"><li style="list-style-type:disc"><code>streamptr</code> : 파일 스트림의 포인터의 포인터</li></ul><ul id="e244b99c-8e60-4c15-8387-7a9850df9178" class="bulleted-list"><li style="list-style-type:disc"><code>mode</code> : 새로 추가된 모드<ul id="574d5b6a-20f8-4c85-a3a8-ad8f04a0f155" class="bulleted-list"><li style="list-style-type:circle">&quot;<code>x</code>&quot; : &quot;<code>w</code>&quot; 또는 &quot;<code>w+</code>&quot;와 함께 사용 / 파일이 이미 있다면 덮어쓰기 대신 그냥 실패</li></ul><ul id="ddec0b5f-e66d-4546-9fd9-b630bd4858a4" class="bulleted-list"><li style="list-style-type:circle">&quot;<code>u</code>&quot; : &quot;<code>w</code>&quot; 또는 &quot;<code>a</code>&quot;와 함께 사용 / 예전처럼 다른 프로그램의 파일 접근을 허용</li></ul></li></ul><ul id="e8530fc8-0ed0-4867-8bfe-1d183e82a8db" class="bulleted-list"><li style="list-style-type:disc">실행 중에 다음과 같은 오류들을 감지함<ul id="31c8b060-944e-4f33-a13d-13328dc47ace" class="bulleted-list"><li style="list-style-type:circle"><code>streamptr</code>가 널 포인터일 경우</li></ul><ul id="0bb4710b-0766-4e69-9e56-f0cf2221c901" class="bulleted-list"><li style="list-style-type:circle"><code>filename</code>이 널 포인터일 경우</li></ul><ul id="9f7cc40a-14b7-47b3-9502-c3ef03b36eef" class="bulleted-list"><li style="list-style-type:circle"><code>mode</code>가 널 포인터일 경우</li></ul></li></ul><h3 id="65293eea-bffe-4b29-8bd3-21a59ed77d37" class="">strlen_s()</h3><pre id="39dbe7dd-7256-4dc4-a288-3898bcc4caac" class="code"><code>size_t strnlen_s(const char* str, size_t strsz);</code></pre><ul id="8e7bc082-f30d-45c3-bcb2-ac938f5ebaea" class="bulleted-list"><li style="list-style-type:disc">반환값<ul id="30800701-a6c4-4d55-8446-deabf0c31915" class="bulleted-list"><li style="list-style-type:circle"><code>str</code>의 길이 : 성공</li></ul><ul id="8592acfb-2a15-43a9-829e-e89bfed3d5a3" class="bulleted-list"><li style="list-style-type:circle"><code>0</code> : <code>str</code>이 널 포인터</li></ul><ul id="9ee6edca-d4bb-433a-9968-a4f2ec795c58" class="bulleted-list"><li style="list-style-type:circle"><code>strsz</code> : <code>str</code>에서 시작하여 <code>strsz</code>개를 읽었는데도 널 문자를 찾지 못함</li></ul><ul id="1bf13af9-a7cc-4122-8759-f825c32f0ff8" class="bulleted-list"><li style="list-style-type:circle"></li></ul></li></ul><ul id="e47644b3-ec8e-4ea4-8d96-ad0eeb8a4890" class="bulleted-list"><li style="list-style-type:disc">결과가 정의되지 않음<ul id="910f7702-c910-41fb-9820-f548e7936a30" class="bulleted-list"><li style="list-style-type:circle"><code>str</code>에 널 문자가 없고 <code>str</code>의 실제 길이가 <code>strsz</code>보다 작을 경우</li></ul><ul id="b3ffe24b-9ea4-40b3-bb31-bb178f3d5ec3" class="bulleted-list"><li style="list-style-type:circle">소유하지 않은 메모리를 읽게 되니 당연한 결과</li></ul></li></ul><h3 id="65025dd7-9233-4ee7-bc43-fbc30c7d3809" class="">strcpy_s()</h3><pre id="2940e364-52a9-467f-a136-40277c1df7c5" class="code"><code>errno_t strcpy_s(char* restrict dest, rsize_t destsz, const char* restrict src);</code></pre><ul id="a772dcd3-c09d-4500-a54c-c69aa7684020" class="bulleted-list"><li style="list-style-type:disc"><code>strcpy()</code>와 다른 점<ul id="f37e28fa-4116-47de-9780-fc40e5c8baf2" class="bulleted-list"><li style="list-style-type:circle">복사 후 남은 <code>dest</code> 공간에 쓰레기 값이 들어있을 수 있음</li></ul><ul id="23b8faa9-09e3-4254-83fd-bf49595b676e" class="bulleted-list"><li style="list-style-type:circle">성능 향상을 위해 한번에 여러 바이트씩 복사할 수도 있기 때문</li></ul></li></ul><ul id="02b4eecb-f270-488c-96eb-a8c278f2366a" class="bulleted-list"><li style="list-style-type:disc">실행 중 다음과 같은 오류들을 감지함<ul id="3e467b10-61a6-44ed-ac2f-961d2a7f7eec" class="bulleted-list"><li style="list-style-type:circle"><code>src</code>나 <code>dest</code>가 널 포인터인 경우</li></ul><ul id="5bae3c21-428b-4237-8bc9-eb0aac3e7043" class="bulleted-list"><li style="list-style-type:circle"><code>destsz</code>가 0이거나 <code>RSIZE_MAX</code>보다 클 경우</li></ul><ul id="490fef1e-4c38-4cbd-ae54-c2aa280a9331" class="bulleted-list"><li style="list-style-type:circle"><code>destsz == strnlen_s(src, destsz)</code> : 즉, 널 문자가 들어갈 공간이 없을 때</li></ul><ul id="9b3841af-2bd3-408a-b7b1-feb379a52e4e" class="bulleted-list"><li style="list-style-type:circle"><code>src</code>와 <code>dest</code>의 메모리 공간이 겹칠 때</li></ul></li></ul><ul id="39598ab9-a24f-4273-bbe0-64e4e1689b46" class="bulleted-list"><li style="list-style-type:disc">다음의 경우 결과가 정의되지 않음<ul id="2c6a1c15-61d0-4d51-bd6f-b633c6d44629" class="bulleted-list"><li style="list-style-type:circle"><code>dest</code>의 실제 배열 크기 ≤ <code>strnlen_s(src, destsz)</code> &lt; <code>destsz</code></li></ul></li></ul><h3 id="bf83efa1-bf97-4f34-af15-dc11c40c621d" class="">strncpy_s</h3><pre id="59c21355-5dcc-4b95-82d2-eaae1834c8da" class="code"><code>errno_t strncpy_s(char* restrict dest, rsize_t destsz, const char* restrict src, rszie_t count);</code></pre><ul id="a35c9b88-a2a3-46a7-9ab8-fd8d510ac392" class="bulleted-list"><li style="list-style-type:disc">최대 <code>count</code>개의 문자를 복사 후 널 문자도 붙여줌</li></ul><ul id="ea9464af-e4e4-4623-a57a-d72344bd0920" class="bulleted-list"><li style="list-style-type:disc"><code>strncpy()</code>와 다른 점<ul id="0228feaa-8e7d-4487-a64d-fcd06990b10c" class="bulleted-list"><li style="list-style-type:circle"><code>strncpy()</code>는 복사 후 남은 공간을 0으로 채워줌</li></ul><ul id="2630b24e-754b-4ee4-b991-8edf6c34df60" class="bulleted-list"><li style="list-style-type:circle"><code>strncpy_s()</code>는 널 문자 뒤 남은 공간을 쓰레기 값이 들어있을 수도 있음</li></ul></li></ul><ul id="87634bea-61c3-4c1c-8734-cb69225f9b57" class="bulleted-list"><li style="list-style-type:disc">실행 중 다음과 같은 오류들을 감지함<ul id="da8def2a-6f54-4efc-b57f-29768d15230c" class="bulleted-list"><li style="list-style-type:circle"><code>src</code>나 <code>dest</code>가 널 포인터인 경우</li></ul><ul id="513a566d-36bb-4b0d-98e4-1f74d0eb9161" class="bulleted-list"><li style="list-style-type:circle"><code>destsz</code>나 <code>count</code>가 0이거나 <code>RSIZE_MAX</code>보다 클 때</li></ul><ul id="90eeb3eb-7475-471f-9b14-94889b549f40" class="bulleted-list"><li style="list-style-type:circle"><code>destsz</code> ≤ <code>strnlen_s(src, count)</code> : <code>dest</code>보다 <code>src</code>가 길 때</li></ul><ul id="40b47f47-ca7a-4746-bed4-92b419864010" class="bulleted-list"><li style="list-style-type:circle"><code>src</code>와 <code>dest</code>의 메모리 공간이 겹칠 때</li></ul></li></ul><ul id="a75c6060-cd48-4374-bae2-fc13fe3ae086" class="bulleted-list"><li style="list-style-type:disc">다음 경우, 결과가 정의되지 않음<ul id="790b0939-11ab-410e-bc71-1a409e0c8969" class="bulleted-list"><li style="list-style-type:circle"><code>dest</code>의 실제 배열 크기 &lt; <code>strnlen_s(src, destsz)</code> ≤ <code>destsz</code></li></ul><ul id="c3d6a365-54c7-429e-869f-ce927c9b35c5" class="bulleted-list"><li style="list-style-type:circle"><code>src</code>의 실제 배열 크기 &lt; <code>strnlen_s(src, count)</code> &lt; <code>destsz</code></li></ul></li></ul><h3 id="be8de7ac-3368-4f5a-8296-4bea2ca5e4b4" class="">논란의 여지가 많은 _s 함수</h3><ul id="f12a34bd-aca3-426e-85d8-3bd7d1e7063d" class="bulleted-list"><li style="list-style-type:disc">메모리를 보호한다고 <code>_s</code> 함수들이 반드시 올바르다고 볼 수는 없음<ul id="178563ac-ca00-4ef8-ac0d-16316e96874b" class="bulleted-list"><li style="list-style-type:circle">심지어 모든 경우를 방어하지도 않음</li></ul><ul id="8a07187e-b31d-4064-90f3-2faf72de9cbc" class="bulleted-list"><li style="list-style-type:circle">각 함수마다 규칙도 목잡해짐</li></ul><ul id="c067e937-a62e-4e39-b04e-829506db6cd7" class="bulleted-list"><li style="list-style-type:circle">복잡한 규칙은 실수할 여지를 증가</li></ul></li></ul><ul id="64306fc2-3fcb-46cb-a0c7-ef1656d7539a" class="bulleted-list"><li style="list-style-type:disc">무조건 안전한 함수를 쓰자는 주장은 언매니지드 언어 개발자에게 잘 안 통하는 논리<ul id="bdc15ae0-1983-4a74-96e5-b4f7385a30f1" class="bulleted-list"><li style="list-style-type:circle">성능을 포기해야 하기 때문</li></ul><ul id="925148c7-cfca-4a94-92fd-71466f7e0152" class="bulleted-list"><li style="list-style-type:circle">내부 동작원리가 직관적으로 안보이는 문제도 있음</li></ul></li></ul><ul id="b424956d-822f-424f-9c1e-282e83c50be7" class="bulleted-list"><li style="list-style-type:disc">이런 오류들을 핸들러에서 어떻게 처리해줄지 명백하지 않음</li></ul><ul id="564287d1-01e5-4cd5-9b5f-e0f05be457a6" class="bulleted-list"><li style="list-style-type:disc">실제로 논란의 여지가 많아서 널리 구현되지 않음</li></ul><h3 id="3d8efd24-c197-470d-9f45-8439189e4591" class="">안전한 코딩은 프로그래머의 몫</h3><ul id="b2fa3129-7657-4b4d-b399-d6ecf37fd3bc" class="bulleted-list"><li style="list-style-type:disc"><code>_s</code> 함수들은 방어한다고 이것저것 내부적으로 추가한 게 많음</li></ul><ul id="6b51ed9b-e308-44a3-ade2-6ccc4fbe0367" class="bulleted-list"><li style="list-style-type:disc">추가적으로 뭔가를 해주면 당연히 성능은 저하</li></ul><ul id="456bb40d-c0d7-4b49-a13e-ce362b86f174" class="bulleted-list"><li style="list-style-type:disc">&#x27;strcpy()`의 순수한 속도가 필요하다면 C11의 함수를 못 쓸 수도</li></ul><ul id="fb02707c-3304-4ae0-bce8-de797d616614" class="bulleted-list"><li style="list-style-type:disc">C 프로그래밍할 때는 널 포인터 관리를 어차피 잘 해야함<ul id="a1a33605-182e-45a6-993e-671065188c36" class="bulleted-list"><li style="list-style-type:circle">함수 몇개 고친다고 해결될 일이 아님</li></ul><ul id="234f0c0d-94bb-4a35-b848-b03aacd5f369" class="bulleted-list"><li style="list-style-type:circle">그렇다고 모든 함수 안에서 이런 검사를 해줄 수는 없음</li></ul></li></ul><ul id="373e3cc0-93d6-4af0-aaee-93d3266ffea8" class="bulleted-list"><li style="list-style-type:disc">프로그래머가 할 일을 함수가 전부 다 해줄 필요는 없음</li></ul><h3 id="24abf8fc-e002-44ce-a200-13621a28390c" class="">C99의 방향성과 상반됨</h3><ul id="46d6d267-250f-4f90-b006-540f80bdcbea" class="bulleted-list"><li style="list-style-type:disc"><code>restrict</code> 키워드<ul id="07487066-88ac-40f6-a1af-fc81c12cfa6f" class="bulleted-list"><li style="list-style-type:circle">C99</li></ul><ul id="d3bbc184-557b-41db-a6f8-69e48aa59a4a" class="bulleted-list"><li style="list-style-type:circle">메모리 접근에 대한 안전장치를 해제하라고 알려주는 힌트</li></ul><ul id="2c300746-2a35-4387-a7db-fcc7b1d9d7e6" class="bulleted-list"><li style="list-style-type:circle">컴파일러는 안전한 메모리 접근을 위한 어셈블리 코드를 생략할 수 있음</li></ul><ul id="79486fc6-aa0d-47f1-8736-40ee50ca1ace" class="bulleted-list"><li style="list-style-type:circle">속도 상승, 그러나 호출자가 실수하면 결과를 예측할 수 없음</li></ul></li></ul><ul id="ba52ed8f-17df-4662-943e-d05dcfa4d852" class="bulleted-list"><li style="list-style-type:disc"><code>xxx_s()</code> 함수<ul id="09d2e7bc-215c-43ef-9be1-02167d4fb4dc" class="bulleted-list"><li style="list-style-type:circle">C11</li></ul><ul id="8b076919-c56b-494c-9e10-2c8465c4be8c" class="bulleted-list"><li style="list-style-type:circle">여러 안전장치를 붙인 메모리 접근 함수들을 제공</li></ul><ul id="d17ff6f9-96c7-4192-8e54-8cf22e56b02e" class="bulleted-list"><li style="list-style-type:circle">속도 저하</li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d4bdd5e5-4d28-413f-94a3-45ef58ee4a06"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>성능, 속도, 메모리가 확실히 보이는 것 자체가 C 언어의 존재 의미!</strong></div></figure><h2 id="26863602-72ff-4496-83b7-f5ff30e6db19" class="">Type-Generic 함수 만들기</h2><h3 id="5092ba92-deff-489c-bdd4-b299eb79d010" class="">&lt;tgmath.h&gt;와 제네릭 선택</h3><ul id="f934cb81-1fd3-4de0-9beb-2d76c191d3a2" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;tgmath.h&gt;</code><ul id="2f7cfb8b-e469-4cfd-a5b8-f8ba15325d90" class="bulleted-list"><li style="list-style-type:circle">매개변수 형에 알맞는 수학 함수를 찾아서 호출해주는 매크로 함수</li></ul><ul id="b2b094e1-c67e-419b-a72f-7a8dff34f3d5" class="bulleted-list"><li style="list-style-type:circle">컴파일러가 알아서 구현해준 것</li></ul></li></ul><ul id="2e606247-2160-4095-baea-afd7b4af5dab" class="bulleted-list"><li style="list-style-type:disc">프로그래머가 이런 매크로를 직접 만들 방법이 없었음</li></ul><ul id="57113b86-2082-4b8e-9162-57888530047b" class="bulleted-list"><li style="list-style-type:disc">C11에서는 가능<ul id="7ff6f96e-b022-4da3-86ba-5b7f7315a114" class="bulleted-list"><li style="list-style-type:circle">제네릭 선택(generic selection)이라 부름</li></ul><ul id="201104b7-0a9c-4db7-9b55-a659ddda8c6b" class="bulleted-list"><li style="list-style-type:circle"><code>_Generic</code> 키워드 사용</li></ul><ul id="69c06161-9d21-45da-8d29-0ff5824b7a19" class="bulleted-list"><li style="list-style-type:circle">이제 <code>&lt;tgmath.h&gt;</code>도 이 키워드를 사용해서 직접 구현 가능</li></ul></li></ul><h3 id="dbea0692-e7ae-41e0-8067-b6cb78b3e999" class="">_Generic 키워드</h3><pre id="9bd2c866-2398-45b6-b817-c061df9bb60c" class="code"><code>_Generic(&lt;제어 표현식&gt;, &lt;연관 목록&gt;)</code></pre><ul id="08ac7ce5-3d86-4406-af58-92bfa255341a" class="bulleted-list"><li style="list-style-type:disc"><strong>컴파일 도중</strong>에 여러 가지 표현식 중 하나를 선택하는 방법<ul id="00814574-7749-44a4-a9ec-da6147bdce43" class="bulleted-list"><li style="list-style-type:circle">실행 중에 선택하는 게 아님</li></ul></li></ul><ul id="fe4577e5-4cb2-4df7-89fc-428c9bb8e998" class="bulleted-list"><li style="list-style-type:disc">매크로 함수의 대체 목록으로 사용하는 게 일반적</li></ul><ul id="c6da9860-4af9-46ac-b4c0-7735704e8c26" class="bulleted-list"><li style="list-style-type:disc">흡사 switch문과 비슷해 보임</li></ul><h3 id="b7841322-ceb8-4e06-b22d-13fe09c8f368" class="">_Generic으로 ceil() 함수를 구현한 예</h3><pre id="25e6d9bd-ba76-43fb-981b-ff8bc76ee4c2" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define ceil(X) _Generic((X),           \
							long double: ceill,       \
									default: ceil,        \
										float: ceilf)(X)
// X의 type에 따라 ceilll, ceil, ceilf로 바꿔달라는 것을 의미함

int main(void)
{
	float num1 = 3.1415;
	double num2 = 697429.8748;

	printf(&quot;ceil(%f) = %f\n&quot;, num1, ceil(num1)); // ceil &gt; ceilf
	printf(&quot;ceil(%f) = %f\n&quot;, num2, ceil(num2)); // ceil &gt; ceill
}</code></pre><pre id="0cd502e7-daba-45b6-a168-72e996948c5d" class="code"><code>ceil(3.141500) = 4.000000
ceil(697429.874800) = 697430.000000
_</code></pre><h3 id="6efe2500-bc69-44b0-b2d0-4d10617bcf57" class="">연관 목록</h3><ul id="38f3740a-e0d2-457e-a886-c8b6c4ee6aa5" class="bulleted-list"><li style="list-style-type:disc">연관 목록의 각 항목은 다음의 형태를 가짐<pre id="a7230d8d-7f89-4de3-bde9-2bc0a6683bce" class="code"><code>&lt;자료형&gt;: &lt;호출할 함수 이름&gt;   // 여러 개 사용 가능
default: &lt;호출할 함수 이름&gt;    // 딱 하나만 혹은 생략 가능</code></pre></li></ul><ul id="cb65c29e-d35b-4058-acaf-5178b75a9670" class="bulleted-list"><li style="list-style-type:disc">대체 규칙<p id="614f2de5-7182-4492-af20-ca6c516e345c" class="">1) 연관 목록에 그 형이 있다면 그에 대응하는 표현식으로 대체</p><p id="bb207b93-3591-442f-a71c-cf7b6f97c7f3" class="">2) 연관 목록에 형이 없고 <code>default:</code>가 있다면 그에 대응하는 표현식으로 대체</p><p id="c0dce323-9e16-4922-9fac-66c90cb5c40e" class="">3) <code>default:</code>도 없다면 컴파일 되지 않음</p></li></ul><h2 id="5946d470-10b4-45ea-9e24-37f1c9a36550" class="">정적 어서트</h2><p id="2aa07965-d6cc-41cf-88bc-0d72891c53d6" class="">⇒ 동적 어서트 : 실행 중에 도는 어서트</p><p id="731303a8-9cb8-4c3c-8fd9-63c30ce79c54" class="">⇒ 정적 어서트 : 실행 중의 반대</p><h3 id="d026be6e-4eb8-46ee-a3a4-fb5d6fd21c2a" class="">어서트는 프로그래머의 베스트 프렌드</h3><ul id="e90a39d9-2a07-4970-8c52-ab328882b4ae" class="bulleted-list"><li style="list-style-type:disc">코드 작성 시 프로그래머가 세운 가정 또는 선 조건이 올바른지 검사</li></ul><ul id="c55a6970-8f55-403b-bf8e-ea9335b36e0d" class="bulleted-list"><li style="list-style-type:disc">개발 중에 실수를 일찍 발견할 수 있게 도와줌</li></ul><ul id="819f0d24-fcbc-437e-b287-5523da814fb0" class="bulleted-list"><li style="list-style-type:disc">예 : 구조체의 크기 보장하기<pre id="83a7bce5-aa3b-4555-ac26-44aa0875acc4" class="code"><code>typedef struct statuc {
	unsigned int level;
	unsigned int exp;
} status_t;</code></pre><pre id="a3cd798f-f180-4d54-9be4-9399db2bc995" class="code"><code>assert(sizeof(status_t) == 8);
assert(sizeof(int) == 4);
// 코드 생략</code></pre></li></ul><h3 id="e1fa375a-502e-428a-96fe-212d9b54ddf0" class="">어서트의 한계</h3><pre id="f5d10473-929b-4ea5-b934-5641a26aa026" class="code"><code>typedef struct statuc {
	unsigned int level;
	unsigned int exp;
} status_t;</code></pre><pre id="1edea0dd-9632-48c6-974b-cf6e6f318eaa" class="code"><code>void display_status_bar(user_id_t id_
{
	status_t level_info = { 0, };

	// 플레이어의 경험치를 UI에 보여줌
}</code></pre><ul id="fa4dc1d7-10e7-473d-9009-c9441da5f2bd" class="bulleted-list"><li style="list-style-type:disc">위와 같이 C로 만든 게임을 새로은 콘솔 게임으로 이식하기 위해 새로운 콘솔에 맞게 컴파일을 진행</li></ul><ul id="f9c65965-3630-4291-96ed-a98bb2127b59" class="bulleted-list"><li style="list-style-type:disc">성공적으로 컴파일이 진행되었음</li></ul><ul id="f1f08a30-473c-4ced-af16-225db3c81442" class="bulleted-list"><li style="list-style-type:disc">하지만 특정 레벨에서 UI가 이상하게 나오거나 크래시가 나는 경우가 생길 수 있음<p id="96d1e946-d967-46e7-a213-124efeae64d5" class="">⇒ 알고보니 그 콘솔 게임기는 <code>int</code>가 4바이트가 아니라 2바이트</p></li></ul><hr id="54e8ae85-e765-435e-904b-a08146a87c08"/><p id="b122485c-efc4-42e1-aca2-bf16ac788818" class=""><strong>Q) 이 문제를 해결할 수 있는 가장 좋은 방법은 무엇일까?</strong></p><p id="c7e3f3a6-02b6-4d6e-8a67-215b08934375" class=""><strong>A)</strong> 컴파일이 아예 되지 않도록 하는 것이 최선임</p><hr id="1d926700-07fc-463a-9379-0f3071c3724c"/><ul id="ba47aa76-4c84-4dd3-8f72-ca25321e35a1" class="bulleted-list"><li style="list-style-type:disc">어떤 가정(예 : <code>int</code> 크기는 4)이 깨질 경우 아예 컴파일이 되지 않으면 됨</li></ul><ul id="8a1cf6fc-9d47-4f17-a8c8-fa3054cf6e03" class="bulleted-list"><li style="list-style-type:disc">그러려면 어서트의 조건을 컴파일 중에 평겨할 수 있어야함</li></ul><ul id="78c0cbf9-4eaf-4c9b-a41e-847e3fec31a3" class="bulleted-list"><li style="list-style-type:disc">하지만 실행 중에만 판단 가능한 조건들은 이런 것이 불가능<pre id="7d572985-8b7e-4a41-86e1-1317f9693f9a" class="code"><code>float divide(float op1, float op2)
{
	assert(op2 != 0.0f);
	return op1 / op2;
}</code></pre><pre id="a1a35f0e-bae1-4f83-b02c-41e72aa313eb" class="code"><code>f = float op1 = 10.4f;
float op2 = 0.0f;

printf(&quot;%f / %f = %f\n&quot;, op1, op2, divide(op1, op2));</code></pre><p id="b5b098c0-9854-45e4-9daa-77faf4fbca7d" class="">⇒ 실행 중에 판단이 가능한 <code>assert()</code></p></li></ul><ul id="b87c0bde-1c49-4faa-959b-103e7fd30657" class="bulleted-list"><li style="list-style-type:disc">컴파일 중에 판단 간으한 조건들도 충분히 많음<ul id="d350d37b-a2fb-43eb-a7cb-d605a0ddef07" class="bulleted-list"><li style="list-style-type:circle">구조체 및 기본형의 크기가 그 좋은 예</li></ul><ul id="4e84289e-3d9f-49e5-bd9c-2b121e98b362" class="bulleted-list"><li style="list-style-type:circle">이들은 이미 컴파일 중에 결정되는 사항</li></ul></li></ul><ul id="9b84c045-7e28-4cd4-ad37-0677a87fec4f" class="bulleted-list"><li style="list-style-type:disc">이런 조건이 충족 안 할 때 컴파일을 막아주는 것이 <strong>정적 어서트</strong></li></ul><h3 id="44885ecb-72b8-4ee7-aafa-b813c10a91fd" class="">정적 어서트</h3><pre id="3aa61881-18a6-4fa7-939c-b5b7474e38fe" class="code"><code>_Static_assert(&lt;표현식&gt;, &lt;메세지&gt;)</code></pre><ul id="455a6a96-3c04-46b4-b5b9-f99b31aa52ff" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;assert.h&gt;</code>를 인클루드하면 <code>static_assert</code>가 정의되어 있음<pre id="b4fa4dd4-63f0-47ed-820c-3268db9c51bc" class="code"><code>#define static_assert _Static_assert</code></pre></li></ul><pre id="4f9dab4d-3cf7-43f5-86c7-9438019928c2" class="code"><code>_Static_assert(sizeof(status_t) == 8, &quot;status_t size mismatch&quot;);
// 혹은
static_assert(sizeof(status_t) ==8, &quot;status_t size mismatich&quot;);</code></pre><ul id="99c262d3-707c-45be-ba4d-3d378392cb0d" class="bulleted-list"><li style="list-style-type:disc">&lt;표현식&gt;이 0으로 평가되면 컴파일 오류</li></ul><ul id="72e6f8be-f279-4448-a213-13aacabd05ca" class="bulleted-list"><li style="list-style-type:disc">무슨 문제인지 설명해주는 메시지도 &#x27;&lt;메세지&gt;&#x27;에 넣을 수 있음<ul id="1630b590-87ff-4706-bfd6-d3014568e9e1" class="bulleted-list"><li style="list-style-type:circle">컴파일 실패 시 코드에서 한눈에 보이니 좋음 (자체 문서화)</li></ul></li></ul><ul id="96d8ef4b-18c9-4daa-a7f5-3c80c6159c0c" class="bulleted-list"><li style="list-style-type:disc">정적 어서트의 경우 메시지를 넣지 않으면 안됨!</li></ul><ul id="708c0483-6972-4f6a-957f-bc49046ada68" class="bulleted-list"><li style="list-style-type:disc">추후 C 표준에서 어서트 조건만 받는 버전이 들어온다고 함</li></ul><h3 id="ad24879c-c0f2-431d-836d-698dff386f41" class="">베스트 프랙티스 : 어서트 vs 정적 어서트</h3><ul id="afc68da7-1331-4722-b3b1-206756d14fe7" class="bulleted-list"><li style="list-style-type:disc">컴파일 중에 평가될 수 있는 조건이라면 무조건 정적 어서트<ul id="38907de4-d8c3-4140-9e59-8d66d468f570" class="bulleted-list"><li style="list-style-type:circle">컴파일이 안되면 실행파일 자체가 안나옴</li></ul><ul id="9b23cca1-fa7d-4e26-82f0-de83cbaa8b47" class="bulleted-list"><li style="list-style-type:circle">따라서 프로그래머가 어떻게든 고침</li></ul><ul id="fad2b618-33bc-41bc-92d1-7f327dbf0265" class="bulleted-list"><li style="list-style-type:circle">단, C11에서만 사용 가능</li></ul></li></ul><ul id="ca035469-cbc9-47b1-9abf-95de11b81f55" class="bulleted-list"><li style="list-style-type:disc">그 외의 조건은 여전히 어서트를 사용할 것</li></ul><ul id="568f92e9-d4ae-4a5b-bea1-e152db08734a" class="bulleted-list"><li style="list-style-type:disc">C11을 지원하지 않는 컴파일러를 사용한다면<ul id="00627920-4395-43f2-ac6d-0920b45776f5" class="bulleted-list"><li style="list-style-type:circle"><code>static_assert</code>를 <code>assert</code>로 <code>#define</code> 할 것</li></ul><ul id="74521ba9-ea6b-472d-9c10-f86398f1a73e" class="bulleted-list"><li style="list-style-type:circle">C11에서 정적 어스트로 동작</li></ul><ul id="e1bbece2-42be-4a53-803e-463eb147b8f2" class="bulleted-list"><li style="list-style-type:circle">그 전 표준에서는 동적 어서트로 동작</li></ul></li></ul><h2 id="a91a2c75-269f-4a9b-9700-8cbf7f80d1a4" class="">_Noreturn 키워드</h2><pre id="b923c760-25c6-4e06-883a-1e5318b216e4" class="code"><code>_Noreturn &lt;반환형&gt; &lt;함수이름&gt;(&lt;매개 변수&gt;)</code></pre><ul id="df79aa35-4eab-4e06-a209-05669871746d" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdnoreturn.h&gt;</code>를 인클루드하면 <code>noreturn</code>을 대신 사용 가능<pre id="880c1526-8511-4a1a-a3bb-61123bef80cd" class="code"><code>noreturn void cross_the_river()
{
	// 코드 생략
}</code></pre></li></ul><hr id="3e3572fe-43c4-46a0-824d-ced8d77fa4e5"/><p id="a3d1f4c8-9717-4e82-876c-4c5222f8724f" class=""><strong>Q)</strong> <code><strong>void</strong></code><strong>도 이미 반환하지 않겠다는 의미가 아닌가?</strong></p><p id="f0e38637-0f1f-41b1-a534-6de1be2482f9" class=""><strong>A) </strong>No! <code>void</code>는 반환하는 값이 없다는 의미 → 여전히 함수에서 원래 호출자로 돌아오긴(return) 함</p><hr id="c0fb2a53-1dd9-45ac-885c-d08637d33c8e"/><ul id="82aea993-38df-4a7a-a05d-8c2536f3a5b2" class="bulleted-list"><li style="list-style-type:disc"><code>noreturn</code>은 그 함수에서 원래 호출자로 돌아가지 않겠다는 의미</li></ul><ul id="e15a7045-a8ee-4bae-a1dc-4390dfc6c962" class="bulleted-list"><li style="list-style-type:disc">무한 루프에 빠지는 함수!<ul id="5b6c8d49-f090-4f29-a2bc-9903de32d261" class="bulleted-list"><li style="list-style-type:circle">Why? 멀티스레딩을 할 때는 필요한 경우가 있음</li></ul></li></ul><ul id="0725b201-a72e-4d3f-a303-b242a971c5e3" class="bulleted-list"><li style="list-style-type:disc">또한 어떤 함수에서 프로그램을 종료시켜버리는 경우에도 이에 해당함</li></ul><h3 id="7c9a3e4f-5ec6-443e-af2c-887e0356d432" class="">표준 라이브러리의 _Noreturn 함수들</h3><ul id="bba69e14-dc4e-4561-ab74-85cbe9a052fb" class="bulleted-list"><li style="list-style-type:disc">다음의 표준 라이브러리 함수들은 절대 호출자로 돌아오지 않음<ul id="27644937-c3d0-44dc-8bf3-69a7a6626221" class="bulleted-list"><li style="list-style-type:circle"><code>abort()</code></li></ul><ul id="dab26a10-d809-49d3-b5a1-d33bf20892b2" class="bulleted-list"><li style="list-style-type:circle"><code>exit()</code></li></ul><ul id="3d781fbe-73b7-478e-9293-06f235f5861a" class="bulleted-list"><li style="list-style-type:circle"><code>_Exit()</code></li></ul><ul id="0ed44b17-c4d6-412e-8d0c-144a2e1dea52" class="bulleted-list"><li style="list-style-type:circle"><code>quick_exit()</code></li></ul><ul id="2ac63a6c-2f18-485c-92ac-08289a04352b" class="bulleted-list"><li style="list-style-type:circle"><code>thrd_exit()</code></li></ul><ul id="776fcf3f-7273-4456-923b-b32369acd23c" class="bulleted-list"><li style="list-style-type:circle"><code>longjmp()</code></li></ul></li></ul><ul id="ba339a2e-2939-4943-8244-5446dfa957e7" class="bulleted-list"><li style="list-style-type:disc">대부분 무언가를 종료하는 함수들</li></ul><hr id="5011391e-bc1a-4c6d-b557-fcb44273705c"/><p id="3e21879f-9b43-4cdf-958d-a8006c28b861" class=""><strong>Q) 굳이 왜 _Noreturn을 달...? 안해도 그만 아닌가?</strong></p><p id="d8f19a39-7d20-4520-bfc7-20be63b50a81" class=""><strong>A) </strong>컴파일러의 최적화!</p><p id="15948a72-d16b-43a4-969a-65b22ef463df" class="">⇒ <code>_Noreturn</code>이 달린 함수가 반환을 해버리면 정의되지 않은 결과가 나옴<div class="indented"><pre id="270f34b1-d624-4318-aaa1-6dfd7e8a1e43" class="code"><code>noreturn void exit_program(int error_code)
{
	if (error_code != 0) {
		exit(error_code(;
	}
}</code></pre></div></p><hr id="ab7a8cc1-fbb0-455a-bd3b-e13aaaf56a56"/><h3 id="2fde13c3-d494-4c8f-80dc-6a580e44f83c" class="">베스트 프랙티스 : 별로 안씀!</h3><ul id="7de31733-0adf-4879-8eaf-73be02bb9054" class="bulleted-list"><li style="list-style-type:disc">어차피 이런 함수는 많지 않음</li></ul><ul id="c798a00a-17da-48f3-87f2-b78d78519135" class="bulleted-list"><li style="list-style-type:disc">따라서 noreturn을 쓸 곳이 별로 없을 것임<ul id="4ee7fc00-821e-43b1-8c4a-153e78a06961" class="bulleted-list"><li style="list-style-type:circle">그래서 최적화 떄문에 noreturn을 붙인다는 것도 좀 오버</li></ul></li></ul><ul id="a55e1ed5-2fe3-4e9c-b175-414a31eefac1" class="bulleted-list"><li style="list-style-type:disc">그 대신 자체 문서화로서의 역할이 더 강하다고 볼 수 있음<ul id="ce6d0e4f-e8dd-4d82-a6ae-017775819a87" class="bulleted-list"><li style="list-style-type:circle">프로그래머가 함수 시그니처를 딱 보는 순간 판단할 수 있음</li></ul><ul id="86723068-8ea6-4e26-9b19-35d97ac72230" class="bulleted-list"><li style="list-style-type:circle">&quot;이 함수는 절대 반환되지 않는구나! 잘못 호출해서 프로그램이 종료되거나 무한 반복에 빠지는 일이 없아야겠군!&quot;</li></ul></li></ul><ul id="a3a16541-c7a7-4729-92bf-9d4e563ab1fa" class="bulleted-list"><li style="list-style-type:disc"><code>noreturn</code>은 돌아오지 못하는 강.. 건너갔으면 돌아오지 말자!</li></ul><h2 id="cd35bc87-62de-444a-a38e-d855cd832ea7" class="">메모리 정렬</h2><h3 id="03f48d6d-9af6-44ef-8241-3e481c721ae3" class="">일반적으로 메모리 할당시 주소는 4의 배수로 이루어짐</h3><ul id="49c1c98a-4c44-4bfc-a334-d42961c63279" class="bulleted-list"><li style="list-style-type:disc">표준은 이런 걸 정하지 않음</li></ul><ul id="8d775a4d-ffba-47c8-b7b1-f007774246d5" class="bulleted-list"><li style="list-style-type:disc">데스크탑에서 실행하면 이런 패턴을 볼 수 있을 뿐</li></ul><ul id="049a5f96-4551-4303-879a-8c441e9ff07d" class="bulleted-list"><li style="list-style-type:disc">이유?<ul id="98f6c356-bcde-4c04-826a-afb76dbf0b0e" class="bulleted-list"><li style="list-style-type:circle">32비트에서는 4바이트 단위로 메모리를 접근하는 게 성능상 유리</li></ul><ul id="b913584a-7b58-4dd4-b8f3-371b2856bf96" class="bulleted-list"><li style="list-style-type:circle">구조체에서 컴파일러가 알아서 패딩을 붙이는 이유와도 비슷</li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="7cfa2075-d9d4-4b1f-8cb2-02d98e25e389"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">이렇게 시작 주소가 4의 배수로 나눠 떨어지는 메모리를 <strong>4바이트로 정렬된(aligned) 메모리</strong>라고 함</div></figure><h3 id="96c853b5-95be-4f90-b16f-a7495fa535ee" class="">프로그래머가 직접 메모리를 정렬할 일이 있을까</h3><ul id="6f2885c7-7506-47ef-b022-a38e3a0003bf" class="bulleted-list"><li style="list-style-type:disc">하드웨어에 따라 직접 지정해줘야 하는 경우가 있음<p id="af4887cb-1f06-4cef-8531-54334574c602" class="">1) 특정 바이트로 정렬을 하면 성능이 향상되는 경우</p><ul id="d12d82b1-019e-43f1-8305-3027a387a53e" class="bulleted-list"><li style="list-style-type:circle">정렬을 안해도 여전히 동작은 함</li></ul><ul id="52ffab7a-3620-413e-8537-30ca04e2b969" class="bulleted-list"><li style="list-style-type:circle">속도가 느려질 뿐</li></ul><p id="a7ddf360-4502-4733-954d-5c79eb43dcd4" class="">2) 정렬을 하지 않으면 아예 동작하지 않는 경우</p><ul id="53039d80-454a-4444-9d72-0471b42268f3" class="bulleted-list"><li style="list-style-type:circle">정렬되지 않은 메모리를 하드웨어가 처리할 수 없는 경우가 이에 해당<ul id="17a17daf-a198-41dd-a5df-33847f396b0e" class="bulleted-list"><li style="list-style-type:square">예 : 그래필 카드</li></ul></li></ul><ul id="430d5221-19a7-44df-ad5e-0b3a269c0179" class="bulleted-list"><li style="list-style-type:circle">이 경우는 프로그램 실행 중에 크래시가 나는 경우가 대부분</li></ul></li></ul><h3 id="bea545d4-bc53-4901-80a1-0674d15d7c2f" class="">aligned_alloc()</h3><p id="c21fe49f-1418-4e86-b449-2a126f85ffa4" class="">⇒ 프로그래머가 직접 메모리를 정렬을 해야하는 경우에 사용하는 함수의 등장</p><pre id="fc234494-4221-4847-812a-07b205a0e7d2" class="code"><code>void* aligned_alloc(size_t alignmnet, size_t size);</code></pre><ul id="2495a224-3860-44c9-be3d-865f59a122b4" class="bulleted-list"><li style="list-style-type:disc"><code>alignment</code> : 메모리 시작 주소가 정렬되야하는 바이트</li></ul><ul id="0105d70d-f3f1-4f21-bedb-18e90e65ff9f" class="bulleted-list"><li style="list-style-type:disc"><code>size</code> : 할당할 바이트의 크기 → <strong>반드시 </strong><strong><code>alignment</code></strong><strong>의 배수여야 함</strong></li></ul><ul id="d963d274-f935-49ce-9f7b-e4d6b1b7efae" class="bulleted-list"><li style="list-style-type:disc">반환값<ul id="fd417bba-231b-4e17-93b7-dd507705996d" class="bulleted-list"><li style="list-style-type:circle">성공 시 : 할당된 메모리 주소</li></ul><ul id="776053ee-f215-45a2-9071-1a3d6c36189b" class="bulleted-list"><li style="list-style-type:circle">실패 시 :널 포인터</li></ul></li></ul><ul id="a9b1476d-63b2-444f-920e-c4acc3cade01" class="bulleted-list"><li style="list-style-type:disc">실패 조건<p id="433324b6-92c4-4e40-858d-133e18b73d74" class="">1) <code>alignment</code>가 구현에서 유효하지 않거나 지원하지 않는 크기일 때</p><p id="9aefcdf1-6738-4fbd-83ba-ffebdb20a0b2" class="">2) <code>size</code>가 <code>alignmnet</code>의 배수가 아닐 때</p><ul id="f22addeb-4337-44e7-8781-fd3cdc716196" class="bulleted-list"><li style="list-style-type:circle">단, 첫 C11 버전에서는 널 포인터 반환이 아님 (결과가 정의되지 않음)</li></ul><ul id="21c9278c-e916-46e5-8180-07d39b290670" class="bulleted-list"><li style="list-style-type:circle">수정 버전(DR 460)부터 널 포인터 반환</li></ul></li></ul><h3 id="c0f533d1-d093-4aa7-b8a8-e055a1dea6cd" class="">aligned_alloc()의 예 (1)</h3><pre id="99bfe743-2aa7-48d0-9f07-aa29745e63c9" class="code"><code>// 첫 C11 버전: 결과가 정의되지 ㅇ낳음, C11 수정버전: 널포인터
int* p1 = aligned_alloc(4096, sizeof(int));
print(&quot;p1: %p\n&quot;, (void*)p1);

// 단, 하나의 정수형을 할당하더라도 정렬 크기(4096)의 배수를 유지해야 함
int* p2 = aligned_alloc(4096, 4096 * sizeof(int));
printf(&quot;p2: %p\n&quot;, (void*)p2);

free(p2);
free(p1);</code></pre><pre id="acf1cd48-3c94-4968-9d0e-9a4ad1baf613" class="code"><code>p2: 0x1dc6000</code></pre><ul id="e4479d59-3aa5-4726-8f53-22504e58bd30" class="bulleted-list"><li style="list-style-type:disc">4096은 16진수로 0x1000<ul id="27775ce5-3857-42fe-b769-c11bf5b2f594" class="bulleted-list"><li style="list-style-type:circle">따라서, 주소의 마지막 세자리는 언제나 000!</li></ul></li></ul><h3 id="7a0fd4e5-10ca-433d-8b96-c77f4a8b404c" class="">aligned_alloc()의 예 (2)</h3><pre id="8682b2ee-a16a-4614-a8cc-8ab85cf1832c" class="code"><code>size_t align_up(const size_t alignment, const size_t size)
{
	return (size + alignment - 1) / alignment * alignment;
}</code></pre><pre id="b7ef9987-6bd5-4e5f-9f0d-e26cff0c6c94" class="code"><code>const size_t num_bytes = align_up(4096, sizeof(int));

int* p = aligned_alloc(4096, num_bytes);
printf(&quot;p: ox%p\n&quot;, (void*)p);

free(p)</code></pre><pre id="371c7d41-2726-41b5-985f-9f32bd8aa66a" class="code"><code>p: 0x0xa90000</code></pre><h3 id="c7bc62c3-8184-4acd-b8fe-65576505f4e6" class="">_Alignas를 통한 스택 메모리 정렬</h3><pre id="9aff136d-9c38-48c1-b2ef-9cae5d948c10" class="code"><code>_Alignas(&lt;v표현식&gt;)</code></pre><ul id="911bc56b-3b6e-475d-81ac-4f56a389f06f" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdalign.h&gt;</code>를 인클루드하면 <code>alignas</code>로 사용할 수 있음</li></ul><pre id="3472dcfa-ad9c-4754-8995-29b0bff0fb78" class="code"><code>int num1;
alignas(4096) int num2;
int num3;

printf(&quot;num1: %p\n&quot;, (void*)&amp;num1);
printf(&quot;num2: %p\n&quot;, (void*)&amp;num2);
printf(&quot;num3: %p\n&quot;, (void*)&amp;num3);</code></pre><pre id="2c278a89-3151-4b6a-bb19-9161668a3067" class="code"><code>num1: 003AEFF0
num2: 003AE000
num3: 003ADFFC</code></pre><h2 id="7ce39da3-59b9-44f8-a0a1-be2cd59db9b1" class="">구조체 정렬</h2><ul id="badba2be-79d6-4b50-b942-af6a804c25ed" class="bulleted-list"><li style="list-style-type:disc">두 가지 방법이 있음<ul id="fa69c771-db34-4653-8e78-00321416138b" class="bulleted-list"><li style="list-style-type:circle">각 멤버를 따로 정렬</li></ul><ul id="9754b1c3-0287-42f3-97e5-cc516f52669a" class="bulleted-list"><li style="list-style-type:circle">모든 멤버를 일괄적으로 같은 크기로 정렬</li></ul></li></ul><ul id="77ee2ece-cdf2-4c0a-9c16-ff087a76f93f" class="bulleted-list"><li style="list-style-type:disc">구조체 변수를 선언할 때, 그 변수의 시작 주소도 정렬 가능</li></ul><h3 id="0ef836f3-cc4f-4028-96f6-fd9dcf20fb07" class=""><strong>구조체 정렬의 예 - 멤버 변수 별 정렬</strong></h3><pre id="1e64bf0f-783f-4e7f-8b02-b3cc53c37b31" class="code"><code>typedef struct data {
	alignas(4096) int num;
	alisgnas(1024) int dummy[10];
} data_t;</code></pre><pre id="6994a064-b1fe-4859-9051-851bb6397810" class="code"><code>data_t data = { 0, };

printf(&quot;data size: %d, alignof: %d\n&quot;, sizeof(data), _Alignof(data));
printf(&quot;data.num: %p\n&quot;, (void*)&amp;data.num);
printf(&quot;data.dummy: %p\n&quot;, (void*)&amp;data.dummy);</code></pre><pre id="dd8f60c8-c44a-4d53-a04b-7c705fa336d2" class="code"><code>data size: 4096, alignof: 4096
data.num: 0x7ffef60d4000
data.dummy: 0x7ffef60d4400</code></pre><h3 id="c7fc505f-0399-47a7-93c0-fbae969a13bd" class="">구조체 정렬의 예 - 모든 멤버 변수 동일 정렬</h3><p id="4bd8960a-d1c1-4f7e-bd48-f1d6216b339c" class="">
</p><pre id="e56de238-7e74-4918-9ea7-9442188f22ae" class="code"><code>typedef struct data {
	alignas(4096) int num;
	alisgnas(1024) int dummy[10];
} data_t;

typedef struct aligned_data {
	int num;
	alignas(4096) int dummy[10];
} aligned_data_t;</code></pre><pre id="8d5d43f4-681d-49a7-8dba-da0d80c30add" class="code"><code>data_t data = { 0, };
printf(&quot;data size: %d, alignof: %d\n&quot;, sizeof(data), _Alignof(data));

aligned_data_t aligned_data = { 0, };
printf(&quot;aligned_data size: %d, alignof: %d\n&quot;, sizeof(aligned_data), _Alignof(aligned_data));

printf(&quot;aligned_data.num: %p\n&quot;, s(void*)&amp;aligned_data.num);
printf(&quot;aligned_data.dummy: %p\n&quot;, s(void*)&amp;aligned_data.dummy);
</code></pre><pre id="bbbc57f5-65f6-4a2e-8d98-9a2adaaf6fb4" class="code"><code>data size: 44, alignof: 4
aligned_data size: 8192, alignof: 4096
aligned_data_num: 0x7ffd7393a000
aligned_data.dummy: 0x7ffd7393b000</code></pre><h3 id="0f7308c5-8eb1-4031-8150-083b9161113b" class="">구조체 변수 선언 시 메모리 정렬</h3><pre id="da4c5d8e-171b-4716-89e5-4081688e5cae" class="code"><code>typedef struct data {
	int num;
	int dummy[10];
} data_t;</code></pre><pre id="a9c7d590-9639-4ea5-9fa7-2e10cb0e5063" class="code"><code>alignas(4096) data_t data;

printf(&quot;data size: %d, alignof: %d\n&quot;, sizeof(data), _Alignof(data));
printf(&quot;data: %p\n&quot;, (void*)&amp;data);</code></pre><pre id="5f6ea8b7-2c24-4882-86bd-1dbe0013f803" class="code"><code>data size: 44, alignof: 4096
data: 0x7ffc797ff000</code></pre><h3 id="d71a1a05-6bab-4504-99ed-d0d8d8884f91" class="">동적 할당을 할 경우엔 주의하자</h3><ul id="198ba9aa-9a92-4502-b9df-02d95a017c23" class="bulleted-list"><li style="list-style-type:disc"><code>malloc()</code> 함수는 구조체용 메모리를 할당한다는 사실을 모름<ul id="cca9ac80-9e61-436e-9cd5-98b4f419dc3b" class="bulleted-list"><li style="list-style-type:circle">따라서 구조체 멤버변수의 정렬에 맞게 메모리 할당이 안 됨</li></ul></li></ul><ul id="971f144f-3e4d-4b56-adb9-b8fcf3a8d5e8" class="bulleted-list"><li style="list-style-type:disc">그 대신 <code>aligned_alloc()</code>을 사용해야 함<ul id="0a9a3e9b-01ff-4beb-a5c8-ee7127e4a521" class="bulleted-list"><li style="list-style-type:circle">메모리 크기도 반드시 배수가 되야 한다는 점 잊지 말것</li></ul><ul id="b1166c56-1189-4eb8-aa68-4b3a32ad6d11" class="bulleted-list"><li style="list-style-type:circle">아까 봤던 <code>aligned_up()</code> 함수 같은걸 만들어서 쓸 것</li></ul></li></ul><pre id="be11f4d5-209b-48f7-92e6-9d5a7ca99d8e" class="code"><code>typedef struct data {
	int num;
	alignas(4096) int dummy[10];
} data_t;</code></pre><pre id="ef5a2fe4-101b-4f46-bb06-1f750a3afef1" class="code"><code>const size_t alignment = _Alignof(data_t);
const size_t size = align_up(alignment, sizeof(data_t));

data_t* p = aligned_alloc(alignmnet, size);

printf(&quot;data: %p\n&quot;, (void*)p);

free(p);</code></pre><pre id="d9fdd23d-0921-4562-8ecb-25c6e1d009a9" class="code"><code>data: 0xc71000</code></pre><h3 id="e4ff0bed-c34f-4489-b775-b2423c39555f" class="">변수가 몇 바이트 정렬인지 어떻게 알 수 있는가</h3><ul id="8b9af438-7823-4d41-a222-de91cb9b0953" class="bulleted-list"><li style="list-style-type:disc">가장 간단한 방법은 나머지 연산을 하는 것<pre id="1683e04f-60d7-40d1-84ec-811601f1df44" class="code"><code>bool is_aligned(const void* const p, const size_t align)
{
	return ((unsigned int)p % align) == 0;
}</code></pre></li></ul><h3 id="65be2459-bca3-4d77-b131-f359e093a64c" class="">_Alignof()</h3><p id="3185aa62-2be3-4a32-8d40-670faba68e9e" class="">⇒ <code>sizeof()</code>처럼 몇 바이트 정렬되어 있는지 알려주는 함수</p><pre id="04b5902d-2b1f-4024-9198-c440b4bf3850" class="code"><code>_Alignof(&lt;자료형&gt;)</code></pre><ul id="07b366ef-528e-4312-b0b8-c67c16ec064b" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdalign.h&gt;</code>를 인클루드 하면 <code>alignof()</code>로 사용 가능</li></ul><pre id="b904f737-24f2-48e2-9570-6113fb12212f" class="code"><code>int num1;
alignas(4096) int num2;
int num3;

printf(&quot;align of num1 = %d\n&quot;, _Alignof(num1));
printf(&quot;align of num2 = %d\n&quot;, _Alignof(num2));
printf(&quot;align of num3 = %d\n&quot;, _Alignof(num3));</code></pre><pre id="67e16ff4-5a51-4a20-bf62-ddbdbdef8c94" class="code"><code>align of num1 = 4
align of num2 = 4099
align of num3 = 4</code></pre><h2 id="1102f93f-b5b5-456d-b730-ac98b866226d" class="">멀티 스레딩</h2><ul id="46a3ff95-1621-4c58-9da3-876acd59bc8a" class="bulleted-list"><li style="list-style-type:disc">지금까지 작성한 프로그램은 일직선으로 실행이됨</li></ul><ul id="ee51a452-1826-44b5-8ba1-df2f060d52d4" class="bulleted-list"><li style="list-style-type:disc">한번에 한가지 일만 가능</li></ul><ul id="51065823-a096-4d88-98a1-249f35d5c9bd" class="bulleted-list"><li style="list-style-type:disc">하지만 동시에 여러가지 일을 하는 프로그램도 있음<ul id="1b75347d-ee7e-4d79-a7b8-037edb0b150c" class="bulleted-list"><li style="list-style-type:circle">TV의 경우 화면출력과 소리출력을 동시에 함</li></ul><ul id="b44446f6-9c90-4658-9f2a-7ed3eef8b3ca" class="bulleted-list"><li style="list-style-type:circle">웹브라우저에서 웹 서핑하면서 파일 다운로드하기</li></ul></li></ul><ul id="953ca94f-fe31-4784-8044-2bc0b768d590" class="bulleted-list"><li style="list-style-type:disc">전자는 싱글 스레드에서 실행되는 프로그램, 후자는 멀티 스레드에서 실행되는 프로그램이라고 함</li></ul><ul id="e3db01d7-bd17-4fbd-a409-e4927b1a5844" class="bulleted-list"><li style="list-style-type:disc">뿐만 아니라 성능 향상을 위해서 멀티스레딩을 하기도 함</li></ul><ul id="627a7ced-cb94-4483-b627-a5eea0e67d23" class="bulleted-list"><li style="list-style-type:disc">어떻게 성능 향상을 하는가<ul id="4ac79578-11d5-423c-824c-023a2751d139" class="bulleted-list"><li style="list-style-type:circle">최신 컴퓨터에는 여러 개의 코어(core)가 달려 있음<ul id="d55d152d-ee6b-4e7f-9865-89546149732a" class="bulleted-list"><li style="list-style-type:square">윈도우의 경우 &#x27;작업 관리자&#x27;에서 확인 가능</li></ul><ul id="fa4ff2f1-f1f4-4e1d-b5e4-64a91d065469" class="bulleted-list"><li style="list-style-type:square">CPU 사양(스펙)을 보도 코어가 몇 개인지 알 수 있음</li></ul></li></ul></li></ul><ul id="1df16599-a2b6-40fc-ac0b-b2cbd0eb1422" class="bulleted-list"><li style="list-style-type:disc">이제까지 작성한 프로그램은 기본적으로이 많은 코어 중 하나만 실행해줌</li></ul><ul id="ac160723-b416-40e0-9860-ed572ddd8356" class="bulleted-list"><li style="list-style-type:disc">이때 모든 코어를 사용한다면 성능을 향상시킬 수 있음</li></ul><ul id="9125267e-8da3-4164-a014-a6cb485d13f6" class="bulleted-list"><li style="list-style-type:disc">이론상 사용하는 코어 수만큼 향상</li></ul><hr id="730f8cfc-3124-4ff3-bd50-87a8c938ff50"/><p id="99a8a371-8a92-409b-9c04-c4f51562a8f6" class="">여기서는 C11에서 멀티 스레딩을 지원한다는 정도만 다룰 예정</p><ul id="fbe9994e-0155-4123-b690-299b54ce0255" class="bulleted-list"><li style="list-style-type:disc">선택적 구현 사항이기도 함</li></ul><ul id="72bfb0a1-8c3e-487d-bdca-1b0c0985ef1c" class="bulleted-list"><li style="list-style-type:disc">어떤 임베디드 기계는 멀티 스레딩 지원을 아예 안 할 수도 있으니..</li></ul><ul id="526e1390-3e5b-4b7d-8649-5b6ea2d0bc70" class="bulleted-list"><li style="list-style-type:disc">매크로를 통해 지원 여부 판단 가능</li></ul><p id="2b222e0e-1921-45bf-8a28-7b66be8b2336" class="">또한 어떤 키워드나 함수가 있는지 보고 넘어갈 예정</p><hr id="4dc0564c-10f0-47cd-85aa-03e8e0a44b21"/><h3 id="7ee057be-6c97-42a0-b6e9-dc8b8110ea04" class="">멀티 스레딩을 감독하는 운영체제</h3><p id="3e6ff3bc-a7fa-45d7-834e-3de40c4b7bc2" class=""><strong>Q) C11 이전에는 멀티 스레딩을 지원하지 않았는가?</strong></p><p id="8a0722f6-8149-49e1-b5bd-8c44e9288eed" class=""><strong>A)</strong> 언어 자체에서 지원하지 않았음 → 멀티 스레딩은 운영체제의 몫</p><ul id="6e460c3e-10ec-42a0-bc32-87d1b7829ae6" class="bulleted-list"><li style="list-style-type:disc">멀티 스레딩을 감독하는 건 운영체제임<ul id="6d39c3be-1f87-4c1d-bd8e-03391a64542c" class="bulleted-list"><li style="list-style-type:circle">여러 스레드가 프로그램을 나눠 실행하려면 감독이 있어야함</li></ul><ul id="c4d2db9e-31e0-4528-b846-c7b747d20eb2" class="bulleted-list"><li style="list-style-type:circle">그 감독 겸 지휘자가 운영체제임</li></ul></li></ul><ul id="4ad232b5-195b-4eaf-816c-fecfa8b70b6a" class="bulleted-list"><li style="list-style-type:disc">C11 이전의 멀티 스레딩은 OS 함수를 사용<ul id="615f572b-4319-46c6-b5dd-a15b1fc6150d" class="bulleted-list"><li style="list-style-type:circle">각 운영체제 별로 스레드를 관리하는 함수가 있엇음</li></ul><ul id="ad36fbe3-25b6-47a5-95cc-f9286eb5546d" class="bulleted-list"><li style="list-style-type:circle">C 프로그래머는 각 운영체제가 제공하는 함수들을 호출했을 뿐<ul id="975a199a-8a81-4ddd-8a41-1550730d6070" class="bulleted-list"><li style="list-style-type:square">즉, 이쩔 수 없이 포팅이 불가능한 코드를 작성</li></ul><ul id="45dba21c-7745-49b9-8410-1acfb5029e79" class="bulleted-list"><li style="list-style-type:square">플랫폼마다 <code>#ifdef</code>를 써서 처리했던 것이 일반적임</li></ul></li></ul><ul id="4b5c3a8f-16f7-45fc-b31d-40b171ba124d" class="bulleted-list"><li style="list-style-type:circle">그것을 합쳐서 C11 표준으로 만든게 전부<ul id="5678c110-67b9-405e-8168-9a4fbe11dd45" class="bulleted-list"><li style="list-style-type:square">따라서 이제 포팅이 가능한 코드 작성이 가능</li></ul></li></ul></li></ul><h3 id="d7ebe96d-4acf-4b90-a99b-eae848517199" class="">멀티 스레딩 프로그래밍의 문제점</h3><ul id="2af7fd15-d8b4-47fc-a181-2577cd69e4b7" class="bulleted-list"><li style="list-style-type:disc">여러 스레드가 동일한 메모리에 접근하는 것<ul id="3cdb1e62-f9e6-472d-a2e9-0ea8152962d1" class="bulleted-list"><li style="list-style-type:circle">해결법 : 어떤 스레드가 접근하는 동안 다른 스레드의 접근을 막음</li></ul><ul id="beecd0a9-0fd2-4b30-98bd-e30c31f2c002" class="bulleted-list"><li style="list-style-type:circle">이를 보통 락(lock)을 건다고 함</li></ul><ul id="6606e137-8917-4af0-a9d8-ebac9cafb2a6" class="bulleted-list"><li style="list-style-type:circle">이때 사용하는 대표적인 락의 종류가 바로 뮤텍스(<code>mutex</code>)</li></ul></li></ul><ul id="9c18ad87-3aac-487d-885a-db97f3fb89f9" class="bulleted-list"><li style="list-style-type:disc">그러나 락을 잠그고 여는 행위는 너무 느림<ul id="1b3a528d-c7ff-4241-b044-bf0e7d412bb5" class="bulleted-list"><li style="list-style-type:circle">따라서 많은 CPU는 락을 안 써도 되는 <code>atomic</code> 연산을 지원<ul id="cee760c8-2d30-46e3-86af-129a795118e7" class="bulleted-list"><li style="list-style-type:square">락을 안 써도 멀티 스레드 환경에 안전</li></ul><ul id="f2c63327-75c1-402c-8b2b-3bed6df983a4" class="bulleted-list"><li style="list-style-type:square">단, 기본 데이터형이어야만 함 (예: <code>int</code>)</li></ul><ul id="b171ec9f-4de6-46ab-8df6-f08dad8180df" class="bulleted-list"><li style="list-style-type:square">간단한 연산에 한함 (예: 변수값 1 증가하기)</li></ul></li></ul></li></ul><h3 id="3a1bbfad-34ba-4828-a996-31ee5903fe9e" class="">atomic</h3><ul id="ac0a041c-a036-468e-9705-2bb1f10f62ff" class="bulleted-list"><li style="list-style-type:disc">어떤 연산을 더 이상 쪼갤 수 없는 하나의 단위로 보는 것</li></ul><ul id="473858c4-ef20-4cdb-92a8-86b4b215d2e0" class="bulleted-list"><li style="list-style-type:disc">메모리에서 읽기(load) &gt; 데이터 갱신(update) &gt; 메모리에 저장(store) :  이걸 3단계로 보지 않고 이 자체를 <strong>&#x27;하나의 최소 단위&#x27;</strong>로 보겠다는 의미<ul id="4c0ee2d4-f937-4ea1-80f7-553f0fd26793" class="bulleted-list"><li style="list-style-type:circle">즉, 이 자체가 하나의 연산이 됨</li></ul></li></ul><ul id="a9665d5f-4e7a-48cf-bab4-4c72a5185318" class="bulleted-list"><li style="list-style-type:disc"><code>atomic</code> 연산 동안에는 다른 스레드가 개입할 여지가 없음<ul id="91239b58-b0ba-4e9b-b25f-baac7677615f" class="bulleted-list"><li style="list-style-type:circle">3단계 모델에서는 중간에 개입해서 서로 값을 덮어쓰는 경우가 생김</li></ul></li></ul><ul id="b67be5ec-27b3-42aa-9359-41cb24064b92" class="bulleted-list"><li style="list-style-type:disc">C11은 <code>atomic</code> 명령어들을 프로그래머에게 노출해줌<ul id="fbcf1171-1e78-4dc1-9626-4d3f3a8f5af0" class="bulleted-list"><li style="list-style-type:circle">변수선언 앞에 붙일 수 있는 <code>_Atomic</code> 키워드</li></ul><ul id="380adab3-1a6d-4dc6-a1dd-ff6211d616da" class="bulleted-list"><li style="list-style-type:circle"><code>atomic</code> 연산에 사용할 수 있는 함수들</li></ul></li></ul><pre id="73d3fdd0-1162-4205-b116-032249523efd" class="code"><code>_Atomic &lt;자료형&gt;</code></pre><ul id="d04dbffb-d73b-4a1e-960d-84d8f8ac6a67" class="bulleted-list"><li style="list-style-type:disc"><code>__STDC_NO_ATOMICS__</code>이 정의되어 있으면 지원 안함<ul id="7762fb1a-adfb-4493-ac59-002e50e7b9d4" class="bulleted-list"><li style="list-style-type:circle">뒤에서 볼 함수들도 마찬가지</li></ul></li></ul><ul id="78203ac1-71be-4ce3-9009-b099f1133c40" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdatomic.h&gt;</code>에 키워드랑 형을 미리 합쳐 정의해놓은 것도 있음<ul id="7d14aff4-a271-4b4b-b728-d9dfc1ae824c" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_bool</code>, <code>atomic_char</code>, <code>atomic_int</code>, <code>atomic long</code> 등등 총 37종</li></ul></li></ul><h3 id="5796d568-1bfe-4249-a5b6-073edc44d95f" class=""><strong>기본형 변수를 atomic으로 선언하기</strong></h3><ul id="a148f66b-9e3d-405f-9da2-8a8b120dbd46" class="bulleted-list"><li style="list-style-type:disc"><code>_Atomic</code> 키워드를 사용할 때<pre id="8a460423-ae2f-479f-9431-617f780baa36" class="code"><code>static _Atomic int s_num_threads;
static _Atomic _Bool s_existing;</code></pre></li></ul><ul id="01598c09-35be-49db-b1ac-5f96c176acf6" class="bulleted-list"><li style="list-style-type:disc">편의성 매크로를 사용할 때<pre id="728c7bc9-8c28-4439-b820-c00c5a581a19" class="code"><code>static atomic_int s_num_threads;
static stomic_bool s_existing;</code></pre></li></ul><ul id="ff3cfb0b-f377-453c-b83d-69d37920cc0e" class="bulleted-list"><li style="list-style-type:disc">이렇게 선언만 해놓으면 일반 변수 사용하듯이 사용하면 됨</li></ul><ul id="6dd2ad1b-79cd-4316-8183-ac9b83e60f68" class="bulleted-list"><li style="list-style-type:disc"><code>_Atomic</code>을 안 붙이면 <code>++</code>연산자를 사용하더라도 3단계로 동작 (예: <code>++i</code>)</li></ul><h3 id="2ca7404b-03ee-403b-a219-08b56ac6ceb3" class="">atomic 함수들</h3><ul id="eae6b533-af5d-40a4-b1ce-c3c0d7fc15ed" class="bulleted-list"><li style="list-style-type:disc">다음과 같은 함수들이 있음<ul id="0baa37d4-4d2c-47fd-9e61-bbaee6e76b69" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_init()</code></li></ul><ul id="08e2e21b-ebff-4a65-ac28-f8287be05035" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_flag_test_and_set()</code></li></ul><ul id="6715b2b7-c73e-4827-9cb4-5c3fa94822f2" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_load()</code></li></ul><ul id="ecb78e5b-15ab-4470-b660-545bfbc2cdc1" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_store()</code></li></ul><ul id="f60c3f26-f257-44d6-923b-4effb5b0f261" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_fetch_add()</code></li></ul><ul id="7ea1e979-f810-4dac-ad07-b9ce638b0ea4" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_fetch_sub()</code></li></ul><ul id="6e07b740-cfe0-4aac-acb2-bd3349cebe0a" class="bulleted-list"><li style="list-style-type:circle"><code>atomic_exchange()</code></li></ul><ul id="9d3b9913-b85f-443e-b68b-34f2f6b3587c" class="bulleted-list"><li style="list-style-type:circle">등</li></ul></li></ul><h3 id="0dbcbafd-b524-49e0-bed0-8ce10f3268b2" class="">CPU가 atomic을 지원 안 할 경우</h3><ul id="e4e9ee9e-a98f-4c5b-93e0-2ce644ddc8cf" class="bulleted-list"><li style="list-style-type:disc">여전히 <code>atomic</code> 키워드와 함수를 사용할 수도 있음<ul id="8efa5e9d-ea7b-485a-81e6-0a255dc03d8c" class="bulleted-list"><li style="list-style-type:circle"><code>__STDC_NO_ATOMICS__</code>이 정의되어 있지 않는 한</li></ul></li></ul><ul id="c5a69b86-3040-4af2-85d0-2afcd33d2f7b" class="bulleted-list"><li style="list-style-type:disc">C에서 내부적으로 락을 대신 사용할 수도 있음</li></ul><ul id="f7ca17e4-2c10-4c42-bc40-9ec613d30044" class="bulleted-list"><li style="list-style-type:disc">그건 다음 매크로들을 확인하면 됨<ul id="17e741ce-e4aa-4f10-b068-307c0b8a2a91" class="bulleted-list"><li style="list-style-type:circle"><code>ATOMIC_BOOL_LOCK_FREE</code></li></ul><ul id="48194c12-2b5e-43de-bf3c-a8fe83e300f8" class="bulleted-list"><li style="list-style-type:circle"><code>ATOMIC_CHAR_LOCK_FREE</code></li></ul><ul id="98072989-acdc-401d-8f94-542821751396" class="bulleted-list"><li style="list-style-type:circle">ATOMIC_INT_LOCK_FREE</li></ul><ul id="cdfa0949-295f-49f3-a56c-e838c2660d68" class="bulleted-list"><li style="list-style-type:circle">ATOMIC_LLONG_LOCK_FREE</li></ul><p id="1ede1578-d2c1-4ed5-bec5-064762f26da8" class="">⇒ <code>0</code>: 지원안함 / <code>1</code>: 지원하지만 가끔 atomic이 아님 / <code>2</code>: 언제나 atomic</p></li></ul><h3 id="42764468-c027-48d7-95e7-8440d87a16e6" class="">_Thread_local</h3><pre id="f93e8f71-6344-48d4-a6d0-8c6ce611d6b8" class="code"><code>_Thread_local &lt;자료형&gt;</code></pre><ul id="59eb7c21-3961-497e-ac0c-2d708e0c42b6" class="bulleted-list"><li style="list-style-type:disc"><code>__STDC_NO_TRHEADS__</code>이 정의되어 있으면 지원 안 함</li></ul><ul id="f5dd1185-8c18-4ba3-8be8-a71960bf1d8a" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;threads.h&gt;</code>를 인클루드하면 <code>thread_local</code>을 쓸 수 있음</li></ul><ul id="e78ceff9-bc21-443a-b1bf-34d8ae83058c" class="bulleted-list"><li style="list-style-type:disc">줄여서 흔히 TLS(thread local storage)라고 부름</li></ul><ul id="62840066-910d-4afb-95a0-09418297adb4" class="bulleted-list"><li style="list-style-type:disc"><code>atomic</code> 변수와 마찬가지로 자료형 앞에 붙이는 키워드</li></ul><ul id="669913cb-793e-4bd0-a18b-33a29f9f99a3" class="bulleted-list"><li style="list-style-type:disc">그러면 각 스레드마다 이 변수의 사본이 생기는 꼴<pre id="b4b17369-d620-4cf0-8ddb-701a875328f4" class="code"><code>static _Thread_local int s_num;
static thread_local int s_num;</code></pre></li></ul><h3 id="5e69570b-dbad-4cdd-b926-4d7a69c29263" class="">스레드 지원 라이브러리 : &lt;threads.h&gt;</h3><ul id="0e6574ee-46e0-447d-b677-fa4140cd13bc" class="bulleted-list"><li style="list-style-type:disc">스레드 관리용 함수 및 자료형을 제공</li></ul><ul id="72947058-4bed-48d6-b904-432212132330" class="bulleted-list"><li style="list-style-type:disc">선택적 구현 사항<ul id="8d899de2-344c-4a47-9bf4-7929fa25cfad" class="bulleted-list"><li style="list-style-type:circle">스레드 관련 코드를 작성할 때, <code>__STDC_NO_THREADS__</code>를 확인할 것</li></ul></li></ul><h3 id="8aeffd3c-ef30-4088-82d3-fdfaa4448547" class="">스레드 관련 함수들</h3><ul id="4bac6c5b-f34a-4ee4-ab48-f120f6dedea1" class="bulleted-list"><li style="list-style-type:disc"><code>thrd_create()</code> : 스레드 만들기</li></ul><ul id="ced3f980-8aa4-4281-a740-f6ba110851b7" class="bulleted-list"><li style="list-style-type:disc"><code>thrd_join()</code> : 스레드 실행이 끝나는 것을 기다리기</li></ul><ul id="2a7adfe6-f183-4469-b3bb-9b0b340e53fd" class="bulleted-list"><li style="list-style-type:disc"><code>thrd_yield()</code> / <code>thrd_sleep()</code> : 실행 순서 양보하기</li></ul><p id="9a0bfb4a-8769-4320-9067-8b7d60d46a45" class="">
</p><ul id="49ce276c-d73e-417c-aaa1-a2e9118d94a3" class="bulleted-list"><li style="list-style-type:disc">뮤텍스 조건 변수 이용하기<ul id="f9761886-48a5-4ada-b97a-6951e520c195" class="bulleted-list"><li style="list-style-type:circle"><code>mtx_init()</code> / <code>mtx_destroy()</code></li></ul><ul id="6d98732c-bf88-435f-8543-c04b5e3d59fd" class="bulleted-list"><li style="list-style-type:circle"><code>mtx_lock()</code> / <code>mtx_trylock()</code> / <code>mtx_unlock()</code></li></ul><ul id="c5f47f8f-99b3-4f2f-9276-6ab6a32dda88" class="bulleted-list"><li style="list-style-type:circle"><code>cnd_init()</code> / <code>cnd_destroy()</code></li></ul><ul id="94789b3a-e748-4fcd-9e4b-4f2e9640bbe2" class="bulleted-list"><li style="list-style-type:circle"><code>cnd_signal()</code> / <code>cnd_broadcast()</code> / <code>cnd_wait()</code></li></ul></li></ul><ul id="c60f9d96-1bfb-4381-bcb9-ec089602d7a4" class="bulleted-list"><li style="list-style-type:disc">등</li></ul><p id="8e2e6f61-c24b-4f9a-83a9-59fb577e0877" class="">
</p></div></article></body>

{% endblock post_content %}