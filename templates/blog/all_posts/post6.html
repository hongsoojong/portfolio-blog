{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">2진수의 음수 표현법</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 17, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="dbe9a485-be1d-471b-903b-885fb6f71dea" class="page sans"><div class="page-body"><ul id="47414278-db19-40cd-8786-941ec7fe9d40" class="bulleted-list"><li style="list-style-type:disc">프로그램을 개발하기 위해 고급언어들로 작성한 소스코드들은 결과적으로 컴퓨터가 이해할 수 있는 언어로 번역이 이루어짐</li></ul><ul id="a462d664-04a1-4f8b-b2cd-e5f315a7e48e" class="bulleted-list"><li style="list-style-type:disc">간단한 이유이지만, 컴퓨터는 근본적으로 0과 1밖에 모르기 때문 ⇒ 2진수</li></ul><ul id="6a38832b-f0bd-4641-a970-2162330e004d" class="bulleted-list"><li style="list-style-type:disc">좀 더 직관적으로 말하자면 전기적 신호로 전달 할 수 있는 방법이 On/Off 즉, 전류가 흐르는지 (=1), 안흐르는지(=0) 밖에 모름</li></ul><ul id="bf5f5c20-8006-4cbb-a051-d27b5313c0fc" class="bulleted-list"><li style="list-style-type:disc">그리고 이러한 신호들의 조합으로 여러 명령 체계를 만들어 사용</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ac9c0248-c2f8-4240-b696-3de8f9204936"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">우리가 일반적으로 사용하는 10진수를 단순하게 2진수로 해석하여 수를 표현하는데 아무런 문제가 없어보이지만, 양수 뿐만 아니라 음수를 표현할 방법이 필요함</div></figure><h2 id="fae8af50-c4d5-4fdf-99d5-a896d07dae55" class="">보수</h2><ul id="f9c54d96-2cc3-471b-b090-99e94c2a8b99" class="bulleted-list"><li style="list-style-type:disc">쉽게 풀어쓰면 &#x27;보충해주는 수&#x27;를 의미함 (어떤 수를 만들기 위해 필요한 수)</li></ul><ul id="f2612c2e-a2e6-4ced-a59c-54e0f36b66f7" class="bulleted-list"><li style="list-style-type:disc">현재의 숫자에서 자릿수가 1단계 올라갈 수 있는 수</li></ul><ul id="1e227a43-8d89-4b9a-af01-66250b102a93" class="bulleted-list"><li style="list-style-type:disc">컴퓨터에서 음의 정수를 표현하기 위해서 고안</li></ul><ul id="c7088130-f956-4084-8037-95b0bad2355b" class="bulleted-list"><li style="list-style-type:disc">컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 뺄셈은 덧셈으로 형식을 변환하여 계산 → 즉 컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산</li></ul><h3 id="2de9c023-d0a3-4d39-80ce-fdcd76c60aed" class="">보수를 사용하는 이유</h3><ul id="debc8a71-0fbd-4737-bd3a-7a9c7c7bd23e" class="bulleted-list"><li style="list-style-type:disc">부호 절대값을 이용하여 음수(뺄셈)을 이용하는 경우 고려해야 할 점이 많음</li></ul><ul id="ffc05962-eb26-49d0-8eb6-1638ed617834" class="bulleted-list"><li style="list-style-type:disc">보수를 이용하여 뺄셈을 할 수가 있는데, 바로 이 점이 컴퓨터 입장에서 좀 더 쉽고 일관되게 쓸 수 있음</li></ul><ul id="70e5660d-923e-4559-a3da-e397d72decc0" class="bulleted-list"><li style="list-style-type:disc">음수, 양수 상관없이 일관되게 덧셈만으로도 결과값을 얻기 위해 쓰임</li></ul><h2 id="46eeac40-1f77-44a9-97bf-365e6b13be4c" class="">음수를 표현하는 방법</h2><h3 id="453b81c3-a811-48fa-9358-bc1dcdafde40" class="">1) 부호 절댓값(Sign-Magnitude)</h3><ul id="b004b8c5-4b1e-4b2e-a3e0-57943b3dabda" class="bulleted-list"><li style="list-style-type:disc">가장 쉽게 생각할 수 있는 방법으로, 최상위 비트(MSB; Most Significant Bit)를 이용</li></ul><ul id="b30aa3ad-e1eb-44e9-9283-054201441a81" class="bulleted-list"><li style="list-style-type:disc">가장 일반적으로 사용하는 in t(32bit) 자료형 예시<p id="2d84ba37-437d-4646-a696-a520994a2846" class="">⇒ 0일 때 양수, 1일 때 음수</p><p id="f1c16712-5814-4613-a252-6dddb39313f7" class="">5 (10) = <code>0000 0000 0000 0000 0000 0000 0000 0101 (2)</code></p><p id="aeff9bde-5f60-45d7-ac57-ac9d306b4f5f" class="">-5 (10) = <code>1000 0000 0000 0000 0000 0000 0000 0101 (2)</code></p></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f3f9f576-4ab3-4d5f-bdaf-27792f10b402"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">우리는 10진법 체계에 익숙해져있고 음수의 덧셈에서도 쉽게 정답을 도출할 수 있지만, 컴퓨터는 그렇지 않음</div></figure><ul id="81e5f958-2793-4460-843a-8251f63d4120" class="bulleted-list"><li style="list-style-type:disc">장점<ol type="a" id="0829e93a-04ae-4227-b53c-416ea212097b" class="numbered-list" start="1"><li>최상위 비트만 고려해주면 되기 때문에 사람 입장에서는 직관적임</li></ol></li></ul><ul id="f8212a29-1446-4063-b5a5-bb6bec590599" class="bulleted-list"><li style="list-style-type:disc">한계<ol type="a" id="301df410-92c5-4b5b-9525-cb705d52e17d" class="numbered-list" start="1"><li>-0 (<code>1000 0000</code>)과 +0 (<code>0000 0000</code>)을 모두 인지할 수 있도록 처리해야함</li></ol><ol type="a" id="4ad7dca5-0fcd-408f-8df3-1794d7f80f6b" class="numbered-list" start="2"><li>연산에서 고려해야할 것들이 많아져 회로가 복잡해지고 많아짐 (MSB와 절댓값을 각각 계산)<p id="63afb93a-ac93-46d4-a612-e180198cd051" class="">⇒ -23 + 31 / 31 - 23 (절대값이 큰 쪽의 부호에 따라 MSB, 절댓값이 큰 수에서 작은 수로 빼줘야함)</p></li></ol></li></ul><h3 id="db4d43a2-b24d-41da-9115-7cb231aa7758" class="">2) 1의 보수</h3><ul id="1190b5da-dc52-4751-801f-a88401b2f760" class="bulleted-list"><li style="list-style-type:disc">2진법에서 1의 보수는 모든 자리의 수를 1로 만드는 수 (0→1, 1→0로 변환)</li></ul><ul id="63ec502c-fb11-42e6-99fe-20b3a1ffdf1f" class="bulleted-list"><li style="list-style-type:disc">최상위 비트는 양수와 음수 부호를 결정함</li></ul><ul id="c94a2eb5-2ca9-478b-8a5c-412f5a2b8e32" class="bulleted-list"><li style="list-style-type:disc">장점<ol type="a" id="2306dabc-cd68-4aaa-b1e6-211ebd0c3958" class="numbered-list" start="1"><li>비트만 반전하면 음수값을 구할 수 있음</li></ol><ol type="a" id="29444183-62f3-400c-bf12-7496748fa478" class="numbered-list" start="2"><li> MSB의 성질이 유지됨</li></ol><ol type="a" id="09022fba-f684-4714-9662-0293fdbecc24" class="numbered-list" start="3"><li>덧셈만으로 뺄셈을 구현할 수 있어 비교적 회로가 단순해짐</li></ol></li></ul><ul id="ad53ed01-464a-45a1-bc19-d13480ec28ef" class="bulleted-list"><li style="list-style-type:disc">한계<ol type="a" id="66035c9e-891d-4899-85cf-1f4a571f4190" class="numbered-list" start="1"><li>캐리가 발생하는 경우 처리해줘야함<hr id="46599196-4478-4284-92b4-7dc9fe967104"/><p id="0e5249dc-b507-484f-916f-650181655b15" class=""><code><strong>111 (2) - 110 (2) = 111 (2) + 001 (2) = 1000 (2) = 1 (2)</strong></code></p><p id="478e58aa-9204-4625-a043-fea35e1e06c8" class="">⇒ 최상위 비트를 지우고 1을 더함 (캐리 발생)</p><p id="bf8a58cc-77f0-47af-b04a-cc4667c4a886" class=""><code><strong>100 (2) - 110 (2) = 100 (2) + 001 (2) = 101 (2) = - 010(2)</strong></code></p><p id="3dc9dc18-2b1d-42a2-83cb-ebb18c64a036" class="">⇒ MSB가 1인 경우 캐리가 발생하지 않으며 1의 보수를 구하고 - 부호 붙임</p><hr id="a031404b-b727-4a54-a73f-aa39a53b829d"/></li></ol><ol type="a" id="c9ddc712-3b38-4c25-bec9-a92ef1d85b05" class="numbered-list" start="2"><li>-0 (<code>1111 1111</code>)과 +0 (<code>0000 0000</code>)을 모두 인지할 수 있도록 처리해야함</li></ol></li></ul><h3 id="fa2fad49-ae22-4cba-93f0-28eacc892b93" class="">3) 2의 보수</h3><ul id="bb262027-d830-4723-af95-e49d8af8abad" class="bulleted-list"><li style="list-style-type:disc">1의 보수에 +1을 하면 2의 보수가 됨</li></ul><ul id="df77fe2a-8f5a-4078-9bad-b90b21d4f687" class="bulleted-list"><li style="list-style-type:disc">최상위 비트는 양수와 음수 부호를 결정함</li></ul><ul id="df5f1f69-b7e5-46d8-b6f7-3d786c1da6ab" class="bulleted-list"><li style="list-style-type:disc">장점<ol type="a" id="e4df0500-82f9-4f2b-9f9c-9cfd905f231d" class="numbered-list" start="1"><li>1의 보수에 +1을 하면 음수값을 얻을 수 있음</li></ol><ol type="a" id="a8db0693-b2de-4766-b4f7-f7bb92519e5e" class="numbered-list" start="2"><li>MSB의 성질이 유지가 됨</li></ol><ol type="a" id="79ceda63-a5d2-4c28-a60a-67063b4bc13a" class="numbered-list" start="3"><li>덧셈만으로 뺄셈을 구현할 수 있어 회로가 단순해짐<hr id="15fe6b05-20a9-4f06-bc6c-79631e7e9022"/><p id="961fc706-9fe8-4101-81d7-4f5c2007f11f" class=""><code><strong>111 (2 ) - 110 (2) = 111 (2) + 010 (2) = 1001(2) = 1(2)</strong></code></p><p id="6979d569-381e-466d-8a29-6eb46aac92d3" class="">⇒ 최상위 비트를 지움</p><p id="79f2588b-eedc-4f3c-b30f-873dc173a90f" class=""><code><strong>100 (2) - 110 (2) = 100 (2) + 010 (2) = 110 (2) = -010 (2)</strong></code></p><p id="f6bcc9a9-35cd-4436-98ef-0e424315c42c" class="">⇒ 2의 보수를 구하고 - 부호 붙임</p><hr id="b0888826-dd39-49c0-b51c-a3495c06cde3"/></li></ol><ol type="a" id="b5837f66-246a-4567-9a51-91c82733cf55" class="numbered-list" start="4"><li>1의 보수의 단점 (캐리 발생 문제 및 +-0) 모두 해결됨<hr id="e05c6d99-d031-4bbe-905f-5b2eab191c57"/><p id="2dd45d3a-cbe6-42de-8bfb-43eef2eae6c1" class=""><code><strong>0000 0000 (2)</strong></code><strong> : 0</strong></p><p id="6a0fa8a8-4fdc-4cf5-b22b-97bc8064a24a" class=""><code><strong>1000 0000 (2)</strong></code><strong> : -128</strong></p><p id="03e690fc-8f34-4ed3-ac35-7afa32233e94" class="">⇒ <strong>-127 = </strong><code><strong>1000 0001 (2)</strong></code>에서 1을 빼준 <strong>-128 = </strong><code><strong>1000 0000 (2)</strong></code>의 숫자로 표현 가능</p><hr id="a19627e3-8e0e-495d-ac67-9cacdc4b26a1"/></li></ol></li></ul><h2 id="05991dc7-48bf-417a-8773-1671639f0505" class="">2의 보수가 음수인 이유 (검증)</h2><hr id="58b9de9f-ca44-48b4-9e0c-e57d838e0e04"/><p id="add7306a-014e-4d85-b712-dbd3b831530e" class="">&lt;<strong>예시&gt;</strong></p><ol type="1" id="2bd3ab80-7fc8-46be-b22b-74bdf85aae66" class="numbered-list" start="1"><li>10진수 37 → 16진수 0x25 → 2진수 <code>0010 0101</code> → 2의 보수 <code>1101 1011</code> → 16진수 0xDB → 결과 10진수 -37</li></ol><ol type="1" id="32655958-406a-4f08-b4ae-df7b1db9fba5" class="numbered-list" start="2"><li>검산을 해보면 <code>0010 0101</code> + <code>1101 1011</code> = 0이 되어야 함 → 더하면 <code>1 0000 0000</code></li></ol><ol type="1" id="b1562adb-67ee-4d31-abf1-85a3bc3fe75b" class="numbered-list" start="3"><li>0이 되지는 않지만 현재 8비트로만 이야기를 하므로 9번쨰 자리는 저장하지 못하고 아래 8자리만 유효숫자로 남음 (최상위 부호를 제외하면 0이 됨)</li></ol><ol type="1" id="a962b632-4f0a-49c9-a8d7-8c1347f5eef8" class="numbered-list" start="4"><li>즉, 2의 보수로 만들어낸 수는 확실히 음수인 것을 확인할 수 있음</li></ol><hr id="1161b6f3-be7c-42bb-8a70-f73f0119f17e"/><p id="0b71bec0-3062-476e-8101-bcbfd317b0f2" class="">&lt;<strong>128의 2의 보수&gt;</strong></p><ol type="1" id="c7517bb6-77f1-4c7a-ad68-63998d975437" class="numbered-list" start="1"><li>10진수 128 → 16진수 0x80 → 2진수 <code>1000 0000</code> → 2의 보수 <code>1000 0000</code> → 16진수 0x80 → 결과 10진수 -128</li></ol><ol type="1" id="be22be80-ed7a-40b6-aa95-c2adedca3e0f" class="numbered-list" start="2"><li><code>1000 0000</code> + <code>1000 0000</code> = <code>1 0000 0000</code></li></ol><ol type="1" id="fd2de444-d29c-4702-9236-9dd3873fab77" class="numbered-list" start="3"><li>이 경우 <code>1000 0000</code>이 양수인지 음수인지 구별할 수 없음 (16진수 0x80도 같음)</li></ol><ol type="1" id="56f389e5-ed8f-453b-8a35-3f060f4f0e25" class="numbered-list" start="4"><li>이 때 다른 음수값의 최상위 비트가 1이라는 점을 이용</li></ol><ol type="1" id="c78728f6-0eb3-428a-8b5c-f6a854b92f7e" class="numbered-list" start="5"><li>128인지 -128인지 구별해야할 때 0x80을 2진수로 나타내면 <code>1000 0000</code>이 되며, 최상위 비트가 1이므로 -128로 생각하는 것이 타당함</li></ol><ol type="1" id="23f1dd72-5b74-46c1-8fb8-8e5ec6d817c1" class="numbered-list" start="6"><li>따라서 8비트일 때 -128(<code>1000 0000</code>) ~ 127(<code>0111 1111</code>)이 표현범위가 됨</li></ol><hr id="ca25afe4-995b-4da1-9d5a-6d4011b38b8f"/><p id="b01b7d55-175e-496c-b628-236f97832d28" class="">
</p></div></article></body>

{% endblock post_content %}