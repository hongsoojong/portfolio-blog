{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">2진수의 음수 표현법</a>
{% endblock post_title %}

{% block post_content %}

    {% block post_date %}
        <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 17, 2021 ]</div>    
    {% endblock post_date %}

    <main class="container w-1/2 mx-auto font_kor">
        <div>
            <div class="post_text">
                <li>프로그램을 개발하기 위해 고급언어들로 작성한 소스코드들은 결과적으로 컴퓨터가 이해할 수 있는 언어로 번역이 이루어짐</li>
                <li>간단한 이유이지만, 컴퓨터는 근본적으로 0과 1밖에 모르기 때문 ⇒ 2진수</li>
                <li>좀 더 직관적으로 말하자면 전기적 신호로 전달 할 수 있는 방법이 On/Off 즉, 전류가 흐르는지 (=1), 안흐르는지(=0) 밖에 모름</li>
                <li>그리고 이러한 신호들의 조합으로 여러 명령 체계를 만들어 사용</li>
            </div>
            <div class="post_text">
                <p class="font-bold">우리가 일반적으로 사용하는 10진수를 단순하게 2진수로 해석하여 수를 표현하는데 아무런 문제가 없어보이지만, 양수 뿐만 아니라 음수를 표현할 방법이 필요함</p>
            </div>
        </div>
        <div id="보수">
            <div class="post_heading">보수</div>
            <div class="post_text">
                <li>쉽게 풀어쓰면 '보충해주는 수'를 의미함 (어떤 수를 만들기 위해 필요한 수)</li>
                <li>현재의 숫자에서 자릿수가 1단계 올라갈 수 있는 수</li>
                <li>컴퓨터에서 음의 정수를 표현하기 위해서 고안</li>
                <li>컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 뺄셈은 덧셈으로 형식을 변환하여 계산 → 즉 컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산</li>
            </div>
            <div class="post_subheading">보수를 사용하는 이유</div>
            <div class="post_text">
                <li>부호 절대값을 이용하여 음수(뺄셈)을 이용하는 경우 고려해야 할 점이 많음</li>
                <li>보수를 이용하여 뺄셈을 할 수가 있는데, 바로 이 점이 컴퓨터 입장에서 좀 더 쉽고 일관되게 쓸 수 있음</li>
                <li>음수, 양수 상관없이 일관되게 덧셈만으로도 결과값을 얻기 위해 쓰임</li>
            </div>
        </div>
        <div id="음수 표현법">
            <div class="post_heading">음수를 표현하는 방법</div>
            <div class="post_subheading">1) 부호 절댓값(Sign-Magnitude)</div>
            <div class="post_text">
                <li>가장 쉽게 생각할 수 있는 방법으로, 최상위 비트(MSB; Most Significant Bit)를 이용</li>
                <li>가장 일반적으로 사용하는 in t(32bit) 자료형 예시</li>
                <p class="ml-7">⇒ 0일 때 양수, 1일 때 음수</p>
                <div class="ml-7 post_box">
                    <p>5 (10) = 0000 0000 0000 0000 0000 0000 0000 0101 (2)</p>
                    <p>-5 (10) = 1000 0000 0000 0000 0000 0000 0000 0101 (2)</p>
                </div>
                <li class="font-bold">우리는 10진법 체계에 익숙해져있고 음수의 덧셈에서도 쉽게 정답을 도출할 수 있지만, 컴퓨터는 그렇지 않음</li>
                <li>장점</li>
                <p class="ml-7">a. 최상위 비트만 고려해주면 되기 때문에 사람 입장에서는 직관적임</p>
                <li>한계</li>
                <p class="ml-7">a. -0 (1000 0000)과 +0 (0000 0000)을 모두 인지할 수 있도록 처리해야함</p>
                <p class="ml-7">b. 연산에서 고려해야할 것들이 많아져 회로가 복잡해지고 많아짐 (MSB와 절댓값을 각각 계산)</p>
                <p class="ml-11">⇒ -23 + 31 / 31 - 23 (절대값이 큰 쪽의 부호에 따라 MSB, 절댓값이 큰 수에서 작은 수로 빼줘야함)</p>
            </div>
            <div class="post_subheading">2) 1의 보수</div>
            <div class="post_text">
                <li>2진법에서 1의 보수는 모든 자리의 수를 1로 만드는 수 (0→1, 1→0로 변환)</li>
                <li>최상위 비트는 양수와 음수 부호를 결정함</li>
                <li>장점</li>
                <p class="ml-7">a. 비트만 반전하면 음수값을 구할 수 있음</p>
                <p class="ml-7">b.  MSB의 성질이 유지됨</p>
                <p class="ml-7">c. 덧셈만으로 뺄셈을 구현할 수 있어 비교적 회로가 단순해짐</p>
                <li>한계</li>
                <p class="ml-7">a. 캐리가 발생하는 경우 처리해줘야함</p>
                <div class="ml-7 post_box">
                    <p class="font-bold">111 (2) - 110 (2) = 111 (2) + 001 (2) = 1000 (2) = 1 (2)</p>
                    <p>⇒ 최상위 비트를 지우고 1을 더함 (캐리 발생)</p>
                    <p class="font-bold">100 (2) - 110 (2) = 100 (2) + 001 (2) = 101 (2) = - 010(2)</p>
                    <p>⇒ MSB가 1인 경우 캐리가 발생하지 않으며 1의 보수를 구하고 - 부호 붙임</p>
                </div>
                <p class="ml-7">b. -0 (1111 1111)과 +0 (0000 0000)을 모두 인지할 수 있도록 처리해야함</p>
            </div>
            <div class="post_subheading">2의 보수</div>
            <div class="post_text">
                <li>1의 보수에 +1을 하면 2의 보수가 됨</li>
                <li>최상위 비트는 양수와 음수 부호를 결정함</li>
                <li>장점</li>
                <p class="ml-7">a. 1의 보수에 +1을 하면 음수값을 얻을 수 있음</p>
                <p class="ml-7">b. MSB의 성질이 유지가 됨</p>
                <p class="ml-7">c. 덧셈만으로 뺄셈을 구현할 수 있어 회로가 단순해짐</p>
                <div class="ml-7 post_box">
                    <p class="font-bold">111 (2 ) - 110 (2) = 111 (2) + 010 (2) = 1001(2) = 1(2)</p>
                    <p>⇒ 최상위 비트를 지움</p>
                    <p class="font-bold">100 (2) - 110 (2) = 100 (2) + 010 (2) = 110 (2) = -010 (2)</p>
                    <p>⇒ 2의 보수를 구하고 - 부호 붙임</p>
                </div>
                <p class="ml-7">d. 1의 보수의 단점 (캐리 발생 문제 및 +-0) 모두 해결됨</p>
                <div class="ml-7 post_box">
                    <p class="font-bold">0000 0000 (2) : 0</p>
                    <p class="font-bold">1000 0000 (2) : -128</p>
                    <p>⇒ -127 = 1000 0001 (2)에서 1을 빼준 -128 = 1000 0000 (2)의 숫자로 표현 가능</p>
                </div>
            </div>
        </div>
        <div id="2의 보수 검증">
            <div class="post_heading">2의 보수가 음수인 이유 (검증)</div>
            <div class="post_text">
                <div class="post_box">
                    <p class="font-bold">< 예시 ></p>
                    <p>1. 10진수 37 → 16진수 0x25 → 2진수 0010 0101 → 2의 보수 1101 1011 → 16진수 0xDB → 결과 10진수 -37</p>
                    <p>2. 검산을 해보면 0010 0101 + 1101 1011 = 0이 되어야 함 → 더하면 1 0000 0000</p>
                    <p>3. 0이 되지는 않지만 현재 8비트로만 이야기를 하므로 9번쨰 자리는 저장하지 못하고 아래 8자리만 유효숫자로 남음 (최상위 부호를 제외하면 0이 됨)</p>
                    <p>4. 즉, 2의 보수로 만들어낸 수는 확실히 음수인 것을 확인할 수 있음</p>
                </div>
            </div>
            <div class="post_text">
                <div class="post_box">
                    <p class="font-bold">< 128의 2의 보수 ></p>
                    <p>1. 10진수 128 → 16진수 0x80 → 2진수 1000 0000 → 2의 보수 1000 0000 → 16진수 0x80 → 결과 10진수 -128</p>
                    <p>2. 1000 0000 + 1000 0000 = 1 0000 0000</p>
                    <p>3. 이 경우 1000 0000이 양수인지 음수인지 구별할 수 없음 (16진수 0x80도 같음)</p>
                    <p>4. 이 때 다른 음수값의 최상위 비트가 1이라는 점을 이용</p>
                    <p>5. 128인지 -128인지 구별해야할 때 0x80을 2진수로 나타내면 1000 0000이 되며, 최상위 비트가 1이므로 -128로 생각하는 것이 타당함</p>
                    <p>6. 따라서 8비트일 때 -128(1000 0000) ~ 127(0111 1111)이 표현범위가 됨</p>
                </div>
            </div>
        </div>
    </main>
{% endblock post_content %}