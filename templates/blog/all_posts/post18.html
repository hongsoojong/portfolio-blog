{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(14) C99 표준</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Oct 05, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="497698bf-0a25-45a7-b8ff-b33ba4e739e1" class="page sans"><div class="page-body"><h3 id="b88fce7f-8cb2-4a2a-9699-da57cc40cdf7" class="">C99 표준에는 굉장히 다양한 것들이 추가됨</h3><ul id="46c6051a-a81b-4624-9757-3d79c310ec67" class="bulleted-list"><li style="list-style-type:disc">인라인 함수</li></ul><ul id="99cebd51-e01d-4f67-8942-5fcd49492214" class="bulleted-list"><li style="list-style-type:disc"><code>restrict</code> 키워드</li></ul><ul id="3071fcd5-4471-41aa-8c2d-46d19003ea72" class="bulleted-list"><li style="list-style-type:disc">한 줄 주석 (<code>//</code>)</li></ul><ul id="3f79c740-4ebe-41a6-9507-37794385db40" class="bulleted-list"><li style="list-style-type:disc">변수 선언의 위치 개선</li></ul><ul id="3e78ee36-6370-49fd-94a1-3eacb6167f1b" class="bulleted-list"><li style="list-style-type:disc"><code>va_copy</code></li></ul><ul id="2c91e056-521c-4c61-8a6a-41db7dcb8353" class="bulleted-list"><li style="list-style-type:disc">새로운 자료형<ul id="bbc14e18-57aa-4186-9c83-26cb3fea29f0" class="bulleted-list"><li style="list-style-type:circle"><code>long long int</code></li></ul><ul id="ed263321-0a41-4b34-a910-78240d5df5ed" class="bulleted-list"><li style="list-style-type:circle"><code>_Bool</code></li></ul><ul id="aadc83c2-a37b-4e53-9526-d707cad45bc6" class="bulleted-list"><li style="list-style-type:circle">고정 폭 정수형</li></ul><ul id="c12b5bf9-ad8b-4b01-ad9e-9f298ce92ad6" class="bulleted-list"><li style="list-style-type:circle"><code>_Complex</code>, <code>_Imaginary</code></li></ul></li></ul><ul id="392089f4-a412-416c-8d88-938cbf084479" class="bulleted-list"><li style="list-style-type:disc">IEEE 부동 소수점 지원 개선</li></ul><ul id="5daa81f9-3f7b-4bbe-8512-4263c5f038b2" class="bulleted-list"><li style="list-style-type:disc">수학 관련 오류 처리</li></ul><ul id="9315c7da-8573-4cbd-ba0c-3e3d829d7642" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;tgmah.h&gt;</code></li></ul><ul id="0bbcabf6-7021-4b54-9d57-d1c536d03205" class="bulleted-list"><li style="list-style-type:disc">가변 길이 배열</li></ul><ul id="f0e6942d-af30-4137-9417-bf13567e80ec" class="bulleted-list"><li style="list-style-type:disc">배열의 정적 색인</li></ul><ul id="8e5d7aaf-5b81-4263-89a9-24f5c0a42d2e" class="bulleted-list"><li style="list-style-type:disc">복합 리터럴</li></ul><ul id="14602ac1-a57f-4478-8e82-38790aed7bc4" class="bulleted-list"><li style="list-style-type:disc">가변 매크로</li></ul><ul id="40a5fa52-d516-44f2-874a-31c0ffa76155" class="bulleted-list"><li style="list-style-type:disc"><code>snprintf()</code></li></ul><ul id="b25c52c6-ef71-4746-81dc-efe52ca1c116" class="bulleted-list"><li style="list-style-type:disc">유니코드 </li></ul><ul id="48da036e-3080-45fd-8fb0-acd66deece70" class="bulleted-list"><li style="list-style-type:disc">등등</li></ul><h2 id="2c0a3619-8090-4cb1-a698-3036e730d2cd" class="">C99로 빌드하기</h2><ul id="a2932f84-6b05-4daa-9c32-9a5315b1d22d" class="bulleted-list"><li style="list-style-type:disc">C99가 되었으니 컴파일 옵션도 바뀌어야함 → 매우 간단</li></ul><ul id="9049d50e-d228-4859-b007-65f9a20debd5" class="bulleted-list"><li style="list-style-type:disc">std 옵션을 c89 대신 c99로<pre id="71553ced-c12a-4c3f-b8f1-14292ef27796" class="code"><code>&gt; clang -std=c99 -W -Wall -pedantic-errors *.c</code></pre></li></ul><h2 id="f11116a8-20c1-475c-8499-38b4576a2ad7" class="">인라인 함수</h2><h3 id="f92fcf01-35cd-44ee-ab83-2f0ea5bfa0d9" class="">(복습) 매크로 함수</h3><ul id="62e05c43-04f8-4cfd-a0a1-edf69557e17a" class="bulleted-list"><li style="list-style-type:disc">함수 호출 형태가 아니라 코드 자체를 무식하게 복붙<pre id="879a7f5c-a954-4eb3-ad11-3f175193e56a" class="code"><code>#define POW(n, p, i, r) r = 1;                        \
												for (i = 0; i &lt; p; ++i) {     \
													r *= n;                     \
												}                             \</code></pre><pre id="e76fa55d-63cc-4b7a-b201-20cb4264da90" class="code"><code>POW(num, exp, i, result);  /* result: 1024 */</code></pre></li></ul><ul id="a063072e-15d7-4a43-ba1e-1f027c07ca47" class="bulleted-list"><li style="list-style-type:disc">함수 호출에 따른 과부하를 막을 수 있음</li></ul><ul id="4ed169fd-9f27-4eb7-b480-46ffb6c06012" class="bulleted-list"><li style="list-style-type:disc">그러나<strong> 디버깅이 아주 매우 엄청나게 힘듦</strong></li></ul><ul id="65bb9618-b935-48bb-91f9-f0327470dd80" class="bulleted-list"><li style="list-style-type:disc">뿐만 아니라 <strong>가독성이 매우 떨어짐</strong></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3679f683-883c-4c47-9b31-b83df2c64ade"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">우리가 흔히 작성하던 함수에 매크로 함수의 장점만 추가할 순 없을까? ⇒ <strong>C99에서는 가능! (항상은 아니지만)</strong></div></figure><h3 id="7a04cccc-8927-4584-b6e9-b4dfc2c62511" class="">인라인 함수</h3><pre id="a309cab3-85c6-4600-9461-5b5821603020" class="code"><code>inline 반환형 함수_이름(매개변수 목록) {}</code></pre><ul id="c6a2b747-2376-4880-b524-c45ae9c10759" class="bulleted-list"><li style="list-style-type:disc">컴파일러에게 최적화 해달라고 알려주는 <strong>&#x27;힌트&#x27;</strong><ul id="064eb610-1d43-413f-89ff-49c0c16dec21" class="bulleted-list"><li style="list-style-type:circle">보통 매크로 함수처럼 코드를 복붙 해줌</li></ul><ul id="36e33b85-80b8-4362-b809-e14f35a72c5a" class="bulleted-list"><li style="list-style-type:circle">즉, 함수 호출이 사라짐!</li></ul><ul id="d31fcc1d-cae4-4958-91d5-d0b5b0dcf552" class="bulleted-list"><li style="list-style-type:circle">힌트일 뿐 컴파일러가 무시할 수도 있음</li></ul><ul id="54b1cd50-1dc1-4a69-972b-4eea96d40562" class="bulleted-list"><li style="list-style-type:circle">inline이 없어도 컴파일러가 최적화 해줄 수도 있음</li></ul></li></ul><ul id="679a4bc2-593e-44d0-8c65-917489d320e8" class="bulleted-list"><li style="list-style-type:disc">복붙을 할 수 있으려면?<ul id="646fa68c-adcd-4476-a911-1d71046cf765" class="bulleted-list"><li style="list-style-type:circle">인라인 함수를 호출하는 코드를 컴파일할 때 그 함수의 구현을 알아야 함</li></ul><ul id="9921ce2d-5d7d-4034-b5bd-150cff13e5a0" class="bulleted-list"><li style="list-style-type:circle">따라서 인라인 함수의 구현은 소스파일이 아니라 <strong>헤드파일에 둠</strong></li></ul></li></ul><h3 id="310522c2-73b3-4649-a527-ebfd39ae5ae0" class="">C++의 인라인과는 다름!</h3><ul id="4a5cd6e4-13bd-4420-94ea-88da588d3d0d" class="bulleted-list"><li style="list-style-type:disc">C의 인라인은 C++에서 가져온 것</li></ul><ul id="e72c7875-056c-4810-b3aa-6b309edd8bfb" class="bulleted-list"><li style="list-style-type:disc">그러나 C++의 인라인만큼 명확하지 않음<ul id="6d1f6669-0114-4e5a-9135-78e142f2edae" class="bulleted-list"><li style="list-style-type:circle">따라서 많이들 실수함</li></ul><ul id="8918aeeb-1ca3-4452-b198-0c508de10c67" class="bulleted-list"><li style="list-style-type:circle">잘 쓰이지 않는 C99 표준이라 올바른 예가 많이 없기 때문일지도</li></ul><ul id="8a35d268-c879-4e32-b899-8d5935120d90" class="bulleted-list"><li style="list-style-type:circle">C에서 올바르게 작동시키려면 좀 이상한 짓을 해야함</li></ul></li></ul><ul id="d4e9a29b-352c-4f40-8029-4dc595ce8c49" class="bulleted-list"><li style="list-style-type:disc">그나마 다행인 것은 C의 인라인 코드는 C++에서 제대로 동작</li></ul><h3 id="e53c661a-a7db-4a32-bace-e6852da0bb07" class="">인라인 함수의 작동법</h3><pre id="52fe8236-9552-44aa-ba4e-7d28021fced0" class="code"><code>/* simple_math.h */
inline int add(int op1, int op2)
{
	return op1 + op2;
}</code></pre><pre id="cd4bd3d0-5d52-4c10-8342-60366b6bfd21" class="code"><code>/* main.c */
#include &quot;simple_math.h&quot;
...
int main()
{
	int result = add(10, 20) * add(30, 50);
	printf(&quot;%d&quot;, result);
	return -;
}</code></pre><p id="e30cc9f4-89f7-4209-8e59-80a50f6a1437" class="">⇒ 다음과 같이 코드가 작성되면</p><pre id="da680e56-923f-4723-84f2-921129adbc30" class="code"><code>/* main.c */
...
int main()
{
	int result = (10 + 20) * (30 + 50);
	printf(&quot;%d&quot;, result);
	return -;
}
	</code></pre><p id="24abd973-8a4e-4dd6-9eec-ae4e8d11ec47" class="">⇒ 이와 같이 합쳐짐</p><h3 id="eec97865-3c09-4374-affe-0a9c8f2d693c" class="">무식하게 코드를 복붙하지 않음!</h3><ul id="c7dedeab-c1f4-48f5-a442-145fcac0187e" class="bulleted-list"><li style="list-style-type:disc">매크로는 전처리기가 코드를 무식하게 토씨 하나 안 틀리게 복붙 함<ul id="704a4826-60ab-4215-a889-10c1fa0afe8c" class="bulleted-list"><li style="list-style-type:circle">그러다 보니 연산자 우선순위 문제가 생길 수 있음</li></ul><ul id="68da560b-acd5-4e91-9405-b8bae310d380" class="bulleted-list"><li style="list-style-type:circle">매개변수 및 코드를 무조건 괄호로 감싸는 것을 권장</li></ul></li></ul><ul id="e7e2e06f-54f1-44a5-913a-fc9e332f7597" class="bulleted-list"><li style="list-style-type:disc">인라인 함수는 컴파일러가 컴파일 중에 함수 호출을 코드로 바꿔줌<ul id="be383271-9755-45f9-adf1-0b4ea756a881" class="bulleted-list"><li style="list-style-type:circle">사실 결과적으로 복붙 → 좀 더 융통성 있게 잘 복붙할 뿐</li></ul><ul id="24aa10ee-d3a2-4a19-8cdc-7a9f9a66663c" class="bulleted-list"><li style="list-style-type:circle">함수가 누리는 혜택을 그대로 누림</li></ul></li></ul><h3 id="4f87ec7b-5082-4b18-ab00-af777b077b04" class="">함수 구현을 알아야 복붙이 가능함</h3><ul id="d3220071-2c75-4885-b813-032de507870a" class="bulleted-list"><li style="list-style-type:disc">복붙을 하려면 막하던, 잘하던 간에 함수의 구현을 알아야함</li></ul><ul id="d9ca6d2d-bf03-4dc3-97e3-4f1f227606d7" class="bulleted-list"><li style="list-style-type:disc">즉, 트렌슬레이션 유닛 안에 인라인 함수의 실제 코드가 있어야함</li></ul><ul id="c8c55984-d67d-4259-a3c9-6ceeaaf5f864" class="bulleted-list"><li style="list-style-type:disc">이 함수의 구현이 다른 C 파일 안에 있으면 불가능<ul id="88bf85f7-2c87-4e0c-bed5-0c5ac9324ed0" class="bulleted-list"><li style="list-style-type:circle">C 파일 별로 따로 컴파일되기 때문</li></ul></li></ul><ul id="43dab8aa-53e7-48a2-af59-50f8b224111a" class="bulleted-list"><li style="list-style-type:disc">따라서 헤더파일 안에 실제 코드가 있어야함<ul id="7d3d6e40-0476-47f2-9954-124d58da6f28" class="bulleted-list"><li style="list-style-type:circle">매크로 함수와 마찬가지</li></ul><ul id="7f5a725b-d196-4458-9848-1597228008ec" class="bulleted-list"><li style="list-style-type:circle">전처리기 단계에서 <code>#include</code>가 헤더의 내용을 모두 붙붙</li></ul></li></ul><h3 id="05f4b38d-11cd-4e24-b49d-cb746c70de84" class="">인라인 함수 오류의 예</h3><p id="2750c528-6071-4a0a-b616-663c35de683b" class=""><strong>&lt;헤더에 함수의 구현부를 넣으면?&gt;</strong></p><pre id="4be7c0ff-b906-43ec-96ae-778e7bdb4a3e" class="code"><code>/* simple_math.h */
int add(int op1, int op2)
{
	return op1 + op2
}</code></pre><pre id="4a93eb8b-1ef0-45dd-be7a-bda228dccccf" class="code"><code>/* humanoid.c */
#include &quot;simple_math.h&quot;

void walk(...)
{
}
// 코드 생략</code></pre><pre id="7a7293ec-bff0-4c3e-a374-dc53e6b37636" class="code"><code>/* bird.c */
#include &quot;simple_math.h&quot;

void fly(...)
{
}
// 코드 생략</code></pre><ul id="b2bc6d66-f459-4029-a488-bbdae16d475d" class="bulleted-list"><li style="list-style-type:disc">링크 오류 발생<p id="0745f540-c37c-4b18-b309-473998be954b" class="">⇒ 함수의 구현체 똑같은 이름이 여러 개가 있음 → 동일한 함수가 여러군데 있을 경우 합칠 때 문제가 됨</p><pre id="52954105-7b75-42e8-b13f-5af6827b62f2" class="code"><code>humanoid-c3d9cc.o : error LNK2005: _add already defined in bird-781d91.o
a.exe : fatal error LNK1169: one or more multifly defined symbols found
clang: error: linker command failed with exit code 1169 (use -v to see invocation)</code></pre></li></ul><ul id="f1ee2140-cc7f-4258-aaf8-bc20e477ee9d" class="bulleted-list"><li style="list-style-type:disc">링킹 오류가 나는 이유<ul id="bc74755d-8675-44db-8675-320283374e82" class="bulleted-list"><li style="list-style-type:circle">모든 <code>.o</code>파일에 <code>add()</code>가 들어 있음</li></ul><ul id="e04d8da9-78a8-43e4-b8b0-1e2c7eecdf3a" class="bulleted-list"><li style="list-style-type:circle">즉, 동일한 이름의 함수가 2개나 있음</li></ul><ul id="5b4f2bc6-da78-46f6-ac95-e5ae6265703d" class="bulleted-list"><li style="list-style-type:circle">그 중 어느 <code>add()</code>와 링킹을 해야하는지 몰라서 오류 발생<p id="2e0f9a5e-5373-47dd-bc65-228cef3f4ff0" class=""><strong>⇒ 이 문제를 해결하는 방법? inline 함수</strong></p></li></ul></li></ul><p id="ec2d404a-2310-4e40-bab8-821a8f4274d4" class=""><strong>&lt;inline 키워드로 이 함수의 용도를 표시&gt;</strong></p><ul id="5aec2c0f-1fc0-4f1d-a975-4f09346a5b03" class="bulleted-list"><li style="list-style-type:disc">컴파일러에게 호출용 함수가 아니라 코드 교체용이라 알려줌</li></ul><ul id="9a369744-e97c-4009-9c6d-eb3fc3e0e442" class="bulleted-list"><li style="list-style-type:disc">그 결과 링커가 볼 수 있는 함수 심볼을 만들지 않음</li></ul><pre id="efdf2c08-1917-479c-a264-effa9fff69bc" class="code"><code>/* simple_math.h */
inline int add(int op1, int op2)
{
	return op1 + op2;
}</code></pre><ul id="e755921e-fd0e-4ae8-8881-1b5789b42811" class="bulleted-list"><li style="list-style-type:disc">이제 컴파일하면 아까의 링커 오류가 안남</li></ul><ul id="8e8c6a10-44be-4757-b9b0-220b77be7612" class="bulleted-list"><li style="list-style-type:disc">단, 다른 오류가 날 수도 있음</li></ul><hr id="2d3e9472-aab8-480a-9409-9f5bb3a263a7"/><p id="1545d978-a18e-4b40-8899-1c2a1096ead7" class=""><strong>inline 키워드는 그저 힌트일 뿐</strong></p><ul id="5ab8bb71-1af0-4b1e-80b5-4fbea33c4250" class="bulleted-list"><li style="list-style-type:disc">컴파일러가 해당 함수를 인라인화 한다는 보장이 없음</li></ul><ul id="cb8f91bf-a774-4a18-ac85-53c4ecb87f41" class="bulleted-list"><li style="list-style-type:disc">한다면 문제가 없음</li></ul><ul id="b225d43b-04a5-4116-a5d1-5844f96ae0a2" class="bulleted-list"><li style="list-style-type:disc">안한다면 문제가 됨</li></ul><hr id="5fe2d440-b94c-4a82-902f-9360090ecd61"/><p id="0937b43c-e37f-4a62-bacc-5adc0a461113" class=""><strong>&lt;인라인 함수로 변경 및 호출하는 코드&gt;</strong></p><pre id="a36abd8b-7fed-4910-a836-2a2ec7236047" class="code"><code>/* simple_math.h */
inline int add(int op1, int op2)
{
	return op1 + op2;
}</code></pre><pre id="987aa947-bf92-46e5-8777-b60cdfedf1b4" class="code"><code>/* humanoid.c */
#include &quot;simple_math.h&quot;

void walk(...)
{
	// 코드 어딘가에서
	// add() 호출
}
// 코드 생략</code></pre><pre id="8ed0f3d7-c3ca-495d-a7ea-57a7138334b2" class="code"><code>/* bird.c */
#include &quot;simple_math.h&quot;

void fly(...)
{
	// 코드 어딘가에서
	// add() 호출
}
// 코드 생략</code></pre><p id="43e6f57f-955f-479e-aad6-de42b23f3812" class=""><strong>&lt;인라인이 안 되면 무슨 문제가 일어날까&gt;</strong></p><ul id="fb0cb037-d688-4cb6-b182-968bfc6ee3ff" class="bulleted-list"><li style="list-style-type:disc">inline 키워드가 붙은 함수가 인라인 안됬다는 의미는?<ul id="478eb594-067e-4bc9-9d5b-1e5341f9af39" class="bulleted-list"><li style="list-style-type:circle">여전히 실행 중에 함수 호출을 한다는 의미</li></ul></li></ul><ul id="e6715658-f46c-43e6-981e-16bfc003cc38" class="bulleted-list"><li style="list-style-type:disc">따라서 컴파일 단계에서 그 함수의 시그니처만 기억</li></ul><ul id="03d45691-2d00-41b6-9cfe-30e0f4f3cdc9" class="bulleted-list"><li style="list-style-type:disc">링커가 실제 함수 구현을 찾아 구멍을 메꿔줌</li></ul><ul id="a97ffe7f-e975-4a46-8ea9-9523d3e185ab" class="bulleted-list"><li style="list-style-type:disc">그 경우 링킹 오류가 발생<pre id="9c08292b-52b1-47b3-9406-e9fb39353acf" class="code"><code>/tmp/ccyGlyMx: In function &#x27;fly&#x27;:
bird.c:(.text+0xf): undefined reference to &#x27;add&#x27;
/tmp/cc0BESkh In function &#x27;walk&#x27;:
humanoid.c:(.text+0xf): undefined reference to &#x27;add&#x27;
</code></pre><p id="8e850708-ee6b-4358-b28b-92b86f34f7b6" class="">⇒ 표준 상으로는 오류가 나오는 것이 맞으나 clang에서는 오류가 발생하지 않아 gcc로 결과 대체</p></li></ul><p id="3d25190c-d276-4c94-a418-a58b618f5cd9" class=""><strong>&lt;왜 이런 일이 발생할까&gt;</strong></p><ul id="f3c7da2f-dd7d-4bd2-bf7e-bebdbed9e164" class="bulleted-list"><li style="list-style-type:disc">이전에 inline 키워드를 설명한 바와 같이<ul id="7b3c6e1e-ccea-4840-afe7-2df8d210e10e" class="bulleted-list"><li style="list-style-type:circle">컴파일러에게 해당 함수를 &#x27;함수&#x27;로 쓰지 말라 함</li></ul><ul id="7c7dfa89-b436-4f1d-b869-a159a1990f13" class="bulleted-list"><li style="list-style-type:circle">그 대신 &#x27;코드 교체용&#x27;으로 쓰라고 알려줌</li></ul></li></ul><ul id="c08f3605-dce7-46fc-8222-e33fbb0088e9" class="bulleted-list"><li style="list-style-type:disc">그러다보니 <strong>컴파일러는 링커가 볼 수 있는 함수 심볼을 만들지 않음</strong></li></ul><ul id="6b1a154d-98f2-43fe-8efa-d2a74fba6be8" class="bulleted-list"><li style="list-style-type:disc">그러나 문제는 이 함수가 반드시 인라인 된다는 보장이 없음</li></ul><ul id="167cf6f3-5b99-456c-b22a-4be965953682" class="bulleted-list"><li style="list-style-type:disc">인라인이 안되면<ul id="5a52ddee-0e20-440e-ae98-6b4f9b3e3579" class="bulleted-list"><li style="list-style-type:circle">안됬는데 함수 심볼마저 없음</li></ul><ul id="f7f68542-d62b-4c8c-a7cf-a6a77c02a52e" class="bulleted-list"><li style="list-style-type:circle">따라서 링커 입장에서는 해당 함수를 찾을 방법이 없음!</li></ul></li></ul><h3 id="aac47f76-7cb2-40fb-a3c6-5f5da0f579a3" class="">링킹 오류의 해결법 1 : 일반 함수도 따로 만든다</h3><ul id="f73e499d-ac71-40f2-8b9f-b5706c20958c" class="bulleted-list"><li style="list-style-type:disc">인라인 함수와 똑같이 구현된 일반 함수가 어딘가에 존재하면 됨<ul id="1935bd3c-c223-4ebe-af2e-a98eac662c93" class="bulleted-list"><li style="list-style-type:circle">링커가 찾을 수만 있으면 문제 없음</li></ul></li></ul><ul id="54f5dae3-e651-4aa9-9a9c-51867c410ea1" class="bulleted-list"><li style="list-style-type:disc"><strong>그러나 이런 방법은 쓸데 없는 코드 중복</strong></li></ul><pre id="99372176-c8e9-4dd8-a241-3d4fa88cf8f1" class="code"><code>/* simple_math.h */
#ifndef SIMPLE_MATH_H
#define SIMPLE_MATH_H

inline int add(int op1, int op2)
{
	return op1 + op2;
}

#endif /* SIMPLE_MATH_H */</code></pre><pre id="cc4be808-5d96-4f0b-96c2-37f35ab7069f" class="code"><code>/* simple_math.c */
int add(int op1, int op2)
{
	return op1 + op2;
}</code></pre><p id="dba5920a-0cce-4681-b57b-8be5ceeb6852" class="">⇒ 시그니처만 표시하기 위한 c 파일 : header를 넣어주지도 않았음</p><ul id="b9ed9a2b-9d71-4ebf-a393-6163dc168520" class="bulleted-list"><li style="list-style-type:disc">코드가 중복되는 순간 변경시 하나만 바꿔주고 하나는 안 바꿔줄 경우 실수들이 발생할 가능성이 농후함</li></ul><h3 id="28198ebc-3b2f-4c28-a13b-e13fd4d48a18" class="">링킹 오류의 해결법 2 : extern</h3><ul id="81b12b5a-2521-4ff3-9ae3-f5714c7e98fc" class="bulleted-list"><li style="list-style-type:disc">가장 좋은 방법 : 코드 중복 없이 함수 하나만 있는 것<ul id="1a6ff867-ad41-41c6-ba6b-fef61203686c" class="bulleted-list"><li style="list-style-type:circle">인라인이 되면 인라인으로 사용</li></ul><ul id="1afca775-2e34-455d-83a8-15a7bf6c3202" class="bulleted-list"><li style="list-style-type:circle">안 되면 일반 함수로 사용</li></ul></li></ul><ul id="396f4816-ee1c-4c0a-93f8-e139d489e17f" class="bulleted-list"><li style="list-style-type:disc">그걸 가능하게 만드는 키워드가 바로 <code>extern</code></li></ul><ul id="7e8e560a-8c82-4857-ac58-d4555a126c88" class="bulleted-list"><li style="list-style-type:disc"><strong><code>extern</code></strong><strong>을 붙이면 링커가 찾을 수 있는 함수도 만들어 줌</strong></li></ul><pre id="e675af5c-8d3b-4508-b90b-f3cc6194507f" class="code"><code>/* simple_math.h */
#ifndef SIMPLE_MATH_H
#define SIMPLE_MATH_H

extern inline int add(int op1, int op2)
{
	return op1 + op2;
}

#endif /* SIMPLE_MATH_H */</code></pre><pre id="3e296c96-e221-47e2-84de-8c43181fee9c" class="code"><code>/* humanoid.c */
#include &quot;simple_math.h&quot;

void walk(...)
{
	// 코드 어딘가에서
	// add() 호출
}
// 코드 생략</code></pre><pre id="83b61aa0-c4d0-4578-8f9b-1ade4a0653ec" class="code"><code>/* bird.c */
#include &quot;simple_math.h&quot;

void fly(...)
{
	// 코드 어딘가에서
	// add() 호출
}
// 코드 생략</code></pre><ul id="76537cd9-dae7-41c5-ad17-47f61a7a43ae" class="bulleted-list"><li style="list-style-type:disc">여전히 오류 발생<pre id="37ae31f0-d4c9-4fdf-ac61-4c2f34907643" class="code"><code>/tmp/ccVLQUNH.o: In function &#x27;add&#x27;:
humanoid.c:(.text+0xf): multiple definition of &#x27;add&#x27;
/tmp/cciAHN2S.o:bird.c:(.text+0x0): first defined here</code></pre><p id="b78392d1-2be1-4fa6-a488-7f24903c1289" class="">⇒ 표준 상으로 오류가 나오는 것이 맞으나 clang에서는 오류가 발생하지 않아 GCC 결과로 대체함</p></li></ul><p id="bc334fc6-5fc0-446e-8868-43c4122f5e27" class=""><strong>&lt;extern을 함수 구현부에 붙일 때 문제점&gt;</strong></p><pre id="e2b46db4-4145-4862-9209-dba5eb4ec117" class="code"><code>/* simple_math.h */
extern inline int add(int op1, int op2)
{
	return op1 + op2;
}</code></pre><ul id="89d01117-aaea-4b98-a5b8-f2f8fa11298d" class="bulleted-list"><li style="list-style-type:disc">이 헤더를 인클루드한 <code>.c</code>파일마다 이 함수가 생성됨</li></ul><ul id="9a7533ec-c0a0-4185-9568-443fa5aebe5d" class="bulleted-list"><li style="list-style-type:disc">즉, inline 안 붙인 함수가 헤더에 있을 때와 마찬가지 문제</li></ul><ul id="9884948c-b21c-418a-8aa2-cb5959d880c2" class="bulleted-list"><li style="list-style-type:disc">프로그램 전체에서 그 함수의 심볼은 딱 하나만 있어야함</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f7fa05e1-5c42-49c9-bf4e-e8f22726a698"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>프로그램 전체에서 특정 함수의 심볼은 단 하나만 있어야함!</strong></div></figure><h3 id="69e2498e-75c3-4b91-a9e9-d09c086e204d" class=""><strong>현재까지 아는 사실</strong></h3><ul id="b1b55c4e-e9c8-4d33-9a5c-e32a7515f28b" class="bulleted-list"><li style="list-style-type:disc">인라인 함수가 인라인도, 일반함수도 될 수 있게 해야함</li></ul><ul id="c077043c-7102-4ee9-9dac-ce5108ebba5b" class="bulleted-list"><li style="list-style-type:disc">일반 함수로 만들기 위해서는 extern 키워드가 필요</li></ul><ul id="2f819918-6415-4f29-afc1-e52fa9e8bed3" class="bulleted-list"><li style="list-style-type:disc">단, 일반 함수는 심볼이 딱 한 번만 나와야함</li></ul><h3 id="e8f2f494-0592-412e-99cd-f45064010f0c" class="">링킹 오류의 해결법 3 : 올바른 해결법 (최종)</h3><hr id="6e2f85f1-d0a4-4aa0-b333-0c8eadb59c08"/><p id="10ee1da6-b6da-402a-9093-1205058b9335" class="">1) <code>.h</code>파일 안에 인라인 함수를 구현</p><pre id="4bafcb88-d451-4419-ba08-58f2b31399ae" class="code"><code>/* simple_math.h */
#ifndef SIMPLE_MATH_H
#define SIMPLE_MATH_H

inline int add(int op1, int op2)
{
	return op1 + op2;
}

#endif /* SIMPLE_MATH_H */</code></pre><p id="19362aba-98d8-4280-9252-fbbcba2ece2a" class="">2) 그에 대응하는 <code>.c</code>파일을 만듦</p><p id="83141b2d-7a2d-48f7-9f37-548edae1ab74" class="">3) 그 파일에서 인라인 함수가 들어있는 <code>.h</code>파일을 인클루드</p><p id="3eea5710-b8d0-4b79-92bd-a3650124f7ae" class="">4) 그 파일에서 인라인 함수를 <code>extern</code> 인라인 함수로 다시 선언</p><pre id="ba4fa56d-db91-4b04-ab5e-b6e70b536d23" class="code"><code>/* simple_math.c */
#include &quot;simple_math.h&quot;

extern inline int add(int op1, int op2);</code></pre><p id="09cdfc5c-a32a-459b-826d-0437f9d189b4" class="">⇒ 앞 인라인 함수의 구현을 이용하여 심볼을 만들어줌</p><hr id="3fb1b7a6-4127-46a0-a066-86eba9b503a0"/><ul id="043f71ee-605a-4ef7-a3fe-282c81dc6c87" class="bulleted-list"><li style="list-style-type:disc">이러면 그 <code>.c</code>파일 안에서만 함수의 심볼이 나옴(딱 한 개!)</li></ul><ul id="240da5a3-3643-45b3-adeb-7555d87aa37f" class="bulleted-list"><li style="list-style-type:disc">이제 컴파일 중 인라인이 되면 헤더파일에 있는 구현을 사용</li></ul><ul id="835b2fcd-b9e8-4f9b-b4b6-1c1dc5f0fa1f" class="bulleted-list"><li style="list-style-type:disc">인라인이 안되면 링커가 <code>.c</code>파일에서 나온 심볼을 이용해 링킹</li></ul><h3 id="3f13f7c4-d589-4bcc-8c5d-330a1ff60d45" class="">올바른 인라인 함수의 예</h3><pre id="5e240203-2b14-47a6-b9c3-e88af8fefcc3" class="code"><code>/* simple_math.h */
#ifndef SIMPLE_MATH_H
#define SIMPLE_MATH_H

inline int add(int op1, int op2)
{
	return op1 + op2;
}

#endif /* SIMPLE_MATH_H */</code></pre><pre id="b583bb93-db69-4897-b3b9-e24c8a6822d5" class="code"><code>/* simple_math.c */
#include &quot;simple_math.h&quot;

extern inline int add(int op1, int op2);</code></pre><pre id="cac3ddd8-de7d-48eb-821e-195d706a3a0c" class="code"><code>/* humanoid.c */
#include &quot;simple_math.h&quot;

void walk(...)
{
	// 코드 어딘가에서
	// add() 호출
}
// 코드 생략</code></pre><pre id="ef46214f-6681-4098-822f-d2df8aed186c" class="code"><code>/* bird.c */
#include &quot;simple_math.h&quot;

void fly(...)
{
	// 코드 어딘가에서
	// add() 호출
}
// 코드 생략</code></pre><h3 id="e27415d9-4531-41ba-aaf2-bdf6fa532e78" class="">C++ 인라인과의 차이</h3><ul id="63a82e35-b06f-4c1d-b2ad-1556400737bd" class="bulleted-list"><li style="list-style-type:disc">C의 인라인은 어떻게 돌아가든 돌아가게 만드려고 이상한 짓을 한 느낌</li></ul><ul id="49d0c20e-9467-42fe-b952-4f0d713d1fa6" class="bulleted-list"><li style="list-style-type:disc">C++에서는 이런 짓을 안 해도 됨<ul id="0781df70-27ed-4ced-bede-5bcb928d9c11" class="bulleted-list"><li style="list-style-type:circle">헤더파일에 구현한 인라인 함수는 자동적으로 <code>extern</code></li></ul><ul id="296c96c6-5922-4e55-80bb-50c76866c762" class="bulleted-list"><li style="list-style-type:circle">따라서 이 헤더파일을 인클루드 한 .cpp 파일마다 함수 심볼이 생김</li></ul><ul id="205f8ca8-46cb-4219-b08a-ccd7b9352a7a" class="bulleted-list"><li style="list-style-type:circle">그러나 표준에 따르면 링커가 이 여러 심볼 중에 하나만 골라서 링킹해야 함</li></ul></li></ul><h3 id="cd3ceddd-8b0a-4dd6-a883-b2b01865e19f" class="">인라인 함수 vs 매크로 함수</h3><p id="d734e6e4-f2bf-49cb-bd72-6aa3356f8426" class=""><strong>&lt;인라인 함수&gt;</strong></p><ul id="f70a4f6e-1e2d-4f4d-92fd-51ef7a3693ee" class="bulleted-list"><li style="list-style-type:disc">함수 호출에 따른 오버헤드가 없음</li></ul><ul id="bd0c2c69-b237-4dc5-aefb-d09b6bc76b9a" class="bulleted-list"><li style="list-style-type:disc">실제로 인라인이 안 될 수도 있음</li></ul><ul id="7464b44f-f0f2-48d8-a559-812b8127eba0" class="bulleted-list"><li style="list-style-type:disc">코드를 알아서 잘 복붙<ul id="31780aaf-194e-43c6-826d-7078f69721aa" class="bulleted-list"><li style="list-style-type:circle">파일 크기가 비교적 덜 커짐</li></ul></li></ul><ul id="38741f6c-f424-4cc0-97fb-153d36239e53" class="bulleted-list"><li style="list-style-type:disc">코드 읽기가 편함</li></ul><ul id="a2ac7c18-00ea-4275-8528-0f1c18e3350c" class="bulleted-list"><li style="list-style-type:disc">디버깅이 쉬움</li></ul><p id="3bb9ac90-c2f5-4c95-9dbe-17baee7906eb" class=""><strong>&lt;매크로 함수&gt;</strong></p><ul id="9605a075-3914-4069-b423-ada3c2ba2d43" class="bulleted-list"><li style="list-style-type:disc">함수 호출에 따른 오버헤드가 없음</li></ul><ul id="484875c5-11f5-485f-8aeb-23e78c77c3c5" class="bulleted-list"><li style="list-style-type:disc">언제나 코드 복붙이 일어남</li></ul><ul id="c2f91791-8532-4e0f-9840-dcee5d3d8f1f" class="bulleted-list"><li style="list-style-type:disc">코드를 무식하게 그대로 복붙<ul id="37687ef2-d914-4f5a-ae3e-549810b62b86" class="bulleted-list"><li style="list-style-type:circle">파일 크기가 커질 수 있음</li></ul></li></ul><ul id="4a4c8638-7e84-4e3b-96d2-f61515920404" class="bulleted-list"><li style="list-style-type:disc">코드 읽기가 어려움</li></ul><ul id="c0ec76ff-8b8a-4db9-9cf2-ac8fca29c34b" class="bulleted-list"><li style="list-style-type:disc">디버깅이 너무 힘듦</li></ul><h3 id="12d55c5e-f7ee-42d6-bff9-5c6be274d8a1" class="">베스트 프랙티스 : 인라인을 쓰자</h3><ul id="8d3e3ab5-214a-49a6-891c-85c2005342cf" class="bulleted-list"><li style="list-style-type:disc">위와 같은 이유로 매크로 함수보다는 인라인이 좋음</li></ul><ul id="7b51fcdf-cb31-4d4c-b4cb-e95144db712a" class="bulleted-list"><li style="list-style-type:disc">특히 한 줄짜리 코드처럼 매우 간단한 함수일 때 적합<ul id="2699bf34-4b37-4cef-b7df-073e3a12f4d2" class="bulleted-list"><li style="list-style-type:circle">매크로도 마찬가지</li></ul></li></ul><ul id="3b878e29-2822-448d-94e0-daf49281a236" class="bulleted-list"><li style="list-style-type:disc">그런데 C에서는 인라인보다 매크로를 더 자주 사용<ul id="261bf394-864b-4912-9610-bbe4a9497f3f" class="bulleted-list"><li style="list-style-type:circle">일단 인라인인 사용하기 매우 불편하고 헷갈림</li></ul><ul id="8fde49c8-9166-4df8-bb62-d3df6511d7b9" class="bulleted-list"><li style="list-style-type:circle">C89 이후 표준에 추가된 기능은 그리 널리 사용되지 않음</li></ul></li></ul><ul id="b7264cad-f5e7-49db-baff-2f96a37867de" class="bulleted-list"><li style="list-style-type:disc">이런 문제가 없는 C++에서는 매크로 대신 거의 인라인을 사용</li></ul><h2 id="a4314ac9-d113-4a23-8d9c-b284d7684b83" class="">정적 인라인 함수</h2><pre id="ecde7a32-ca07-463c-90ea-14bf67ab7dc3" class="code"><code>/* static_math.h */
#ifndef STATIC_MATH_H
#define STATIC_MATH_H

static inline int static_add(int a, int b)
{
	return a + b;
}

#endif /* STATIC_MATH_H */</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="65b230cf-01bf-449f-8ed0-c5b079e9c6f4"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">일례로 <code>.c</code>파일 안에서 <code>extern inline</code>을 선언하는 대신 그냥 static inline을 사용하라고 하는 사람들이 있음. 이 경우 링커 오류가 나지 않는다고.. 하지만 대부분의 경우 잘못된 생각임! 딱 이것만 하면 코드가 성공적으로 컴파일 됨. 이 함수가 인라인화 되던 아니던 마찬가지. 즉, <code>extern inline</code>을 하용하지 않아도 됨</div></figure><pre id="f678b853-3c57-4f19-a472-4bd9e9739df0" class="code"><code>/* adder.c */
#include &lt;stdio.h&gt;

#include &quot;adder.h&quot;
#include &quot;inline_math.h&quot;
/*
위 헤더 파일은 정적이 아닌 인라인 함수를 정의하고,
그에 상응하는 .c파일에 extern inline 선언도 있음
*/
#include &quot;static_math.h&quot;
/*
static inline 함수를 인크룰드하면
이 .c파일 안에서만 사용할 수 있음
따라서 링커가 찾을 수 있는 함수 심볼이 생기지 않음

이 경우 인라이노하가 안된 경우를 대비하여
각 .c파일마다 이 함수의 사본이 생긴다는 것을 의미함
어떻게 확인이 가능한가?
*/

void run_adder(void)
{
	printf(&quot;1 + 2 = %d\n&quot;, static_add(1, 2));
	/* static_add()의 반환값이 올바른지 확인 */
	printf(&quot;addr of static_add: %p\n&quot;, (void*)static_add);
	/* 인라인화가 안 될 경우 실행 중에 호출되는 함수의 주소를 출력하는 코드 */
	
	printf(&quot;1 + 2 = %d\n&quot;, inline_add(1, 2));
	printf(&quot;addr of inline_add: %p\n&quot;, (void*)inline_add);
}</code></pre><pre id="1422ed29-84b3-4a79-9ca3-f870d6606345" class="code"><code>/* main.c */
/* adder.c */
#include &lt;stdio.h&gt;

#include &quot;adder.h&quot;
#include &quot;inline_math.h&quot;
#include &quot;static_math.h&quot;
/*
main.c도 static_math.h를 인쿨루드
따라서 이 안에 statc_add() 함수의 또 다른 사본이 생김
하지만 접근은 main.c만 가능
*/

int main(void)
{
	printf(&quot;1 + 2 = %d\n&quot;, static_add(1, 2));
	printf(&quot;addr of static_add: %p\n&quot;, (void*)static_add);
	
	printf(&quot;1 + 2 = %d\n&quot;, inline_add(1, 2));
	printf(&quot;addr of inline_add: %p\n&quot;, (void*)inline_add);

	run_adder();

	return 0;
}</code></pre><ul id="2b8ff230-3004-4143-ab69-a101c0b2c10b" class="bulleted-list"><li style="list-style-type:disc">실제 출력값 비교<ul id="670737e8-5aee-4415-8b73-0284d5dea9f2" class="bulleted-list"><li style="list-style-type:circle"><code>(void*)inline_add</code> : 이 주소는 <code>main.c</code>와 <code>adder.c</code>에서 같음<ul id="0b79c5f9-8059-4b3f-a4ca-4eeed48dceb5" class="bulleted-list"><li style="list-style-type:square">딱 한 번만 함수를 정의했기 때문</li></ul></li></ul><ul id="539f1eb5-a032-4ffd-b93b-f133a3ce6252" class="bulleted-list"><li style="list-style-type:circle"><code>(void*)static_add</code> : 이 주소는 <code>main.c</code>와 <code>adder.c</code>에서 다름<ul id="e31a5f04-62c1-46db-80d7-8134f7fa6bd9" class="bulleted-list"><li style="list-style-type:square">각 <code>.c</code>파일마다 정적 변수가 만들어졌기 때문</li></ul><ul id="9aecdfcd-1b56-464c-baea-581bebe72acc" class="bulleted-list"><li style="list-style-type:square">따라서 인라인화가 전혀 안됬다면 무의미하게 파일 크기가 2배로 늘어난 꼴이됨</li></ul></li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c8f38726-603d-44cc-94f0-179722e38fd4"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong><code>static inline</code></strong><strong>은 쓰지 말자!</strong></div></figure><h2 id="f204b4e1-b249-4505-a726-0014ca2f0273" class="">restrict 키워드</h2><h3 id="e8cbed7f-3d69-4302-b500-ff700741040a" class="">문자열 복사</h3><p id="6dde5e76-f166-40f0-8c9d-b5c1ecc8ba13" class=""><strong>&lt;src와 범위가 겹치는 dest에 위와 같이 복사가 가능할까? 어떻게 값이 들어갈까?&gt;</strong></p><ul id="1ad9daa2-63e1-488c-bbb1-2af77a9673d5" class="bulleted-list"><li style="list-style-type:disc">덮어 쓰인 값이 복사?</li></ul><ul id="b4946235-615a-4f37-b6e4-6b692a856356" class="bulleted-list"><li style="list-style-type:disc">아니면 원래 문자열 복사?</li></ul><p id="1872567d-6e74-4189-a21b-a60a1e68d47b" class=""><strong>&lt;정답 : &#x27;결과가 정해져 있지 않음&#x27;&gt;</strong></p><ul id="9b14795b-8da5-4dec-84b3-c530c993afb1" class="bulleted-list"><li style="list-style-type:disc">컴파일러 구현에 따라 다름<ul id="8abb15c5-0313-49b9-9c89-0cc30371c29c" class="bulleted-list"><li style="list-style-type:circle">덮어쓰인 값이 복사될 수도 있음</li></ul><ul id="ec83ec1b-6b8c-4aac-95da-7ee86f524072" class="bulleted-list"><li style="list-style-type:circle">원래 문자열이 복사될 수도 있음</li></ul><ul id="a0277865-de29-4ef4-99ab-7869caa0dd48" class="bulleted-list"><li style="list-style-type:circle">둘다 아니라 크래쉬가 날 수도 있음</li></ul></li></ul><h3 id="f1ef0a16-8cdd-4658-917d-7e34792b43cd" class="">함수 호출자를 100% 제어할 수 없음</h3><ul id="4617b9a5-7498-4bad-8a76-30cc3b446d2c" class="bulleted-list"><li style="list-style-type:disc">상식적으로 생각해보면 문자열 복사니 두 메모리(원본, 복사될 공간)가 안 겹치는게 맞음</li></ul><ul id="01bd892d-9b05-4cf7-be06-f4b9ad40ee5f" class="bulleted-list"><li style="list-style-type:disc">그러니 호출자가 겹치는 메모리 범위를 인자로 전달하면 막을 방법이 없음</li></ul><ul id="4ba4b59f-8fa1-4cc6-990c-b27cae985df9" class="bulleted-list"><li style="list-style-type:disc">또 다른 예시로 나눗셈을 할 떄 분모로 0을 사용하는걸 막을 수 없는 것과 마찬가지</li></ul><h3 id="1e98abd1-5ca7-4d74-ac59-a81d1671dfdd" class="">결국 안전의 책임은 컴파일러에게</h3><ul id="778df320-2867-4842-ac12-53e66adec8e7" class="bulleted-list"><li style="list-style-type:disc">결국 많은 컴파일러가 이런 함수를 방어적으로 구현해둠<ul id="1ac750ef-5188-4a56-9ca2-ca70176c79ce" class="bulleted-list"><li style="list-style-type:circle">특히 C → 어셈블리로 변환 과정에서<p id="e6732f77-7171-4107-82b8-a72bc19545d5" class="">1) 한 번에 한 바이트씩 복사</p><p id="45ecbef0-755e-497f-88b5-3aa2d2b729f6" class="">2) 레지스터 등의 임시공간에 원보을 복사해 놓은 뒤 그걸 다시 복사</p></li></ul></li></ul><ul id="bb455d9c-d295-46a7-a1cb-f896c6fba18b" class="bulleted-list"><li style="list-style-type:disc">이런 안전장치 덕에 코드가 비교적 안전하게 실행이 됨</li></ul><ul id="22e41078-3438-4a70-b588-fa22b2f27cda" class="bulleted-list"><li style="list-style-type:disc">그러나 그로 인한 성능 저하 문제가 발생함<p id="91c72313-1793-4d51-af30-b542f7af0f33" class="">⇒ C는 성능을 위해 존재하는 언어가 호출자의 몰상식으로 성능을 잃는 것이 맞는 것일까?</p></li></ul><h3 id="13eae289-aefb-4ef4-a785-d3fc09a39f2c" class="">restrict 키워드</h3><pre id="af07d940-73b1-4299-a2f5-340140a77a25" class="code"><code>int printf(const char* restrict format, ...);
int fprintf(FILE* restrict stream, const char* restrict format, ...);
int sprintf(char* restrict buffer, const char* restrict format, ...);

void* memory(void* restrict dest, const void* restrict src, size_t count)l

char* strcpy(char* restrict dest, const char* restrict src);</code></pre><ul id="213952cd-529e-4f17-9e1a-614bb3eab078" class="bulleted-list"><li style="list-style-type:disc">포인터 변수 전용인 컴파일러에게 알려주는 힌트<ul id="8cf5d363-a0ff-4867-946d-91b175d68cba" class="bulleted-list"><li style="list-style-type:circle"><strong>&#x27;이 포인터 변수의 메모리는 절대 다른 변수와 겹치지 않는다&#x27;</strong></li></ul><ul id="9c0bed98-170d-44ad-a62e-63c44c264472" class="bulleted-list"><li style="list-style-type:circle">컴파일러가 이 힌트를 무시할 수도 있음</li></ul></li></ul><ul id="3c4da1b2-ce1f-4cd4-a7b0-b8a70239c651" class="bulleted-list"><li style="list-style-type:disc"><strong>메모리 범위가 겹치지 않는 걸 막는 키워드가 아님</strong></li></ul><ul id="6fd2596c-df75-4c95-8afa-d52734858edc" class="bulleted-list"><li style="list-style-type:disc">여전히 범위가 겹치는 포인터 전달 가능. 그 경우 정의되지 않은 결과</li></ul><h3 id="40277ac7-bdab-40df-842c-9d4428f65b2e" class="">restrict를 사용 안할 경우</h3><pre id="76deb0a8-3214-43df-9a99-2d471e5a3162" class="code"><code>void increase(int* a, int* b, int* x)
{
	*a += *x;
		movl    (%edx), %esi
		addl     %esi, (%ecx)
	*b += *x;
		movl    (%edx), %ecx
		addl     %ecx, (%eax)
}

/* x가 가리키는 값을 레지스터에 두 번 저장 */</code></pre><ul id="117c4fed-ab2e-458a-83ef-549fb6a34541" class="bulleted-list"><li style="list-style-type:disc">x의 값이 중간에 바뀔 수 있는 가능성을 염두한 코드<p id="7afc6720-322a-4398-88f6-d0cee8488ab6" class="">(x가 a 또는 b와 같은 메모리를 가리킬 수 있다고 가정)</p></li></ul><ul id="91eb89f2-52a1-4f1f-bf5a-19a254f4aaee" class="bulleted-list"><li style="list-style-type:disc">변경된 값을 두 번째 덧셈에서 사용하기 위해 x의 값을 레지스터에 저장하는 어셈블리 명령어가 두 번</li></ul><h3 id="89f12cdb-dca5-4140-a570-989ef6767f4c" class="">restrict를 사용할 경우</h3><pre id="73e08ed2-9e4b-46af-9163-5110162d3183" class="code"><code>void increase(int* restrict a, int* restrict b, int* restrict x)
{
	*a += *x;
		movl    (%edx), %edx
		addl     %esi, (%ecx)
	*b += *x;
		addl     %edx, (%eax)
}</code></pre><ul id="0dcb36a0-7db4-44ff-a06a-b0a1f85c7c99" class="bulleted-list"><li style="list-style-type:disc">두 번째 코드 실행 시, <code>x</code>가 가리키는 값을 다시 레지스터에 읽어오지 않음</li></ul><ul id="16ef5efd-86aa-48ad-be4e-d50062f3ab6f" class="bulleted-list"><li style="list-style-type:disc">즉, 여기서는 어떤 포인터도 서로 같은 메모리를 가리키지 않을 것이라 가정</li></ul><ul id="21f56690-e152-4974-be7d-06d2d8afab17" class="bulleted-list"><li style="list-style-type:disc">따라서 컴파일러가 최적화를 할 수 있음</li></ul><h3 id="57d42a0c-5610-4e46-b176-901f5b5b3ef8" class="">그러나 호출자는 여전히 무시할 수 있음</h3><ul id="bb05973c-e4db-4486-b1d4-26eda89b7310" class="bulleted-list"><li style="list-style-type:disc"><code>restrict</code>는 컴파일러에게 &#x27;안전 장치 꺼도 됨&#x27;이라고 말해주는 것</li></ul><ul id="7ac7a2ec-8700-4c22-95f0-fb434f7c7354" class="bulleted-list"><li style="list-style-type:disc">그러나 프로그래머는 여전히 무시할 수 있음<ul id="874a0996-61b8-466e-87cc-7453b2315967" class="bulleted-list"><li style="list-style-type:circle">여전히 메모리 범위가 겹치는 포인터들을 전달할 수 있음</li></ul></li></ul><ul id="3ca88695-ed5b-4b4f-a04e-552301931515" class="bulleted-list"><li style="list-style-type:disc">코딩 표준에서 언급하였던 매개변수에 &#x27;<code>or_null</code>&#x27;을 붙이는 때와 비슷<ul id="513c9fe2-e0ae-44c9-b9de-1ee8209a0bbc" class="bulleted-list"><li style="list-style-type:circle">함수가 <code>NULL</code> 매개변수를 제대로 처리하는 경우만 그렇게 표시</li></ul><ul id="a0cd7c5d-c9ca-4b04-a3fe-3008583a80de" class="bulleted-list"><li style="list-style-type:circle">그러나 그렇지 않은 매개변수에 <code>NULL</code>을 전달하는 걸 막을 수는 없음</li></ul><ul id="c662c3a9-f383-4422-b0ef-0d7d8d100ca6" class="bulleted-list"><li style="list-style-type:circle"><code>assert()</code>가 유일한 장치</li></ul></li></ul><h3 id="461f6327-b72e-4a22-80a4-050228793747" class="">restrict의 필요성</h3><ul id="a64971f7-9501-416b-8df3-9b38e4ab2df3" class="bulleted-list"><li style="list-style-type:disc">일부 하드웨어의 경우, 매우 빠르게 메모리 복사가 가능 (예 : DMA)</li></ul><ul id="4754b27f-b834-4426-bb15-1c5bde187cf1" class="bulleted-list"><li style="list-style-type:disc">이를 위해 <code>#define</code>을 통해 플랫폼 전용 <code>memcpy()</code>등을 만듦</li></ul><ul id="f728917b-b883-4258-8036-09f047a00b89" class="bulleted-list"><li style="list-style-type:disc">보통 이러한 함수들에는 여러가지 제약이 있음<ul id="ff70b772-d4b4-4b01-87f4-f846d0a714ac" class="bulleted-list"><li style="list-style-type:circle">가장 대표적인 것이 메모리 범위가 겹치지 않아야 한다는 것 (즉, <code>restrict</code>)</li></ul><ul id="367cb983-21c1-497f-b707-86f3aa4c70b8" class="bulleted-list"><li style="list-style-type:circle">그 외 제약으로는 메모리 정렬(alignment)도 있음</li></ul></li></ul><h3 id="ebcb8f0e-1b35-4f97-8317-2c88f223f586" class="">restrict를 무시할 경우의 위험성</h3><ul id="4e4b41fe-1505-4b0f-98f4-9fb9e17f69ac" class="bulleted-list"><li style="list-style-type:disc"><code>inline</code>의 경우, 함수가 인라인화가 안되도 큰 문제가 없었음<ul id="54e3ead9-4513-4315-8469-ffa2e56222bb" class="bulleted-list"><li style="list-style-type:circle">그냥 일반 함수가 호출됨</li></ul></li></ul><ul id="90cf0124-e176-4837-b0a4-ba0748644f4b" class="bulleted-list"><li style="list-style-type:disc">그러나 <code>restrcit</code>덕에 최적화 된 코드에 포인터를 잘못 넣으면<ul id="8db67dc3-2872-465e-8a0f-f7fe4ee7014e" class="bulleted-list"><li style="list-style-type:circle">어떻게 될 줄 모름</li></ul></li></ul><ul id="c1733a1e-e05e-4edd-ad63-731e24849664" class="bulleted-list"><li style="list-style-type:disc">C99 표준이라 C에서는 많이 못 쓰지만 매우 중요한 개념<ul id="831c46c2-8d36-465e-90c7-37d29deb2b06" class="bulleted-list"><li style="list-style-type:circle">잘 알아두는 것이 좋음!</li></ul><ul id="700ddd7b-a854-4227-8083-995abe08e8e6" class="bulleted-list"><li style="list-style-type:circle">C++에서도 매우 흔히 사용함</li></ul></li></ul><h2 id="b023d64b-36d7-4a9a-9d8e-0d261950228a" class="">한 줄 주석</h2><h3 id="48ef3799-e7f8-411e-934e-c16dcab388d1" class="">C89에서 한 줄 주석을 다는 유일한 방법</h3><ul id="7f8be5b8-1243-4c59-beca-e9db7acbcc0e" class="bulleted-list"><li style="list-style-type:disc"><code>/**/</code><pre id="1752d48a-83d9-4336-9541-4e5198393623" class="code"><code>/* 이렇게 주석을 달거나 */
int do_something()
{
	char buffer[LENGTH]; /* 아니면 이렇게 */
	/* 이렇게도 가능 */
}</code></pre></li></ul><h3 id="a1c71051-7b00-4a17-8377-3d09c71510ef" class="">C99에서는</h3><ul id="cc73b358-74fe-483f-aee5-ceac78496c1d" class="bulleted-list"><li style="list-style-type:disc"><code>//  코드 한 줄</code><ul id="1021af05-2462-4a28-a3f8-330b7166b043" class="bulleted-list"><li style="list-style-type:circle"><code>//</code>의 오른쪽에 오는 한 줄의 텍스트만 주석처리를 해 줌</li></ul><pre id="b8d5e40e-e1b3-419b-96c2-c44b57cecb25" class="code"><code>int n;
n = 100; /// 키보드로 나중에 받자

printf(&quot;n: %d&quot;, n)</code></pre></li></ul><h2 id="41fdd17f-3351-4fa1-aa04-87fe6fa94982" class="">변수 선언</h2><h3 id="40b644e9-d1c8-488a-80e7-683dab39c867" class="">변수를 블록 중간에 선언 가능</h3><ul id="bce4224c-35fd-47b7-ad11-3a8845ac9177" class="bulleted-list"><li style="list-style-type:disc">C89에서는 모든 변수를 반드시 블록 상단에 선언했어야함<pre id="f3279dec-5ddc-4bc7-8616-0c2ea2359831" class="code"><code>// 변수 한 100개 선언
int i = 0;

for (i = 0; i &lt; LENGTH; ++i) {
	// 코드 생략
}

// 코드 생략

for (i = 0; i &lt; LENGTH; ++i) {
	// 코드 생략
}</code></pre><pre id="1c863cfb-2268-4b32-a71b-bb48bf6555af" class="code"><code>int sum_math;
int sum_eng;
// 변수 한 100개 선언

sum_math = add(math_scores, LENGTH);

// 코드 생략

sum_eng = add(eng_scores, LENGTH);

// 코드 생략</code></pre></li></ul><ul id="a3a5129f-6ac2-44ed-8653-75c10ac53b61" class="bulleted-list"><li style="list-style-type:disc">C99에서는 블록 중간에 변수 선언이 가능해짐!<pre id="ff5fc806-51b7-47c6-8b60-8acb56c85050" class="code"><code>// 코드 생략

for (int i = 0; i &lt; LENGTH; ++i) {
	// 코드 생략
}

// 코드 생략

for (int i = 0; i &lt; LENGTH; ++i) {
	// 코드 생략
}</code></pre><pre id="122c73d5-fa77-4a11-98a9-168a1153a8fb" class="code"><code>// 코드 생략

int sum_math = add(math_scores, LENGTH);

// 코드 생략

int sum_eng = add(eng_scores, LENGTH);

// 코드 생략</code></pre></li></ul><h2 id="fbb9c8a4-7e69-4e15-addc-9b2c3d67c998" class="">va_copy()</h2><h3 id="4c7b8d89-c332-419c-938f-3bb4df026cc0" class="">(복습) 가변 인자 함수</h3><ul id="043882b5-b2c9-4384-85de-210e7a674889" class="bulleted-list"><li style="list-style-type:disc">정해지지 않은 수의 매개변수(가변 인자)를 허용하는 함수<pre id="57cce970-0d3c-4deb-8d23-e804abb0d9c2" class="code"><code>int add_ints(const size_t count, ...);
int printf(const char *format, ...);</code></pre></li></ul><ul id="a7f4a9d1-ed69-4340-9926-804b97d4502e" class="bulleted-list"><li style="list-style-type:disc">가변 인자 함수와 관련된 매크로 함수 세 가지<ul id="f21a20f5-c0d1-433c-9287-0939e992e08f" class="bulleted-list"><li style="list-style-type:circle"><code>va_start()</code><ul id="6e07083e-696a-4aa8-b92e-25e608baa6c3" class="bulleted-list"><li style="list-style-type:square">가변 인자에 접근하기 전에 반드시 호출하는 함수</li></ul></li></ul><ul id="4e452757-c5f5-43f2-9d41-e3b0b6eeec32" class="bulleted-list"><li style="list-style-type:circle"><code>va_arg()</code><ul id="04dce71f-2418-4858-befb-035b3fdd0fe2" class="bulleted-list"><li style="list-style-type:square">가변 인자 목록으로부터 다음 가변 인자를 가져오는 함수</li></ul></li></ul><ul id="f3fcfebd-7c8a-4a41-8998-cb092dcb7051" class="bulleted-list"><li style="list-style-type:circle"><code>va_end()</code><ul id="04605453-3dcd-4655-a389-fc24bb9cff21" class="bulleted-list"><li style="list-style-type:square">가변 인자에 접근을 다 한 후에 반드시 호출하는 함수</li></ul></li></ul></li></ul><h3 id="67d7c4c1-811f-40aa-9c57-6ebf4982c62e" class=""> va_copy()</h3><p id="ca9f0716-ca19-4674-9abb-03bf692b3fb1" class="">⇒ 복사가 가능한 매크로 함수가 추가됨</p><pre id="3e0518f9-5425-4062-940b-1ad28df1f9ec" class="code"><code>va_copy(dest, src)</code></pre><ul id="2910037c-7881-4517-8fd3-2be410a9197a" class="bulleted-list"><li style="list-style-type:disc">C99에 추가</li></ul><ul id="329e366b-a32f-4552-b1a7-bab37185ba07" class="bulleted-list"><li style="list-style-type:disc">가변 인자 목록을 복사하는 매크로 함수</li></ul><ul id="a24d7ef9-9413-4780-8938-9c80d344f338" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code>를 다 사용한 후에는 반드시 <code>va_end()</code>를 호출해야 함</li></ul><h3 id="04dae11f-206b-44a2-a852-1dcd45c6bc01" class="">va_copy() 예시</h3><pre id="dbcb9930-fdb2-435c-bd24-70a41dc38104" class="code"><code>double get_variance(int count, ...)
{
	va_list arg_list_avg;
	va_start(arg_list_avg, count);
	
	va_list arg_list_v;
	va_copy(arg_list_v, arg_list_avg);

	double avg = 0.0;
	for (size_t i = 0; i &lt; count; ++i) {
		double num = va_arg(arg_list_avg, double);
		avg += num;
	}
	avg /= count;
	va_end(arg_list_avg);

	double variance = 0;
	for (size_t i = 0; i &lt; count; ++i) {
		double num = va_arg(arg_list_v, double);
		variance += (num - avg) * (num - avg);
	}
	variance /= count;
	va_end(arg_list_v);

	return variance;
}</code></pre><pre id="d43b17b4-7443-4780-9928-9307285f4451" class="code"><code>// 메인 함수
printf(&quot;variance: %f\n&quot;, get_variance(4, 10.0. 20.0. 30.0. 40.0));</code></pre><h2 id="947d6e57-4181-4543-86e5-ce1c5fe6f2c2" class="">snprintf()</h2><h3 id="7e753965-79b8-45d4-94ef-04207b5d265a" class="">sprintf()의 문제점</h3><pre id="1fb7967d-f0de-4a2d-b116-1cea7bbc3b82" class="code"><code>int sprintf(char* buffer, const char* format, ...);</code></pre><pre id="082e18b7-3a3a-438d-8ee7-af9dfc84729e" class="code"><code>char buffer[20];
const char* name = &quot;Caterina Hassinger&quot;;
int score = 100;

sprintf(buffer, &quot;%s&#x27;s score: %d\n&quot;, name, score);</code></pre><ul id="0a50406e-73f8-4c62-8db7-aee6e681b332" class="bulleted-list"><li style="list-style-type:disc">안전하지 않음<ul id="edd3e742-07d9-4024-b19b-00d87940fa7e" class="bulleted-list"><li style="list-style-type:circle"> <code>buffer</code>의 크기보다 긴 문자열이 들어와도 중간에 멈추지 ㅇ낳음</li></ul><ul id="8853a991-943c-4c0a-a349-cf6997206fd2" class="bulleted-list"><li style="list-style-type:circle">즉, <code>buffer</code> 범위르 넘어서서 계속 씀</li></ul></li></ul><h3 id="d267198f-cc94-4230-844b-b0eafda42e4d" class=""> snprintf()</h3><pre id="debb1157-4883-49d9-bb8d-6ce193267b3d" class="code"><code>int snprintf(char* restrict buffer, size_t bufsz, const char* restrict format, ...);</code></pre><ul id="1efd5f96-c158-4344-80b4-3e1370805586" class="bulleted-list"><li style="list-style-type:disc">최대 <code>bufsz - 1</code>개의 문자열을 출력</li></ul><ul id="0dce1144-839f-4b6e-8eb8-ff1c9a11a07e" class="bulleted-list"><li style="list-style-type:disc">나머지 하나는 바로 널 문자용<ul id="9f21e46b-5abb-497f-9afe-ca73d9578b65" class="bulleted-list"><li style="list-style-type:circle">언제나 붙여줌!</li></ul><ul id="12f20925-2530-4fd3-a6e4-18ab08e8036d" class="bulleted-list"><li style="list-style-type:circle"><code>strncpy()</code>와는 다름!</li></ul></li></ul><ul id="5a7210e3-2fa2-43fd-9f49-47a14110651a" class="bulleted-list"><li style="list-style-type:disc">하지만 실무에서는 마지막 요소에 널 문자 넣는 코드가 많이 보임<ul id="341a79ed-15c9-4e41-b88e-3a399c6e4dba" class="bulleted-list"><li style="list-style-type:circle"><code>strncpy()</code>처럼</li></ul></li></ul><pre id="b691dc66-0e0d-4fa0-ae9c-98c0e14753f5" class="code"><code>#include &lt;stdio.h&gt;

#define LENGTH (20)

int main()
{
	char buffer[LENGTH];
	const char* name = &quot;Caterina Hassinger&quot;;
	int score = 100;
	
	snprintf(buffer, LENGTH, &quot;%s&#x27;s score: %d\n&quot;, name, score);
	
	return 0;
}</code></pre><pre id="9f8472de-63fe-43d7-bd6e-d802a95c8b13" class="code"><code>// 실제로 더 많이 쓰이는 코드

#include &lt;stdio.h&gt;

#define LENGTH (20)

int main()
{
	char buffer[LENGTH];
	const char* name = &quot;Caterina Hassinger&quot;;
	int score = 100;
	
	snprintf(buffer, LENGTH, &quot;%s&#x27;s score: %d\n&quot;, name, score);
	buffer[LENGTH - 1] = &#x27;\0&#x27;;
	
	return 0;
}</code></pre><h3 id="4ad237e3-4b68-4752-8473-111c310245c5" class="">왜 널 문자를 넣어야 하는가</h3><ul id="3784b73e-721f-415a-897a-19e71a68a312" class="bulleted-list"><li style="list-style-type:disc">C89에서 자기만의 <code>_snprintf()</code>를 제공한 컴파일러가 있었음</li></ul><ul id="caa2e100-8ee2-4052-8c69-c247c3a13011" class="bulleted-list"><li style="list-style-type:disc">이 함수는 널 문자를 안 붙여줬었음</li></ul><ul id="15141a95-4a35-4a2a-a7a4-fab3c7614ac2" class="bulleted-list"><li style="list-style-type:disc">이제는 <code>snprintf()</code>를 만들어서 제대로 지원</li></ul><ul id="13f095b9-0b57-4b8c-a515-b8be17b0dd74" class="bulleted-list"><li style="list-style-type:disc">그러나 여전히 호환 때문에 <code>_snprintf()</code>를 남겨둠<ul id="8ab3722b-e76d-4071-8276-05d476191893" class="bulleted-list"><li style="list-style-type:circle">당연히 이 함수는 널 문자를 안 붙여줌</li></ul></li></ul><ul id="ad1b5878-e893-4a1f-ba06-56b7af94cdf4" class="bulleted-list"><li style="list-style-type:disc">고로 안전을 위해 언제나 마지막 요소에 널 문자를 넣는 코드를 둠</li></ul><pre id="9d4c03bc-539e-4d7f-8118-ecbf60cd4961" class="code"><code>snprintf(buffer, LENGTH, &quot;%s&#x27;s score: %d\n&quot;, name, score);
buffer[LENGTH - 1] = &#x27;\0&#x27;;</code></pre><ul id="251221b2-34b5-441a-a1a9-4ae56191ca2d" class="bulleted-list"><li style="list-style-type:disc">이 방법은 다음에 볼 예외 상황에서도 매우 안전함</li></ul><h3 id="29b4668d-7b1c-4971-8b5a-1200e5b177b9" class="">snprintf()도 위험할 수 있다 : 1</h3><pre id="f8654d0d-ba38-42de-b0d7-fd23e341c26c" class="code"><code>#define LENGTH (20)

char buffer[LENGTH]; // name과 score는 생략
snprintf(buffer, 0, &quot;%s&#x27;s score: %d\n&quot;, name, score);</code></pre><ul id="21997b68-43bb-48b4-abcc-da841c6137c0" class="bulleted-list"><li style="list-style-type:disc"><code>bufsz</code>가 <code>0</code>이면 아무것도 안 함</li></ul><ul id="f5a9d835-f10b-4174-8001-21dbd3dbd6ac" class="bulleted-list"><li style="list-style-type:disc">즉, 아무것도 안 썼으니까 널 문자도 안 붙여줌</li></ul><ul id="32c73f49-2509-491d-adb5-43e2178be60f" class="bulleted-list"><li style="list-style-type:disc">이 때, <code>buffer</code>를 읽으면 엄한 메모리까지 읽어올 수 있음<ul id="e54e938f-4b8c-43b5-ad82-22d63c943be7" class="bulleted-list"><li style="list-style-type:circle">&#x27;<code>\0</code>&#x27;를 만날 때까지 계속 읽음</li></ul></li></ul><h3 id="213777aa-5408-47c5-a7bc-c27c8d10d9d6" class="">snprintf()도 위험할 수 있다 : 2</h3><pre id="a9ce5a07-9a98-412f-9eab-f519fa261af2" class="code"><code>int snprintf(char* restrict buffer, size_t bufsz, const char* restrict format, ...);</code></pre><ul id="3be42341-89b0-46b5-8421-fc82895e6555" class="bulleted-list"><li style="list-style-type:disc">이 밖에도 <code>buffer</code>나 <code>format</code>이 <code>NULL</code>이면 펑펑 터짐!</li></ul><ul id="c43daf60-a50e-4a69-80d5-0fb062bc80c2" class="bulleted-list"><li style="list-style-type:disc">이러한 문제를 해결하고자 더 안전한 함수를 C11에서 제공함</li></ul><h2 id="00548d04-cb99-42a2-9dd3-f2702ae49040" class="">새로운 자료형 : long long int</h2><ul id="37d7b2b4-f9e1-435d-962f-7ad61fee7c63" class="bulleted-list"><li style="list-style-type:disc">C89에서는 최소 64비트인 정수형이 없었음</li></ul><ul id="79d98228-050c-43de-9433-498436685ef1" class="bulleted-list"><li style="list-style-type:disc">그러나 C99에서는 생김</li></ul><ul id="91b63aa0-cb4c-4fb1-a6aa-96e6e187a33d" class="bulleted-list"><li style="list-style-type:disc">그것이 바로 <code>long long int</code><ul id="4aa549d4-8399-4619-875d-4bfb55de5613" class="bulleted-list"><li style="list-style-type:circle">최소 64비트이고 <code>long</code>이상의 크기</li></ul><ul id="00344255-652f-4a6e-bf15-d15e1e650c02" class="bulleted-list"><li style="list-style-type:circle">다른 언어에서는 보통 그냥 <code>long</code>임</li></ul></li></ul><ul id="25299957-588a-40d9-a4b6-48cc9bf0eab3" class="bulleted-list"><li style="list-style-type:disc">표준에 상관없이 보통 안전하게 생각해도 되는 것<ul id="1a65cd6d-4a89-48c6-9977-6f5ab2023a1c" class="bulleted-list"><li style="list-style-type:circle">부호있는 경우 : -9,223,372,036,854,775,807 ~ 9,223,372,036,854,775,807</li></ul><ul id="01c72a57-787a-4e19-96f7-e2fa2d690540" class="bulleted-list"><li style="list-style-type:circle">부호없는 경우 : 0 ~ +18,446,744,073,709,551,615</li></ul></li></ul><h3 id="86346068-c01b-41f6-8b8b-e60c4393fe60" class="">long long in의 리터럴</h3><ul id="70127c17-a020-44e8-88b1-96b666df3679" class="bulleted-list"><li style="list-style-type:disc">부호있는 경우<pre id="fd6fed92-1975-4aed-9e85-49b0afcece73" class="code"><code>long long big_num1 = 9223372036854775807;              /* 기본: signed */
long long int bit_num2 = -9223372036854775807ll;</code></pre></li></ul><ul id="4a07826e-1499-4215-ac3d-a3a65a091cdc" class="bulleted-list"><li style="list-style-type:disc">부호없는 경우<pre id="233f56f6-2caa-438e-a91c-e567369ebbbd" class="code"><code>unsigned long long big_num3 = 9223372036854775808ULL;
unsigned long long int big_num4 = 9223372036854775808U;</code></pre></li></ul><ul id="c1ff62a9-1ee9-4152-906c-eacba6157ea0" class="bulleted-list"><li style="list-style-type:disc">리터럴<ul id="49f91488-32d3-455b-9a9b-e0bb40c7a5e6" class="bulleted-list"><li style="list-style-type:circle"><code>u, U</code> : (10진수) unsigned long long int (8, 16진수) unsigned long long int</li></ul><ul id="cb883053-6ef6-49b6-a74b-9c7fac941c7f" class="bulleted-list"><li style="list-style-type:circle"><code>l, L</code> : (10진수) long long int (8, 16진수) long long int, unsigned long long int</li></ul><ul id="df546b23-046f-4f0c-b025-d93658a96519" class="bulleted-list"><li style="list-style-type:circle"><code>ll, LL</code> : (10진수) long long int (8, 16진수) long long int, unsigned long long int</li></ul><ul id="79408601-9f2e-479f-a3fc-1326012e2e3a" class="bulleted-list"><li style="list-style-type:circle"><code>ull, ULL</code> : (10진수) unsigned long long int (8, 16진수) unsigned long long int</li></ul></li></ul><h3 id="1a549a0b-0db6-418e-92c6-f69395d186dd" class="">long long int의 서식 문자</h3><pre id="27ac34a6-2b85-44f7-af82-41a92439210b" class="code"><code>long long big_num1 = 9223372036854775807;
long long int big_num2 = 18446744073709551615ULL;

printf(&quot;big_num1: %lli\n&quot;, big_num1);
printf(&quot;big_num2: %llu\n&quot;, big_num2);</code></pre><ul id="912729ee-41a5-4c93-9399-7d1e7f77e97e" class="bulleted-list"><li style="list-style-type:disc">부호있는 경우 : <code>%lli</code></li></ul><ul id="03a44225-0e4c-4fcd-a897-e0605a25048f" class="bulleted-list"><li style="list-style-type:disc">부호없는 경우 : <code>%llu</code></li></ul><h2 id="71b05429-2daa-40a7-81ac-4d4e51cf578a" class="">새로운 자료형 :  불형</h2><ul id="dfc5d1cf-4ebd-4d40-bbc5-3246e5951e9e" class="bulleted-list"><li style="list-style-type:disc">드디어  C99에 참과 거짓을 담는 자료형이 나옴<ul id="b0808349-da4f-4816-9790-f0e2b3871367" class="bulleted-list"><li style="list-style-type:circle">더 이상 <code>#define TRUE (1)</code> 이런거 안해도 됨</li></ul></li></ul><ul id="1ab7e737-152b-4189-aee8-b29caa8ee51c" class="bulleted-list"><li style="list-style-type:disc">두 가지 방법이 있음<ul id="81564341-671b-4290-a955-842b05e13b8e" class="bulleted-list"><li style="list-style-type:circle"><code>_Bool</code></li></ul><ul id="28005d5f-9e8d-4ad5-b3a7-20381fd3e8ee" class="bulleted-list"><li style="list-style-type:circle"><code>bool</code> : 헤더 인클루드 필요</li></ul></li></ul><h3 id="092774a5-8c0e-45a9-a138-920682afbcd7" class="">_Bool</h3><ul id="4e146e74-675d-41c0-a03d-64c77bc6f28a" class="bulleted-list"><li style="list-style-type:disc">거짓이면 0, 참이면 1</li></ul><ul id="9ae37f8f-2150-4eec-994a-ef46096d1b30" class="bulleted-list"><li style="list-style-type:disc"><code>char</code>/<code>int</code>/<code>float</code>과 같은 값을<code> _Bool</code>에 넣을 경우<ul id="dab1d2d0-6229-4b93-bafa-50533e1c3ef5" class="bulleted-list"><li style="list-style-type:circle"><code>0</code>에 해당하는 값이면 <code>0</code></li></ul><ul id="da264a51-1aea-4ee3-a521-952840d6ced3" class="bulleted-list"><li style="list-style-type:circle">그 외의 값은 <code>1</code>로 변환</li></ul></li></ul><ul id="cf000858-6b45-48bc-9dd9-601137873bed" class="bulleted-list"><li style="list-style-type:disc">여전히 참과 거짓은 숫자로 표현</li></ul><pre id="0ae7196c-e543-4a82-b8ea-20dc4e407f09" class="code"><code>_Bool is_active = 10;
printf(&quot;%d&quot;, is_active); // 1 출력</code></pre><pre id="a3132510-a85b-479c-9042-3abf4bd1e76d" class="code"><code>_Bool is_student(const char* id)
{
	if (id[0] == &#x27;t&#x27;) {
		return 0;
	}
	
	return 1;
}</code></pre><h3 id="4515d5de-15ac-46b4-979d-e0e6338a07e9" class="">bool, true, false</h3><ul id="b4b53629-4cb6-447b-99f8-90bb2e91856a" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdbool.h&gt;</code> 헤더에 정의(<code>#define</code>)되어 있음</li></ul><ul id="bb064d5a-55fe-4eb3-9363-1f5aca25f835" class="bulleted-list"><li style="list-style-type:disc"><code>bool</code> : <code>_Bool</code>을 다시 정의</li></ul><ul id="ec5af1ee-2c80-493a-9af3-31dd8401b9d3" class="bulleted-list"><li style="list-style-type:disc"><code>true</code> : 1로 정의</li></ul><ul id="8b787980-cd88-443d-94ad-871fb6f29392" class="bulleted-list"><li style="list-style-type:disc"><code>false</code> : 0으로 정의</li></ul><pre id="83f6ce5c-8cdd-439e-8165-18c8503dc24e" class="code"><code>#include &lt;stdbool.h&gt;

bool is_student(const char* id)
{
	if (id[0] == &#x27;t&#x27;) {
		return false;
	}
	
	return true;
}

bool is_valid_id = is_student(id)</code></pre><h3 id="4f990778-0ce9-4e41-8574-e90170d84761" class="">왜 _Bool은 기본이고, bool은 헤더를 인클루드 해야할까</h3><ul id="2723a6d4-43aa-442b-a07e-95d2d3683e37" class="bulleted-list"><li style="list-style-type:disc">C를 만든 사람들이 <code>bool</code>을 추가하려고 함</li></ul><ul id="89a3fc4e-aa39-4b89-b112-dacffbc569d4" class="bulleted-list"><li style="list-style-type:disc">그러나 이미 많은 프로젝트에서 자체적으로 <code>bool</code>을 정의해서 사용 중이었음<pre id="1636e9b4-5f3f-4829-9bfc-89de1e917e03" class="code"><code>typedef unsigned int bool;
#define TRUE (0)
#define FALSE (1)</code></pre><pre id="10fc119f-6474-41b3-9bf0-bf8bc773bb95" class="code"><code>typedef enum {
	false,
	true
} bool;</code></pre></li></ul><ul id="e6f14ce5-bfc7-4cda-928a-6f2e4c2aecce" class="bulleted-list"><li style="list-style-type:disc">개발자들이 자체적으로 만든 <code>bool</code>과 충돌나기 때문에 <code>bool</code>을 기본으로 넣을 수가 없었음</li></ul><ul id="e4cca98d-cffb-4c53-a01f-5c4f45eeb518" class="bulleted-list"><li style="list-style-type:disc">그래서 충돌나지 않게 <code>_Bool</code>을 만듦</li></ul><ul id="25be7ea5-1c86-4a18-a057-308d89394242" class="bulleted-list"><li style="list-style-type:disc">그러나 원래 만드려고 했던 것이 <code>bool</code>이었기에 <code>&lt;stdbool.h&gt;</code>를 만들어 그곳에 <code>bool</code>, <code>true</code>, <code>false</code>를 모두 넣어둠</li></ul><ul id="3bb9ab6a-a24b-45e5-8b30-507f9a22e604" class="bulleted-list"><li style="list-style-type:disc">그래서 자체적으로 만든 불형이 없다면 이 헤더를 인클루드해서 <code>bool</code>을 쓰는 것을 권장</li></ul><h2 id="0194f06a-467f-4588-8525-15d368c38915" class="">새로운 정수형 : 고정 폭 정수형</h2><h3 id="d5a2e899-eff1-4f56-8e22-bd2c9949f730" class="">기본 자료형들의 크기</h3><ul id="513a5360-7bda-4b5f-b699-6128fbbb8982" class="bulleted-list"><li style="list-style-type:disc"><code>char</code> : 최소 8비트</li></ul><ul id="fcbf4c11-af95-40f7-8998-7f7c3553e831" class="bulleted-list"><li style="list-style-type:disc"><code>short</code> : 최소 16비트 (단, <code>char</code> 이상의 크기)</li></ul><ul id="5c01e609-7484-493a-a76d-d5825e0dce5f" class="bulleted-list"><li style="list-style-type:disc"><code>int</code> : 최소 16비트 (단, <code>short</code> 이상의 크기)</li></ul><ul id="517fed4f-a3d7-47fd-a549-5e662d210902" class="bulleted-list"><li style="list-style-type:disc"><code>long</code> : 최소 32비트 (단, <code>int</code> 이상의 크기)</li></ul><ul id="e4f3dba3-6a81-4ac5-ab43-6a928c36152c" class="bulleted-list"><li style="list-style-type:disc"><code>long long</code> : 최소 64비트 (단, <code>long</code> 이상의 크기)</li></ul><h3 id="ebe6dc84-2c9f-4b06-80f7-07d1947c1f88" class="">문제점 : 같은 자료형인데 크기가 다름</h3><ul id="8538da5f-1df0-4b44-8722-64656a48e354" class="bulleted-list"><li style="list-style-type:disc"><code>int</code>형을 32비트라 가정하고 코딩해놓으면 16비트인 곳에서 문제</li></ul><ul id="1d0cec2e-3102-4886-a3e4-bd1a3aa15bb8" class="bulleted-list"><li style="list-style-type:disc">이런 문제를 해결할 수 있는 방법<ul id="e21d035f-be86-4c81-ab7e-03bb3a678cc9" class="bulleted-list"><li style="list-style-type:circle">정수형의 크기가 고무줄이 아니면 됨</li></ul><ul id="9c0342c2-d6dd-4ae5-99a0-309f7f8e943c" class="bulleted-list"><li style="list-style-type:circle">그러면 프로그램을 어느 플랫폼으로 포팅하더라도 문제 없음</li></ul></li></ul><h3 id="a652f40c-400b-47e9-ab11-8c336af61001" class="">고정 폭 정수형(fixed-width integer type)</h3><ul id="9aebfa27-b42a-4bd6-8160-37a410614d3a" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdint.h&gt;</code> 헤더에 정의되어 있음</li></ul><ul id="015b6f35-9a0c-418b-9e56-49bcd6f06f91" class="bulleted-list"><li style="list-style-type:disc"><code>int8_t</code> / <code>uint8_t</code></li></ul><ul id="ea69ad63-30f5-49e2-a4d3-a6975ad72046" class="bulleted-list"><li style="list-style-type:disc"><code>int16_t</code> / <code>uint16_t</code></li></ul><ul id="f08c554c-0e95-4abe-be36-2fbe8e8fc166" class="bulleted-list"><li style="list-style-type:disc"><code>int32_t</code> / <code>uint32_t</code></li></ul><ul id="c78dd755-adda-4016-8cba-26a1d774c6c1" class="bulleted-list"><li style="list-style-type:disc"><code>int64_t</code> / <code>uint64_t</code></li></ul><h3 id="f52d20e8-3f94-4c86-aa1a-889a52795941" class="">최솟값과 최댓값</h3><ul id="1fff09a1-3c58-41c9-a821-7828f0fb3679" class="bulleted-list"><li style="list-style-type:disc">최솟값<ul id="17d4469a-0804-4ee1-a6fe-8359b7a140c5" class="bulleted-list"><li style="list-style-type:circle"><code>INT8_MIN</code></li></ul><ul id="39b056f0-16a9-4923-ada0-de5883d5b351" class="bulleted-list"><li style="list-style-type:circle"><code>INT16_MIN</code></li></ul><ul id="632ed17f-a7af-4a9f-9e6b-db13892078e4" class="bulleted-list"><li style="list-style-type:circle"><code>INT32_MIN</code></li></ul><ul id="efe6e6db-30fc-4bc0-9fde-0c13e5b65c51" class="bulleted-list"><li style="list-style-type:circle"><code>INT64_MIN</code></li></ul></li></ul><ul id="0cbfe914-6d0e-4b78-85ed-ad2b6e121df4" class="bulleted-list"><li style="list-style-type:disc">최댓값<ul id="b1615fe2-c247-4140-ae0d-c9585971ff2f" class="bulleted-list"><li style="list-style-type:circle"><code>INT8_MAX</code> / <code>UINT8_MAX</code></li></ul><ul id="d6cb2b4e-a6de-4b3d-9f11-11d50b222e68" class="bulleted-list"><li style="list-style-type:circle"><code>INT16_MAX</code> / <code>UINT16_MAX</code></li></ul><ul id="63ac7d0b-bd7b-4fcc-80a3-53ad68046719" class="bulleted-list"><li style="list-style-type:circle"><code>INT32_MAX</code> / <code>UINT32_MAX</code></li></ul><ul id="35d9d858-ce3d-4f10-8ff1-4ef7cef0ef2a" class="bulleted-list"><li style="list-style-type:circle"><code>INT64_MAX</code> / <code>UINT64_MAX</code></li></ul></li></ul><h2 id="8c62a790-5b99-4c52-9d41-dfd18891cb97" class="">새로운 자료형 : 허수를 표현하는 자료형</h2><h3 id="c0f4d647-a486-41e5-bbf4-d56713daebf6" class="">허수</h3><ul id="fa994436-ea86-4149-ad8f-dfbcd7a8884f" class="bulleted-list"><li style="list-style-type:disc">수학에는 허수라는 것이 있음<ul id="2f548348-d31d-4ce9-9190-272734358f07" class="bulleted-list"><li style="list-style-type:circle">영어로 imaginary number</li></ul><ul id="03a06d02-ea7b-44c1-ad85-b05454fade91" class="bulleted-list"><li style="list-style-type:circle">수학 기호로는 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span></span><span>﻿</span></span></li></ul><ul id="493197ce-5e7f-4723-8829-48de4e9deb29" class="bulleted-list"><li style="list-style-type:circle"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i^2 = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span><span>﻿</span></span>를 만족하는 수</li></ul><ul id="0675d6e5-aa3c-4bfd-89c8-26c2c84400e4" class="bulleted-list"><li style="list-style-type:circle">간단히 말하면 현실에 존재하지 않음</li></ul></li></ul><ul id="c6c7dae5-90a6-4c98-8e8d-f503facc51e9" class="bulleted-list"><li style="list-style-type:disc">이러한 허수와 실수로 이루어진 수를 복소수라고 함<ul id="98d54eea-1e01-491d-aa4c-834219a6e3d7" class="bulleted-list"><li style="list-style-type:circle">영어로 complex number</li></ul></li></ul><h3 id="02b146c2-0e55-4d79-be53-c98c9fbc58d1" class="">C99에서부터 허수와 복소수를 표현할 수 있음</h3><p id="7eb1b0da-9c76-4233-bcfa-a18606154b49" class=""><code>_Imginary</code></p><ul id="f803beb4-9c83-4992-94e5-00c17e8c1d78" class="bulleted-list"><li style="list-style-type:disc">허수를 나타내는 키워드</li></ul><ul id="941b357f-fd3a-4a3c-b5bb-090b5f1b4f04" class="bulleted-list"><li style="list-style-type:disc">일부 컴파일러는 지원 안 할 수 있음</li></ul><p id="ba7f4f31-5ecd-4b6b-a497-041f564e571a" class=""><code>_Complex</code></p><ul id="c0777885-3817-4565-8455-0abf8108d1f2" class="bulleted-list"><li style="list-style-type:disc">복소수를 나타내는 키워드</li></ul><ul id="a2852f3d-c4ee-4f41-8c1b-faaae9f214ed" class="bulleted-list"><li style="list-style-type:disc">일부 컴파일러는 다른 이름을 사용할 수 있음</li></ul><p id="31018fe7-5f9f-4b20-93ab-132da209db8a" class=""><strong>각각 자료형이 세 개씩 존재</strong></p><pre id="bfbb0f5a-67eb-4079-af33-a63a276067d6" class="code"><code>float _Imginary
double _Imginary
longl long _Imginary</code></pre><pre id="3e276266-0695-4be9-80b6-e7901477ca1a" class="code"><code>float _Complex
double _Complex
long long _Complex</code></pre><p id="939d05cc-6d5f-40fc-99b7-bf6ef8dc0500" class=""><code>&lt;complex.h&gt;</code></p><ul id="7ce056d5-5999-4a25-9d31-7a5b115ff983" class="bulleted-list"><li style="list-style-type:disc">허수와 복소수와 관련있는 헤더파일</li></ul><ul id="987cddb9-cbdc-4e7e-9465-1957123d97f5" class="bulleted-list"><li style="list-style-type:disc"><code>_Bool</code>과 마찬가지로 <code>_Imaginary</code>와 <code>_Complex</code>를 재정의한 매크로를 제공<pre id="04811389-9c8e-4784-b2d6-dc6a51c0d9dd" class="code"><code>float imaginary
double imaginary
long long imaginary</code></pre><pre id="a5293088-ec7a-4839-9f9f-069a58224612" class="code"><code>float complex
double complex
long long complex</code></pre><ul id="61a61b3b-ce5e-4be0-b0dc-7ae377293ee2" class="bulleted-list"><li style="list-style-type:circle">imaginary를 지원 안 하는 컴파일로도 있음</li></ul><ul id="4394831f-a8d4-44f0-a35e-05d9c2e5da97" class="bulleted-list"><li style="list-style-type:circle">complex를 다른 이름으로 제공하는 컴파일러도 있음</li></ul></li></ul><ul id="a9b0dd20-a93a-43b5-837b-5b0474b874ce" class="bulleted-list"><li style="list-style-type:disc"><code>I</code><ul id="60a79078-b636-4a03-9723-b2077d2e5e3e" class="bulleted-list"><li style="list-style-type:circle">허수부에서 사용하는 <style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.2/katex.min.css')</style><span data-token-index="0" contenteditable="false" class="notion-text-equation-token" style="user-select:all;-webkit-user-select:all;-moz-user-select:all"><span></span><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span></span><span>﻿</span></span></li></ul></li></ul><ul id="f4f135cd-507c-410d-afc4-02834abac7e0" class="bulleted-list"><li style="list-style-type:disc">허수, 복소수와 관련된 유틸리티 함수 제공<ul id="8198a0a6-fe3d-4323-8d50-415982c386ae" class="bulleted-list"><li style="list-style-type:circle"><code>cabs()</code> : 복소수의 절댓값 반환</li></ul><ul id="e7f1b639-67d0-42f7-908d-29a106080c31" class="bulleted-list"><li style="list-style-type:circle"><code>creal()</code> : 복소수의 실수부 반환</li></ul><ul id="6cc3d2f6-f117-4c2b-b947-16d5f9f156d0" class="bulleted-list"><li style="list-style-type:circle"><code>cimag()</code> : 복소수의 허수부 반환</li></ul><ul id="0ace9920-f7cb-4309-b9fb-f3446a626485" class="bulleted-list"><li style="list-style-type:circle"><code>csin()</code> : 복소수의 사인 반환</li></ul><ul id="ac3ff9e0-49b9-41c8-98f6-d89f2c3ac381" class="bulleted-list"><li style="list-style-type:circle"><code>ccos()</code> : 복소수의 코사인 반환</li></ul><ul id="02241386-82bf-4324-b3ef-0128c5c5b632" class="bulleted-list"><li style="list-style-type:circle"><code>ctan()</code> : 복소수의 탄젠트 반환</li></ul><ul id="bfb4fb6a-53a9-4330-bee4-17345f46976f" class="bulleted-list"><li style="list-style-type:circle">그 외에도 많은 함수들이 있음</li></ul></li></ul><h2 id="d722079a-0d8f-4a9b-87b5-f96884c23ed8" class="">IEEE 754 부동 소수점 지원</h2><ul id="ab254bb5-ca8f-4ad0-8931-b6fa72583496" class="bulleted-list"><li style="list-style-type:disc">C99의 주요 기능 중 하나라 할 수 있음</li></ul><ul id="617c4f61-d778-46c7-a662-c0d4efd25686" class="bulleted-list"><li style="list-style-type:disc"><code>float</code>은 IEEE 754 32비트 부동 소수점</li></ul><ul id="5c99680f-f845-4066-82c1-8ce662c8b732" class="bulleted-list"><li style="list-style-type:disc"><code>double</code>은 IEEE 754 64비트 부동 소수점</li></ul><ul id="02a87f8b-2ce3-4220-a4c2-5a316830385a" class="bulleted-list"><li style="list-style-type:disc"><code>long double</code>은 IEEE 754 확장 정밀도(extended precisiopn) 부동 소수점</li></ul><ul id="0a7d6058-0577-44dd-889a-843cabb4649f" class="bulleted-list"><li style="list-style-type:disc">사칙 연산과 제곱근의 올림을 IEEE 754에서 정의한대로 처리</li></ul><h2 id="a7017a09-5a44-42e3-bff1-d1c3381173a6" class="">부동 소수점 예외</h2><h3 id="963e2ba6-baef-403c-81c7-1e83d1c00ecd" class=""> C99 이전의 부동 소수점 연산 오류 처리</h3><ul id="6c259538-a6b2-4856-bc81-244cb198d068" class="bulleted-list"><li style="list-style-type:disc">부동 소수점 연산 중 오류가 날 경우 그 이유를 오류 조건이라 함</li></ul><ul id="6c2f2960-64a3-4e9b-86e5-976125821fc8" class="bulleted-list"><li style="list-style-type:disc">C 라이브러리 함수가 오류 조건을 보고하는 경우가 있음</li></ul><ul id="259cce07-03b2-4aed-9323-49b01522c32d" class="bulleted-list"><li style="list-style-type:disc">이 오류 조건의 일부는 <code>errno</code>을 통해 확인 가능<ul id="24f940f0-6939-47f5-a33b-87449843ffb7" class="bulleted-list"><li style="list-style-type:circle">인자가 수학적으로 정의된 범위를 벗어날 경우 : <code>EDOM</code></li></ul><ul id="2e086085-6e03-4ae9-8a05-6d25a95aa709" class="bulleted-list"><li style="list-style-type:circle">오버플로가 발생한 경우 : <code>ERANGE</code></li></ul><ul id="d5f22c35-8a15-4d3a-93c2-56773546ecc5" class="bulleted-list"><li style="list-style-type:circle">언더플로가 발생한 경우 : <code>ERANGE</code>가 설정될 수도 있음 (구현에 따라 가능)</li></ul></li></ul><h3 id="e0c0d810-4e92-42a6-a5d5-a1cb764a01ac" class="">C99의 부동 소수점 연산 오류 처리</h3><ul id="625dd72c-cc9a-4141-a020-7fded08dc4ed" class="bulleted-list"><li style="list-style-type:disc">좀 더 세분화된 부동 소수점 전용 오류 보고 기능 추가<ul id="ed0cccf3-be30-442c-aa99-3adcfcfd1ed9" class="bulleted-list"><li style="list-style-type:circle">이것을 &#x27;부동 소수점 예외&#x27;라고 부름</li></ul><ul id="42e85350-a011-4608-a86c-5ca19b23eb7f" class="bulleted-list"><li style="list-style-type:circle">예외라고 하지만 다른 언어에서 말하는 예외는 아님</li></ul><ul id="ad9f9937-485e-47d5-97ed-e672776d6c72" class="bulleted-list"><li style="list-style-type:circle">그냥 다른 형태의 오류 코드</li></ul></li></ul><ul id="20bd06bb-a32b-44c3-ae4f-5884b2dd0aef" class="bulleted-list"><li style="list-style-type:disc"><code>errno</code>에서 찾을 수 없던 오류 조건도 보고됨</li></ul><ul id="5377c143-3950-4d8c-88b4-8d333e97ac4a" class="bulleted-list"><li style="list-style-type:disc">구현에 따라 다음 중 하나를 지원<ul id="54e0a90f-2dec-45a7-9768-3e6f76e4e7d5" class="bulleted-list"><li style="list-style-type:circle">여전히 <code>errno</code>을 사용</li></ul><ul id="47cc289b-6090-44f4-9833-4aa713fbe14f" class="bulleted-list"><li style="list-style-type:circle">새로운 부동 소수점 예외를 사용</li></ul><ul id="cb0b219b-3f6f-4e79-99a3-3813fb5c1570" class="bulleted-list"><li style="list-style-type:circle">둘 다 지원</li></ul></li></ul><h3 id="b9b3ba34-ff67-45d5-94e4-aaf2fea83523" class="">부동 소수점 연산 오류 처리방법 확인하기</h3><ul id="4814fcec-7586-4a98-9af1-e7d75460c811" class="bulleted-list"><li style="list-style-type:disc">구현에 따라 정의된 <code>math_errhandling</code> 비트 플래그를 확인<p id="a4370aa5-6981-4ec7-b1eb-5bcb9981495d" class="">1) 여전히 <code>errno</code>을 사용 : <code>MATH_ERRNO</code> 플래그가 설정되어 있음</p><p id="bc8afd2b-5af0-4bca-bad2-648438cc6567" class=""><code>#define MATH_ERRNO        1</code></p><p id="99d7dacb-0ecd-4725-ab42-8c0f96927264" class="">2) 부동 소수점 예외를 사용 : <code>MATH_ERREXCEPT</code> 플래그</p><p id="53eb18f8-68d5-41b6-963d-c4d7e69f2fae" class=""><code>#define MATH_ERREXCEPT        2</code></p><p id="79efec75-a02d-453d-b626-e39409428ba5" class="">3) 둘 다 지원 : 둘 다 설정되어 있음</p></li></ul><ul id="baeecc2b-cd10-42f2-a7ac-7b1f1eb00f4d" class="bulleted-list"><li style="list-style-type:disc">다음이 참이면 IEEE 부동소수점 연산(,IEC 60559)을 지원하는 구현<p id="f0685f4b-6629-4bf6-bb6a-ef518436a7b8" class=""><code>math_errhandling &amp; MATH_ERREXCEPT</code></p></li></ul><h3 id="bf50f23d-062e-4d68-abe0-0156a7d78a25" class="">부동 소수점 예외</h3><ul id="8fc832cd-ddd0-4b55-ad6b-3ca9c486fdb8" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;fenv.h&gt;</code> 헤더에 정의되어 있음</li></ul><ul id="c7b64565-7845-4df9-a346-506d04cb1728" class="bulleted-list"><li style="list-style-type:disc">실제 정의된 정수값은 각 구현마다 다름</li></ul><ul id="7d5fcc84-9c7f-4576-a4af-b71ec0e2c030" class="bulleted-list"><li style="list-style-type:disc">단, 비트 플래그를 쓸 수 있도록 2의 승수여야 함</li></ul><pre id="2c524d1e-0869-47c2-8867-cc20238e8b0b" class="code"><code>#define FE_DIVBYZERO       /* 2의 승수 어떤 값 */
#define FE_INEXACT         /* 2의 승수 어떤 값 */
#define FE_INVALID         /* 2의 승수 어떤 값 */
#define FE_OVERFLOW        /* 2의 승수 어떤 값 */
#define FE_UNDERFLOW       /* 2의 승수 어떤 값 */
#define FE_ALL_EXCPET      /* 2의 승수 어떤 값 */
															FE_DIVBYZERO | FE_INEXACT | \
															FE_INVALID | FE_OVERFLOW |  \
															FE_UNDEERFLOW</code></pre><h3 id="90522191-1ae1-4881-af4d-01248ecb2f04" class="">errno과 부동 소수점 예외의 비교</h3><div id="f259b204-bba9-4325-8d38-a52700ef8e6e" class="collection-content"><h4 class="collection-title"></h4><table class="collection-content"><thead><tr><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesTitle"><path d="M7.73943662,8.6971831 C7.77640845,8.7834507 7.81338028,8.8943662 7.81338028,9.00528169 C7.81338028,9.49823944 7.40669014,9.89260563 6.91373239,9.89260563 C6.53169014,9.89260563 6.19894366,9.64612676 6.08802817,9.30105634 L5.75528169,8.33978873 L2.05809859,8.33978873 L1.72535211,9.30105634 C1.61443662,9.64612676 1.2693662,9.89260563 0.887323944,9.89260563 C0.394366197,9.89260563 0,9.49823944 0,9.00528169 C0,8.8943662 0.0246478873,8.7834507 0.0616197183,8.6971831 L2.46478873,2.48591549 C2.68661972,1.90669014 3.24119718,1.5 3.90669014,1.5 C4.55985915,1.5 5.12676056,1.90669014 5.34859155,2.48591549 L7.73943662,8.6971831 Z M2.60035211,6.82394366 L5.21302817,6.82394366 L3.90669014,3.10211268 L2.60035211,6.82394366 Z M11.3996479,3.70598592 C12.7552817,3.70598592 14,4.24823944 14,5.96126761 L14,9.07922535 C14,9.52288732 13.6549296,9.89260563 13.2112676,9.89260563 C12.8169014,9.89260563 12.471831,9.59683099 12.4225352,9.19014085 C12.028169,9.6584507 11.3257042,9.95422535 10.5492958,9.95422535 C9.60035211,9.95422535 8.47887324,9.31338028 8.47887324,7.98239437 C8.47887324,6.58978873 9.60035211,6.08450704 10.5492958,6.08450704 C11.3380282,6.08450704 12.040493,6.33098592 12.4348592,6.81161972 L12.4348592,5.98591549 C12.4348592,5.38204225 11.9172535,4.98767606 11.1285211,4.98767606 C10.6602113,4.98767606 10.2411972,5.11091549 9.80985915,5.38204225 C9.72359155,5.43133803 9.61267606,5.46830986 9.50176056,5.46830986 C9.18133803,5.46830986 8.91021127,5.1971831 8.91021127,4.86443662 C8.91021127,4.64260563 9.0334507,4.44542254 9.19366197,4.34683099 C9.87147887,3.90316901 10.6232394,3.70598592 11.3996479,3.70598592 Z M11.1778169,8.8943662 C11.6830986,8.8943662 12.1760563,8.72183099 12.4348592,8.37676056 L12.4348592,7.63732394 C12.1760563,7.29225352 11.6830986,7.11971831 11.1778169,7.11971831 C10.5616197,7.11971831 10.056338,7.45246479 10.056338,8.0193662 C10.056338,8.57394366 10.5616197,8.8943662 11.1778169,8.8943662 Z M0.65625,11.125 L13.34375,11.125 C13.7061869,11.125 14,11.4188131 14,11.78125 C14,12.1436869 13.7061869,12.4375 13.34375,12.4375 L0.65625,12.4375 C0.293813133,12.4375 4.43857149e-17,12.1436869 0,11.78125 C-4.43857149e-17,11.4188131 0.293813133,11.125 0.65625,11.125 Z"></path></svg></span>오류 종류</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>설명</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>errno</th><th><span class="icon property-icon"><svg viewBox="0 0 14 14" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.4);flex-shrink:0;-webkit-backface-visibility:hidden" class="typesText"><path d="M7,4.56818 C7,4.29204 6.77614,4.06818 6.5,4.06818 L0.5,4.06818 C0.223858,4.06818 0,4.29204 0,4.56818 L0,5.61364 C0,5.88978 0.223858,6.11364 0.5,6.11364 L6.5,6.11364 C6.77614,6.11364 7,5.88978 7,5.61364 L7,4.56818 Z M0.5,1 C0.223858,1 0,1.223858 0,1.5 L0,2.54545 C0,2.8216 0.223858,3.04545 0.5,3.04545 L12.5,3.04545 C12.7761,3.04545 13,2.8216 13,2.54545 L13,1.5 C13,1.223858 12.7761,1 12.5,1 L0.5,1 Z M0,8.68182 C0,8.95796 0.223858,9.18182 0.5,9.18182 L11.5,9.18182 C11.7761,9.18182 12,8.95796 12,8.68182 L12,7.63636 C12,7.36022 11.7761,7.13636 11.5,7.13636 L0.5,7.13636 C0.223858,7.13636 0,7.36022 0,7.63636 L0,8.68182 Z M0,11.75 C0,12.0261 0.223858,12.25 0.5,12.25 L9.5,12.25 C9.77614,12.25 10,12.0261 10,11.75 L10,10.70455 C10,10.4284 9.77614,10.20455 9.5,10.20455 L0.5,10.20455 C0.223858,10.20455 0,10.4284 0,10.70455 L0,11.75 Z"></path></svg></span>부동 소수점 예외</th></tr></thead><tbody><tr id="42541356-e7fe-4cdd-98f3-c56ed0b12cd5"><td class="cell-title"><a href="https://www.notion.so/42541356e7fe4cdd98f3c56ed0b12cd5">도메인 오류</a></td><td class="cell-hxSc">인자가의 범위가 수학적으로 정의된 것의 밖임</td><td class="cell-~~Cv">EDOM</td><td class="cell-wZbP">FE_INVALID</td></tr><tr id="f94dcfd2-2531-47d7-b1d9-cb620a54128a"><td class="cell-title"><a href="https://www.notion.so/f94dcfd2253147d7b1d9cb620a54128a">극한 오류</a></td><td class="cell-hxSc">함수의 수학연산 결과가 무한이거나 정의되지 않음</td><td class="cell-~~Cv">ERANGE</td><td class="cell-wZbP">FE_DIVBYZERO</td></tr><tr id="aaaef8da-4452-4217-86e6-c2c2f199d836"><td class="cell-title"><a href="https://www.notion.so/aaaef8da4452421786e6c2c2f199d836">오버플로</a></td><td class="cell-hxSc">(생략)</td><td class="cell-~~Cv">ERANGE</td><td class="cell-wZbP">FE_OVERFLOW</td></tr><tr id="e974f73b-91bc-4252-9ff7-8a77e1273e4f"><td class="cell-title"><a href="https://www.notion.so/e974f73b91bc42529ff78a77e1273e4f">언더플로</a></td><td class="cell-hxSc">(생략)</td><td class="cell-~~Cv">ERANGE일 수도 아닐 수도</td><td class="cell-wZbP">FE_UNDERFLOW일 수도 아닐 수도</td></tr><tr id="5d1a31bb-8d5d-486d-89d1-19765fb66ab8"><td class="cell-title"><a href="https://www.notion.so/5d1a31bb8d5d486d89d119765fb66ab8">정확하지 않은 값</a></td><td class="cell-hxSc">저자아될 자료형에 맞게 올림처리 해야함</td><td class="cell-~~Cv">-</td><td class="cell-wZbP">FE_INEXACT 일 수도 아닐 수도</td></tr></tbody></table></div><h3 id="f378493e-612d-402a-9107-80da89de302c" class="">부동 소수점 예외가 났는지 확인하는 법</h3><pre id="42860011-96ea-4f9f-b15d-a8c7b592cb06" class="code"><code>int fetestexcept(int excpets);</code></pre><ul id="c929dcb8-d202-4654-a9f3-62706a4efc7c" class="bulleted-list"><li style="list-style-type:disc">excepts로 지정된 비트 플래그들이 설정되었는지 확인</li></ul><pre id="08cdc827-f0f9-493f-ad86-aff8bc9cf43c" class="code"><code>int fecelarexcept(int excpets);</code></pre><ul id="2234db4e-c222-4d99-8b99-b336efeb2daa" class="bulleted-list"><li style="list-style-type:disc">excepts로 지정한 비트 플래그들이 상태를 지움</li></ul><pre id="9eb152cf-e671-4706-a1a4-08d5554d3589" class="code"><code>float div_by_zero = 1.f / 0.f;
if (fetestexcept(FE_DIVBYZERO)) {
	puts(&quot;FE_DIVBYZERO&quot;);
}
feclearexcept(FE_ALL_EXCEPT);</code></pre><pre id="e9eb5183-3981-4344-aa86-1a04a3a247fe" class="code"><code>double div_by_zero = 1.0 / 10.0;
if (fetestexcept(FE_INEXACT)) {
	puts(&quot;FE_INEXACT&quot;);
}
feclearexcept(FE_ALL_EXCEPT);</code></pre><h3 id="b3d8757d-eff1-46f7-8381-3e4cd0ab0f59" class="">부동 소수점 예외를 설정해줄 수도 있음</h3><pre id="9aa45c61-f896-444c-ad57-fa1409247f26" class="code"><code>int feraiseexcept(int excpets);</code></pre><ul id="639e49e7-88de-4c89-8fba-c3d3515c7365" class="bulleted-list"><li style="list-style-type:disc">부동 소수점 매개변수를 받는 함수 구현 중 오류를 보고할 때 유용</li></ul><ul id="8ad7406b-53d0-4a2a-86e3-14d32d7ca4c6" class="bulleted-list"><li style="list-style-type:disc">그러나 오류 코드를 전역 변수에 설정하는 방식<ul id="feb9b6d3-32a7-4bac-b8ec-55c4930bbbe8" class="bulleted-list"><li style="list-style-type:circle">가독성이 그리 좋지 않음</li></ul><ul id="e05649dc-e698-4383-a20a-0f4b67ba0ff5" class="bulleted-list"><li style="list-style-type:circle">전역적으로 오류 코드가 설정된다는 사실을 호출자가 모르기 쉬움</li></ul></li></ul><ul id="19e64ce1-59e1-4be0-a340-ed55dc4dae5a" class="bulleted-list"><li style="list-style-type:disc">이 외에 함수에서 오류 코드를 직접 반환하는 방법도 고려할 것</li></ul><h3 id="eacaec4c-9226-4f1b-b8e4-611d2da88bf2" class="">부동 소수점 연산 환경도 설정 가능</h3><ul id="0a37a92c-6cce-430a-b54d-647ea6a402fe" class="bulleted-list"><li style="list-style-type:disc">역시 <code>&lt;fenv.h&gt;</code>에 들어 있는 함수들을 이용<ul id="89417438-af96-43a9-aa6b-f45c48543498" class="bulleted-list"><li style="list-style-type:circle"><code>fegetroung();</code></li></ul><ul id="03222ed5-935a-484c-b601-63eb3a030e3b" class="bulleted-list"><li style="list-style-type:circle"><code>fesetroung();</code></li></ul><ul id="2338d597-4c65-47fb-8d30-8b360bec0bc2" class="bulleted-list"><li style="list-style-type:circle"><code>fegetenv();</code></li></ul><ul id="dd755663-293e-4c93-8caa-29f9dbd41088" class="bulleted-list"><li style="list-style-type:circle"><code>fesetenv();</code></li></ul><ul id="136f3cbd-2d0e-418c-b4a6-037d5712baf7" class="bulleted-list"><li style="list-style-type:circle"><code>feholdexcpet();</code></li></ul><ul id="b478325e-95bb-48a0-8a07-76dc4981a279" class="bulleted-list"><li style="list-style-type:circle"><code>feupdateenv();</code></li></ul></li></ul><h3 id="6cf0f154-2b17-4efb-87f8-9eb1e7e489f9" class="">하지만 지원여부는 불확실!!</h3><ul id="8c26e4e2-16ac-4fd8-bf60-0ab8475fd549" class="bulleted-list"><li style="list-style-type:disc">다음 <code>#pragma</code>를 사용해야만 작동<p id="afe9693c-3c6d-47a3-9652-967d1c32a3b9" class="">⇒ <code>#pragma</code> : 컴파일러마다 별로도 지원하는 특별한 기능을 켜고 끄는 방법 중 하나</p><pre id="f05aa793-9b5a-4eb3-88c6-ca7315f0a6d9" class="code"><code>#include &lt;fenv.h&gt;

#pragma STDC FENV_ACCESS ON</code></pre><pre id="af27c48f-55a9-41a0-a1e3-ca8fb4b16e9f" class="code"><code>float div_by_zero = 1.f / 0.f;
if (fetestexcept(FE_DIVBYZERO)) {
	puts(&quot;FE_DIVBYZERO&quot;);
}
feclearexcept(FE_ALL_EXCEPT);</code></pre></li></ul><ul id="72d5ee07-1416-43d8-b854-cbd1a4626a99" class="bulleted-list"><li style="list-style-type:disc">위 <code>#pragma</code>를 넣으면 대부분 컴파일러에서 컴파일 오류</li></ul><ul id="e1c5eb7e-3306-4072-ac64-58a35a12cc8c" class="bulleted-list"><li style="list-style-type:disc">각 컴파일러마다 다른 방식으로 부동 소수점 환경을 지원</li></ul><h2 id="72f0cc2a-bb60-48fc-afd6-ca9997e23dc2" class="">Type-Generic 수학</h2><ul id="bc2880e8-ed81-448e-94c8-574822617829" class="bulleted-list"><li style="list-style-type:disc">제네릭(generic)이란 보통 둘 중 하나를 의미<p id="94d2288b-85db-490a-9f46-55158cce2318" class="">1) 모든 자료형을 표현할 수 있는 경우 (예: <code>void*</code>)</p><p id="d816fd41-6ff7-4bcc-8564-119bdace8f3a" class="">2) 각 자료형에 맞게 알아서 동작 (예: C#의 <code>List&lt;&gt;</code>)</p></li></ul><ul id="a269df7f-5685-4924-bf87-c676a70fde42" class="bulleted-list"><li style="list-style-type:disc">여기서는 두 번째 의미</li></ul><ul id="5e6c0115-632c-4d16-97c7-435949f1bca7" class="bulleted-list"><li style="list-style-type:disc">수학 함수(<code>math.h</code>) 및 복소수(<code>complex.h</code>)용 제네릭 매ㅡ로 함수<ul id="0f49557a-753f-414a-827f-cf6006fdf82d" class="bulleted-list"><li style="list-style-type:circle">프로그래머는 매크로 함수를 호출</li></ul><ul id="bb964439-2bbd-4ef3-82f9-4366c19cbdfb" class="bulleted-list"><li style="list-style-type:circle">그러면 매개변수의 자료형에 맞는 함수가 최종적으로 호출</li></ul></li></ul><ul id="0523a33e-d1d1-45ac-85ad-6f27e9426361" class="bulleted-list"><li style="list-style-type:disc">이 매크로 함수는 <code>&lt;tgmath.h&gt;</code>에 들어있음</li></ul><h3 id="7bef8833-26b8-4099-b6df-5f93d4e3279e" class="">매크로 함수가 최종적으로 호출하는 함수</h3><ul id="4bc61537-e0f7-416e-b8d4-334fee352e54" class="bulleted-list"><li style="list-style-type:disc">매크로 함수 이름이 XXX라면 최종적으로 호출 되는 함수의 형태는<ul id="70386f85-9db2-45c5-8b7a-22fa6130a2b5" class="bulleted-list"><li style="list-style-type:circle">실수<ul id="e7b2c9e7-a8ec-45c8-803b-f198583f27d2" class="bulleted-list"><li style="list-style-type:square">float : <code>XXXf()</code></li></ul><ul id="803c1800-e043-4e45-b16b-314bb9832421" class="bulleted-list"><li style="list-style-type:square">double : <code>XXX()</code></li></ul><ul id="2a61da24-df4e-46bf-9e58-039d90da72c9" class="bulleted-list"><li style="list-style-type:square">long double : <code>XXXl()</code></li></ul></li></ul><ul id="f93ece96-9e01-4e7c-9886-5ab023713df7" class="bulleted-list"><li style="list-style-type:circle">복소수<ul id="0c2a8082-52b2-43e4-be2b-5b44614b4156" class="bulleted-list"><li style="list-style-type:square">float : <code>cXXXf()</code></li></ul><ul id="43cec23e-e68b-4be8-b5c3-302fc0c3dc06" class="bulleted-list"><li style="list-style-type:square">double : <code>cXXX()</code></li></ul><ul id="ad8f968e-42ba-4f7e-a70b-ab89ea0fcaee" class="bulleted-list"><li style="list-style-type:square">long double : <code>cXXXl()</code></li></ul></li></ul></li></ul><h3 id="bccefec9-cf2b-429d-9b93-e14af5fc0cf3" class="">복소수와 실수를 모두 지원하는 매크로 함수</h3><ul id="5a080945-2657-4fb2-ab2c-9cc9a2413efd" class="bulleted-list"><li style="list-style-type:disc"> 매개변수에 복소수가 하나라도 있으면 복소수용 함수가 호출됨<ul id="a34d8315-fc2a-41da-955b-12957c7fa80d" class="bulleted-list"><li style="list-style-type:circle"><code>fabs()</code></li></ul><ul id="8cb3b2fd-f01a-4b18-ae27-3923bb5c4382" class="bulleted-list"><li style="list-style-type:circle"><code>pow()</code></li></ul><ul id="3b713b2d-0ab0-45c5-91a0-3aaa8c134024" class="bulleted-list"><li style="list-style-type:circle"><code>exp()</code>, <code>log()</code></li></ul><ul id="4b05a5f1-6af1-455c-978f-91931e1aea91" class="bulleted-list"><li style="list-style-type:circle"><code>sin()</code>, <code>cos()</code>, <code>tan()</code></li></ul><ul id="83351e77-b9ae-4ba2-b1c3-8eff758a2a6b" class="bulleted-list"><li style="list-style-type:circle"><code>asine()</code>, <code>acos()</code>, <code>atan()</code></li></ul><ul id="c4f00468-49e3-4fc3-ab30-f760890553ad" class="bulleted-list"><li style="list-style-type:circle">등</li></ul></li></ul><h3 id="d51a8ede-8e4c-4f40-aa9b-6cb5136184ca" class="">실수만 지원하는 매크로 함수</h3><ul id="18feb50d-2b99-4add-8b78-85ce6c002473" class="bulleted-list"><li style="list-style-type:disc">복소수형 매개변수를 넣으면 정의되지 않은 결과<ul id="2f660e75-ff8b-4c55-aebb-8a5f208543a9" class="bulleted-list"><li style="list-style-type:circle"><code>ceil()</code>, <code>floor()</code>, <code>round()</code></li></ul><ul id="e3a6a7f7-beb9-42f9-87e7-3f6c217d7eba" class="bulleted-list"><li style="list-style-type:circle"><code>fmod()</code></li></ul><ul id="ecac0992-cbdc-419c-a48c-4b98c0559f1f" class="bulleted-list"><li style="list-style-type:circle"><code>fmin()</code>, <code>fmax()</code></li></ul><ul id="ab6f8b8f-4d0f-497c-bc81-ce672d3087e0" class="bulleted-list"><li style="list-style-type:circle"><code>exp2()</code>, <code>log2()</code></li></ul><ul id="12850b94-f1d8-4e0d-a0ce-b67bc9a5d77f" class="bulleted-list"><li style="list-style-type:circle">등</li></ul></li></ul><h3 id="ae32c4aa-f3a6-4364-9831-cfb798508640" class="">복소수만 지원하는 매크로 함수</h3><ul id="2d4a6ebb-e63c-478e-81f6-c800412f3a66" class="bulleted-list"><li style="list-style-type:disc">이 경우 매크로 함수 이름은 <code>cXXX</code> 형태<ul id="8c14e00c-4686-44f0-8db8-0b5e171eeb9b" class="bulleted-list"><li style="list-style-type:circle"><code>carg()</code></li></ul><ul id="ac43d1d5-9878-496a-871e-cbdf07e20d12" class="bulleted-list"><li style="list-style-type:circle"><code>conj()</code></li></ul><ul id="9b28c04c-696c-4adc-b720-36bdb00280dd" class="bulleted-list"><li style="list-style-type:circle"><code>creal()</code></li></ul><ul id="8f9169a5-5f53-4cbb-8985-0285b2a3536f" class="bulleted-list"><li style="list-style-type:circle"><code>cimag()</code></li></ul><ul id="e53e16d5-369f-472b-afe5-f04623a0cd41" class="bulleted-list"><li style="list-style-type:circle"><code>cproj()</code></li></ul></li></ul><h3 id="b5022d17-0129-4972-9e23-62c956ebfff7" class="">float, long double, double, int</h3><ul id="9fd8f707-e259-4fcd-90af-035884a12537" class="bulleted-list"><li style="list-style-type:disc">다음 순서로 최종 호출할 함수가 결정됨<p id="5d51ec4a-45be-4175-a868-a7a8ab81eb87" class="">1) 매개변수 중 하나가 <code>long doubl</code>이면 <code>long double</code>용 함수</p><p id="f2b1e98f-8e97-49b5-8cf0-9c0421e41434" class="">2) 매개변수 중 하나가 <code>double</code> 또는 <code>int</code> 면 <code>double</code>용 함수</p><p id="7f7e8f47-70c6-4f37-ab93-f84fbaa7f7f8" class="">3) 그 밖의 경우는 <code>float</code>용 함수</p></li></ul><h2 id="c7c888f2-8857-455b-9180-e30e854aceb2" class="">가변 길이 배열(variable length arrays)</h2><ul id="356197f6-7b34-44c4-96c8-239911bdcec7" class="bulleted-list"><li style="list-style-type:disc">실행 중에 길이(요소수)가 결정되는 배열</li></ul><ul id="96c838a1-6cca-4368-8deb-fb9190a401ce" class="bulleted-list"><li style="list-style-type:disc">흔히 줄여서 <code>VLA</code>라고 부름</li></ul><pre id="46533fc4-eec6-40ee-8bad-9d737eaf8c66" class="code"><code>int n;
scanf(&quot;%d&quot;, &amp;n);
int nums[n];</code></pre><p id="30bfc2b6-dbc9-42a4-9ce0-8cbd1fa2cc09" class="">
</p><h3 id="6a3a6c26-340d-4485-8b74-a7ead428634b" class="">가변 길이 배열에 대한 비판</h3><ul id="76f2c15b-1bed-4589-9f79-081d359cc732" class="bulleted-list"><li style="list-style-type:disc">C99에 나온 이후로 많은 비판을 받음<ul id="b642bc5b-d122-4397-9ab1-c0a5253ad6da" class="bulleted-list"><li style="list-style-type:circle">리누스 토발즈는 &#x27;아주 멍청한 짓&#x27;이라는 말까지 했음</li></ul></li></ul><ul id="80db9dd9-912b-415c-95b2-29b296df9795" class="bulleted-list"><li style="list-style-type:disc">특히 메모리 관리 측면이 문제<ul id="6d40015f-b3aa-4977-86f3-0b056ecbef9c" class="bulleted-list"><li style="list-style-type:circle">C에서 자동적으로 해주긴 함</li></ul><ul id="e6c705bd-1c99-4fd6-bcbe-67615732e9a6" class="bulleted-list"><li style="list-style-type:circle">그러나 그로 인한 성능 저하가 문제</li></ul><ul id="aef07837-7645-42ed-8c7b-e58a80a4011b" class="bulleted-list"><li style="list-style-type:circle">코드에서 곧바로 메모리가 안 보이는 C답지 못한 코드를 양산하게 됨</li></ul></li></ul><ul id="d5a80d46-3272-48f6-9983-aa4763014240" class="bulleted-list"><li style="list-style-type:disc">그 결과 C11에서는 선택사항으로 강등됨<ul id="9e61cf86-74f3-4620-ac38-0913ee755278" class="bulleted-list"><li style="list-style-type:circle">리눅스 커널에서도 2018년에 드디어 <code>VLA</code>를 다 제거함</li></ul></li></ul><ul id="0cb488c1-329f-4328-9f4c-b4aab0a2f7a5" class="bulleted-list"><li style="list-style-type:disc">고로 여기서는 이런게 있다는 정도만 알고 넘어가면 됨!!</li></ul><h3 id="61415fdc-8795-412a-8edc-e61c6f9f2016" class="">가변 길이 배열의 메모리 위치</h3><ul id="c90d7a9e-a83d-438b-9105-bcf13076fa93" class="bulleted-list"><li style="list-style-type:disc">보통 스택에 저장<ul id="c994bb3d-328d-49e5-819f-cb68da792d7a" class="bulleted-list"><li style="list-style-type:circle">그러나 표준은 메모리 위치가 어디여야하는지 강제하지 않음</li></ul><ul id="4f893058-4330-4727-b2c4-4b6211ab1041" class="bulleted-list"><li style="list-style-type:circle">스택일 수도 힙일 수도 있음</li></ul></li></ul><ul id="6f015a40-69cb-4bdb-8157-154df38af33b" class="bulleted-list"><li style="list-style-type:disc">컴파일 시에 크기를 알 수 없는 배열을 스택에 할당할 수 있는 방법<ul id="faab4ea1-94a4-4411-b30d-25e42d80a84c" class="bulleted-list"><li style="list-style-type:circle">힙 메모리보다 속도가 빠름 → <strong>장점</strong></li></ul></li></ul><ul id="be323fd3-71cd-4787-9806-81bd19751ae0" class="bulleted-list"><li style="list-style-type:disc">하지만 실행 중에 내부적으로 뭔가 더 복잡한 일이 일어남 → <strong>단점 1</strong><ul id="53b31ad6-f754-412a-822f-b1e85db67dd8" class="bulleted-list"><li style="list-style-type:circle">실행 중에 배열을 메모리 어딘가에 저장한 뒤 그 포인터로 기억</li></ul><ul id="8aab03c4-e62e-4150-9250-a0dbd3d26fcf" class="bulleted-list"><li style="list-style-type:circle">나중에 배열을 사용할 때마다 그 포인터를 통해 접근</li></ul></li></ul><ul id="aea06252-d43d-4768-bd5c-85b497983c87" class="bulleted-list"><li style="list-style-type:disc">또한 스택 어버플로가 눈에 잘 안 띄개 만듦 → <strong>단점 2</strong></li></ul><h3 id="5827e633-3dce-47bb-98c8-7bb6561b6c2a" class="">sizeof()로 배열의 크기도 알 수 있음</h3><ul id="93b7e123-ae49-4d21-9da5-5a6c3280fd68" class="bulleted-list"><li style="list-style-type:disc">가변 길이 배열의 크기도 <code>sizeof()</code>를 이용해 실행 중에 확인 가능<pre id="d4a4f7c9-762b-4428-81f8-4dac3799e5d4" class="code"><code>int size;
scanf(&quot;%d&quot;, %size);
int nums[size];
printf(&quot;nums size: %d\n&quot;, sizeof(nums));</code></pre><pre id="a2a6c3c9-a0ff-445b-af3b-88f6f90051aa" class="code"><code>20
nums size: 80
_</code></pre></li></ul><ul id="2913333a-5a5b-4d7a-80c9-ff1646dcbbe8" class="bulleted-list"><li style="list-style-type:disc">한 편으로는 훌륭</li></ul><ul id="30f5bb85-1b5e-4399-9b35-76894fc77d0b" class="bulleted-list"><li style="list-style-type:disc">그러나 이것이 정말 C에게 걸맞는 방법인가 생각해 볼 필요가 있음</li></ul><ul id="99df5b16-8c36-4abc-872e-5a4e597aa0aa" class="bulleted-list"><li style="list-style-type:disc"><code>sizeof()</code>는 컴파일 중에 결정되던 키워드인데 런타임 중에 작동하게 만들기 위해 내부적으로 얼마나 복잡할지..</li></ul><h3 id="17ca8d64-167d-4222-bdad-cf358959a5fa" class="">함수 매개변수로도 사용 가능</h3><ul id="b7396089-bb10-41ec-8241-80facd6ddc0b" class="bulleted-list"><li style="list-style-type:disc">다음처럼 매개변수에도 사용 가능<pre id="f283c516-ebfe-44e7-a4f2-e96053881170" class="code"><code>int sum(int n, int nums[n]_
{
	int r = 0;
	for (int i = 0; i &lt; n; ++i) {
		r += nums[i];
	}

	return r;
}</code></pre><pre id="628fd4fe-08fd-43aa-919a-7402281e721e" class="code"><code>int nums1[5] = { 10, 20, 30, 40, 50 };
int result = sum(5, nums1);
printf(&quot;result: %d&quot;, result); // 150
int nums2[3] = { 10, 20, 30 };
int result = sum(3, nums2);
printf(&quot;result: %d&quot;, result); // 60</code></pre></li></ul><ul id="86817994-6349-4f24-a5cf-3d03f2776ae2" class="bulleted-list"><li style="list-style-type:disc">배열 n개의 요소가 있음을 가정하는 함수임을 나타내기 적합</li></ul><ul id="6aa8e79b-af94-4abe-9a86-222c16adb47b" class="bulleted-list"><li style="list-style-type:disc">그러나 <code>sizeof(nums)</code>는 여전히 4</li></ul><h3 id="ce2138ae-c73f-4785-8424-9a24b2d3a97c" class="">베스트 프랙티스 : VLA 쓰지 말자</h3><ul id="c1bca9af-8ae1-445a-8396-60b521cbac76" class="bulleted-list"><li style="list-style-type:disc">그냥 쓰지 않는게 좋음</li></ul><ul id="0ed169e9-513f-4c85-a2a7-25dde9da1bdc" class="bulleted-list"><li style="list-style-type:disc">여태까지 사용하던 방법을 사용<p id="6c14611d-c369-4f34-9f1a-f7b4bc0a4e4a" class="">1) 충분히 크게 정적 배열을 잡아서 쓸 것</p><p id="5db6552a-5389-41a3-8c51-2db3735781b2" class="">2) 그보다 큰 데이터가 인자로 들어오면 반복문으로 나눠 읽는 법이 있음</p><p id="959d0546-fdd8-41d8-bbd5-a9e2a0055b09" class="">3) 그것도 안되면 동적 메모리 할당을 할 것</p></li></ul><h2 id="469dc77a-814f-424b-bbc5-fd68a9335064" class="">배열 색인 안의 static 키워드</h2><h3 id="7630aaa7-6b14-4820-8d04-e8b3a8d29dc4" class="">(복습) 함수에 배열 매개변수 전달하기</h3><pre id="26190297-732b-44c3-9491-e30f36873d2c" class="code"><code>int sum(int nums[], size_t count)
{
	...
}</code></pre><ul id="11a6e00d-138e-43d9-87f3-940ca9b52038" class="bulleted-list"><li style="list-style-type:disc">여기서 <code>nums</code>는 단순히 <code>int*</code></li></ul><ul id="8a09aec1-d002-4b3b-b807-56166e7d5c02" class="bulleted-list"><li style="list-style-type:disc">하지만 포인터를 전달할 때에 비해 몇 가지 제약이 있음<ul id="98380ae5-f84b-4180-89d8-3a83d6dda2d7" class="bulleted-list"><li style="list-style-type:circle">배열 매개변수를 <code>int* const</code>처럼 전달할 방법이 없음<p id="bc3adc34-5dd7-4cfa-ac2c-b021b4fc4d4e" class="">⇒ <code>const int nums[]</code>는 <code>const int*</code></p></li></ul><ul id="f5ecaad5-c0e7-4514-9414-be3659167990" class="bulleted-list"><li style="list-style-type:circle"><code>restrict</code>도 불가능</li></ul></li></ul><ul id="d852c83a-da2f-485c-8f68-2bab2fab92d0" class="bulleted-list"><li style="list-style-type:disc">함수에 전달될 배열의 요소수를 컴파일 도중 알 방법이 전혀 없음</li></ul><ul id="3ed25810-1a17-4373-a3fe-db718f342c25" class="bulleted-list"><li style="list-style-type:disc">만약 알 수 있다면 최적화 가능 (예: loop unrolling; 루프풀기)</li></ul><ul id="7f4164f2-36cd-4396-8d1c-5aa8c095ad11" class="bulleted-list"><li style="list-style-type:disc">C99는 이런 걸 지정하는 것을 서용</li></ul><h3 id="51a42fc0-3156-4efa-87c9-0d3d231e8c02" class="">배역 색인 안의 static 키워드</h3><pre id="78627380-33e9-4aec-938e-eaa8ff3d1f96" class="code"><code>매개변수_이름[static 한정자 표현식]</code></pre><ul id="af59dcff-45a7-4a97-8d00-ec5845007326" class="bulleted-list"><li style="list-style-type:disc">배열을 매개변수로 전달할 때만 사용 가능</li></ul><ul id="6984b086-0d2a-46de-9540-0ca6175d1b69" class="bulleted-list"><li style="list-style-type:disc">(선택) <code>static</code> 키워드 : 배열에 <strong>최소 몇 개</strong>의 요소가 있는지 알려줌</li></ul><ul id="ff3b0a4f-d87a-473e-ae2f-19ee151a2b10" class="bulleted-list"><li style="list-style-type:disc">(선택) 한정자(qulifier) : 배열 자체(요소가 아님)에 붙는 한정자<ul id="96a89f98-19a4-4c26-bdbb-6503d49f466a" class="bulleted-list"><li style="list-style-type:circle"><code>const</code></li></ul><ul id="0cf06f7f-51cb-45cf-813f-faf354ceba5e" class="bulleted-list"><li style="list-style-type:circle"><code>restrcit</code></li></ul><ul id="2a59f196-ab8c-44f4-a5da-09cf19ee3b18" class="bulleted-list"><li style="list-style-type:circle">등</li></ul></li></ul><pre id="5c5763a9-d17d-44a2-ab2e-5eb4f4fcbf16" class="code"><code>int sum(int nums[static 8], size_t count)
{
	assert(count &gt;= 8);
	// 합을 구해서 반환하는 코드
}</code></pre><ul id="9c70cf4e-a2c3-451a-aa18-8c7b94a65ff2" class="bulleted-list"><li style="list-style-type:disc"><code>num</code>  배열에 최소 8개의 요소가 들어있다고 알려줌</li></ul><ul id="4ba950e3-cc7d-4bcb-a04b-86359467f016" class="bulleted-list"><li style="list-style-type:disc">컴파일러는 이 힌트에 맞춰 최적화를 할 수 있음</li></ul><ul id="f7137df9-fe7d-4ee4-ba8d-cde27e8ff0ac" class="bulleted-list"><li style="list-style-type:disc">실행 중에 그보다 작은 배열이 들어오면 정의되지 않은 결과</li></ul><ul id="9df2b2e8-5b6e-4e29-b9a8-1b9c8b1dbb33" class="bulleted-list"><li style="list-style-type:disc"><code>assert()</code>를 잘 써서 이런 경우를 빨리 찾는게 좋은 습관</li></ul><h3 id="1fe45fa7-81c3-469c-af6f-99de9420c9ae" class="">const 한정자</h3><pre id="9ab0c518-8eb5-4aae-8a9a-59dd9b092818" class="code"><code>void copy_nums(int dest[const], const int src[], size_t count)
{
	for (size_t i = 0; i &lt; count; ++i) {
		dest[i] = *src++;
	}

	dest++;         // 컴파일 오류
	src[0] = 0;     // 컴파일 오류
}</code></pre><ul id="29a91386-7011-4c48-8a01-344cb9b73ff0" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code> : <code>int* const</code></li></ul><ul id="b11230f6-e52b-4546-8f43-0a474d2c8a54" class="bulleted-list"><li style="list-style-type:disc"><code>src</code> : <code>const int*</code></li></ul><h3 id="bcbac363-a073-438d-bd72-53ad578f55e2" class="">restrict 한정자</h3><pre id="c6d09e4c-8e79-444f-b0ba-76eff2e1a275" class="code"><code>void copy_nums(int dest[const restrict]), const int src[restrict], size_t count);</code></pre><ul id="f1e89ff7-ddac-493a-a68b-9131b595f94c" class="bulleted-list"><li style="list-style-type:disc"><code>dest</code> : <code>int* const restrict</code></li></ul><ul id="02495f0e-27a0-449e-9fae-47bb41db07b6" class="bulleted-list"><li style="list-style-type:disc"><code>src</code> : <code>const int* restrict</code></li></ul><h2 id="9037c9bc-bb08-456b-a8aa-99dc4a9fa304" class="">복합 리터럴(compound literal)</h2><ul id="6d5d0edc-65f5-40cd-b854-3bdad143ed84" class="bulleted-list"><li style="list-style-type:disc">어떤 데이터형의 자료를 이름 없이 만들어 한 번 쓰고 버리는 방법</li></ul><ul id="8b2fd2c7-d5ef-469d-9581-964a3a9a6ad4" class="bulleted-list"><li style="list-style-type:disc">주로 <code>struct</code>나 배열에 사용</li></ul><ul id="88ac5d59-29d7-4c84-9a74-7a0b756409b9" class="bulleted-list"><li style="list-style-type:disc">코드는 꼭 초기화 목록(initializer) + 캐스팅처럼 보임</li></ul><h3 id="348741bf-d5db-4739-bcb7-2c0edf205266" class="">복합 리터럴 사용법</h3><pre id="e934993b-fad6-476c-94c1-f78060870a34" class="code"><code>(자료형) {초기화 목록}

(int[]){ 2, 4 };</code></pre><ul id="c41c997d-992d-4e0e-a9f5-cef174c399a5" class="bulleted-list"><li style="list-style-type:disc">자료형<ul id="79157180-3b0d-4671-b03c-43c5d1464fbe" class="bulleted-list"><li style="list-style-type:circle">초기화 목록으로 만들려고 하는 데이터의 자료형</li></ul></li></ul><ul id="9b05c6ac-318b-4090-9c4c-0d3f1793a19f" class="bulleted-list"><li style="list-style-type:disc">초기화 목록<ul id="924bbaaf-5db8-4695-8ebd-43d20b3e9e2e" class="bulleted-list"><li style="list-style-type:circle">자료형을 초기화하는데 적합한 데이터들</li></ul></li></ul><pre id="5d0c6588-94f6-4632-9d20-2bae8a39e92c" class="code"><code>int nums[2] = { 2, 4};     // 일반적인 배열 선언
int* p = (int[]){ 2, 4);   // int[2] 정적 배열. 따로 변수명 없음</code></pre><ul id="4ac47fce-0bc2-4ac7-8668-77bb043356b6" class="bulleted-list"><li style="list-style-type:disc">배열 변수명이 없다보니 포인터에 대입해야 할 일이 있음<ul id="b47f3628-0147-4be7-bfbe-fe620fe9c74c" class="bulleted-list"><li style="list-style-type:circle">예 : 선언 후 데이터를 유지하고 싶은 경우</li></ul></li></ul><ul id="19b88a2f-1b35-42cd-b5c0-89d704558ae0" class="bulleted-list"><li style="list-style-type:disc">그럴 일이 있으면 포인터에 대입하지 않아도 됨<ul id="ccaf4ae3-c127-44bf-bcb6-171fc00448b0" class="bulleted-list"><li style="list-style-type:circle">예 : 매개변수로 사용하는 경우</li></ul><pre id="709c2ea2-0c80-4478-b441-985795ebb200" class="code"><code>int sum(int nums[], int n);</code></pre><pre id="5e6bd134-aa30-4985-b5cf-8b6121ab6fea" class="code"><code>sum((int[3]) { 100, 200, 300 }, 3);</code></pre></li></ul><h3 id="cb1b8af1-83ca-4e64-8187-b0af2e51c48b" class="">복합 리터럴 예시 : 구조체</h3><pre id="280c25d9-2992-4bc7-9b4f-9f1051cdc09e" class="code"><code>struct foo structure;

// 다른 코드들

structure = ((struct foo) { x + y, &#x27;a&#x27;, 0});</code></pre><pre id="e0e3a7d0-b07b-4ee4-9126-44c282d94167" class="code"><code>struct foo {
	int a;
	char b[2];
};</code></pre><ul id="5f6429a0-33a6-4aca-b919-a8c656958404" class="bulleted-list"><li style="list-style-type:disc">위/아래 코드는 같음</li></ul><pre id="1f4187b8-5161-4b34-bf08-3fb6606a9780" class="code"><code>struct foo structure

// 다른 코드들

struct foo temp = { x + y, &#x27;a&#x27;, 0});
structure = temp;</code></pre><h3 id="e54e3dcd-df4a-4e28-9fe7-cd3b39a784d1" class="">베스트 프랙티스 : 그냥 쓰지 말 것</h3><ul id="1b8eeb8c-5899-4b32-ac27-627bab713a30" class="bulleted-list"><li style="list-style-type:disc">이걸 써야할 이유는 아마도 타이핑을 줄이려고 일 듯</li></ul><ul id="7cb09ab4-4a00-465a-9fb6-3b99290e4bd4" class="bulleted-list"><li style="list-style-type:disc">코딩 좀 더 하더라도 명확한 코드가 좋음</li></ul><ul id="c2b0b0c9-6a6a-4c4c-a338-4fc7096a1dd2" class="bulleted-list"><li style="list-style-type:disc">그러니 그냥 쓰지 말자 → 실제로도 거의 쓰지 않음</li></ul><h2 id="acc23d51-8f73-4dd9-b971-481e41616bca" class="">가변 인자 매크로(variadic macro)</h2><ul id="27ca75ba-2290-4ef6-9536-3a258d87beb4" class="bulleted-list"><li style="list-style-type:disc">함수에는 가변 인자 매개변수를 쓸 수 있었음<pre id="c735b7c7-3d8e-4ff7-923f-76f55c03f04f" class="code"><code>int printf(const char* format, ...);
int scanf(const char* format, ...);</code></pre></li></ul><ul id="ec76acc2-482b-4997-84a8-3dcd312d9ebd" class="bulleted-list"><li style="list-style-type:disc">하지만 매크로 함수에서는 그게 불가능 했음</li></ul><ul id="b168275b-b453-48b4-a28e-4ed2502b410f" class="bulleted-list"><li style="list-style-type:disc">C99부터는 가능!</li></ul><h3 id="ae2c7705-9063-4533-afae-b82f035e7bc1" class="">가변 인자 매크로</h3><pre id="ef3dfc71-2fac-4de2-bf41-bd53baf700ec" class="code"><code>#define 식별자(매개변수들, ...) 대체목록
#define 식별자(...) 대체목록</code></pre><ul id="333f5959-ea14-4f1e-b088-1360f2b20212" class="bulleted-list"><li style="list-style-type:disc">일반 함수와는 달리 매개변수 목록에 가변 인자만 있어도 됨</li></ul><ul id="9e0d92e3-9618-4f59-a3dc-1ef69d334bae" class="bulleted-list"><li style="list-style-type:disc"><code>...</code>로 받은 가변 인자는 <code>__VA_ARGS__</code> 매크로로 사용 가능<ul id="45705508-f147-49b6-a7ef-ff182568f2a3" class="bulleted-list"><li style="list-style-type:circle">단, 다른 함수에 전달하는 용도로 밖에 사용 못함</li></ul><ul id="345f2bc4-1386-4799-b045-7420ec4ea8d4" class="bulleted-list"><li style="list-style-type:circle"><code>#</code>을 앞에 붙여서 문자열을 만들 수도 있음</li></ul></li></ul><h3 id="75ede3f3-ec1e-473a-9621-1b6090872156" class="">다른 함수에 가변 인자를 전달하는 용도</h3><ul id="8adaba83-4604-4fab-90a6-45703d1c3a69" class="bulleted-list"><li style="list-style-type:disc">일반 함수와 달리 가변 인자 속에 있는 각 인자에 접근할 방법이 없음<ul id="e9421209-b32c-453c-b30f-c9eec0b5c244" class="bulleted-list"><li style="list-style-type:circle">일반 함수의 경우 <code>va_list</code>를 사용했음</li></ul><ul id="f3bfd6a0-4c4d-413e-8317-b90734b62d58" class="bulleted-list"><li style="list-style-type:circle">매크로 함수 내에서는 불가능</li></ul></li></ul><ul id="7badba8d-c974-4437-801d-4cf65f3193a5" class="bulleted-list"><li style="list-style-type:disc">따라서 매크로의 가변 인자는 다른 함수로 다시 전달하는 용도<pre id="26bb7f0d-e12a-4a9b-a723-82041c8c71ad" class="code"><code>#define LOG_ERROR(...) fprintf(stderr, __VA_ARGS__);</code></pre><pre id="2c46ed3d-db6d-49f2-9e50-53e737327bab" class="code"><code>LOG_ERROR(&quot;FAILED TO LOAD: %s\n&quot;, filename);  // fprintf(stderr, &quot;FAILED TO LOAD: %s\n&quot;, filename);로 바뀜</code></pre></li></ul><h3 id="6e1a96f2-6e80-4579-af7c-f867bba0f6e6" class=""># 명령어와 같이 쓰는 경우</h3><ul id="e4a02618-a0ee-45a2-91cc-725405ac4643" class="bulleted-list"><li style="list-style-type:disc"><code>#</code>를 매크로 함수의 인자 앞에 붙이면 <code>&quot;&quot;</code>로 감싸는 효과<pre id="d6e2d780-26e6-43c1-b60d-8421d74a2083" class="code"><code>#define PRINT_LIST(...) puts(#__VA_ARGS__)</code></pre><pre id="e3c504bc-f2a5-4575-83e8-a539ac74cd46" class="code"><code>PRINT_LIST();  // puts(&quot;&quot;);로 바뀜
PRINT_LIST(17, &quot;Hong&quot;, double); // puts(&quot;17, \&quot;Hong\&quot;, double&quot;)로 바뀜</code></pre></li></ul><h2 id="d05a6e63-e994-4166-809b-ead06fe16127" class="">유니버셜 문자 이름</h2><h3 id="70b329e1-ba03-4fc9-b661-48a67e1f0533" class="">유니코드 지원</h3><ul id="a7d2e639-6743-4ad4-814c-dc5413ddfe2a" class="bulleted-list"><li style="list-style-type:disc">유니코드를 소스파일에서 사용 가능<ul id="dadfe278-4565-413c-ac96-9fc22dde76b1" class="bulleted-list"><li style="list-style-type:circle">변수 이름</li></ul><ul id="9204c9f8-944d-4051-9455-a2cc87f842d3" class="bulleted-list"><li style="list-style-type:circle">문자 또는 문자열</li></ul></li></ul><ul id="a1cf0adf-3c39-43f9-ae15-cc06a0b36948" class="bulleted-list"><li style="list-style-type:disc">소스파일을 특정 유니코드 인코딩으로 저장하는 걸 말하는 것이 아님!<ul id="757a1813-0458-46ec-862d-76dd5c90b002" class="bulleted-list"><li style="list-style-type:circle">예 : UTF-8로 저장한 소스파일</li></ul></li></ul><ul id="30de1b04-36e6-4fb4-8259-232a098665e7" class="bulleted-list"><li style="list-style-type:disc">소스코드 안에 직접 유니코드 코드 포인트를 작성하는 방식</li></ul><ul id="c7313d9a-ee84-4966-8c8b-7b100a4aaa42" class="bulleted-list"><li style="list-style-type:disc">이걸 유니버셜 문자이름(universal character name, UCN)이라 함</li></ul><h3 id="3f89880e-1a60-4f35-88f0-ec74352468ec" class="">UCN 사용법</h3><p id="8e557bb8-1cf8-4149-8d25-e10927416fe6" class=""><strong>&lt;유니코드 코드 포인트 u+nnnn&gt;</strong></p><pre id="14314844-8428-4295-8ca2-00eab3c154c6" class="code"><code>\unnnn</code></pre><p id="e5f0be66-6df0-4543-8855-bccea0417057" class=""><strong>&lt;유니코드 코드 포인트 u+nnnnnnnn&gt;</strong></p><pre id="ef7772a9-775b-41b8-9e17-2f44d6062fac" class="code"><code>\unnnnnnnn</code></pre><pre id="57cc2f3a-63f9-414f-95e0-97375d2b3943" class="code"><code>int mathscore_pope = 10;
printf(&quot;Pope: %d\n&quot;, mathscore_pope);

int mathscore_\ud3ec\ud504 = 10; // \ud3ec: 포, /ud504: 프

const char* pope1 = &quot;포프&quot;               // 파일 자체를 UTF-8로 저장하면 동작함
const char* popo2 = &quot;\ud3ec\ud504&quot;;      // 파일 자체를 UTF-8로 저장 안 해도 동작함

printf(%s: %d&quot;, pope2, mathscore_\ud3ec\ud504);</code></pre><h3 id="61186dda-643a-479e-a82b-b9050ba22984" class="">UCN 지원의 의의</h3><p id="6bc328b4-1a0d-4d84-a0b0-dd84d77961f5" class=""><strong>&lt;아스키 인코딩으로 저장한 경우&gt;</strong></p><ul id="a754fe6e-62bb-465d-97d1-ca4df24beb05" class="bulleted-list"><li style="list-style-type:disc">다시 열면 그 문자가 유지되지 않음<pre id="733bc68f-d1e8-4645-b75d-eb13a7dca8c4" class="code"><code>// \ud3ec: ?, /ud504: ?</code></pre></li></ul><p id="9b580ce2-903a-43c5-b49f-326e23e959e9" class=""><strong>&lt;특정 언어용 인코등으로 저장한 경우&gt;</strong></p><ul id="b32050b0-7b49-4aa1-872d-8fcc110c850b" class="bulleted-list"><li style="list-style-type:disc">컴파일러가 제대로 읽지 못해서 컴파일 오류를 내는 경우가 대부분</li></ul><p id="71ba447f-0c2d-4e74-af8e-5ab66d17dc53" class=""><strong>&lt;UTF-8 인코딩으로 저장한 경우&gt;</strong></p><ul id="8601f890-3bee-4f88-87d2-7ac1d3bb0fc7" class="bulleted-list"><li style="list-style-type:disc">파일을 다시 열어도 문자가 유지됨</li></ul><ul id="09f65a77-6f21-4cf0-a503-f27f86a802a9" class="bulleted-list"><li style="list-style-type:disc">단 폰트가 없을 경우 ㅁㅁㅁ로 자올 수 있음</li></ul><ul id="3abc600b-4773-4bfd-93d2-30f5d2aac14e" class="bulleted-list"><li style="list-style-type:disc">예전 컴파일러에서는 컴파일 오류가 날 수도 있음 (아스키만 지원)</li></ul><ul id="0fce6c33-e58b-4f1f-be13-517fefb372d8" class="bulleted-list"><li style="list-style-type:disc">요즘 컴파일러는 대부분 UTF-8를 지원<pre id="9ff112f5-7d55-448b-9b54-046831adde6e" class="code"><code>// \ud3ec: 포, /ud504: 프</code></pre></li></ul><hr id="3fdc30bc-a899-4e68-81b4-38f5a532f19b"/><p id="d6efc78b-5553-442f-b5ed-f5afd8a0469c" class=""><strong>Q) 그럼 이제 C가 다국어 처리를 다 알아서 해주는 것인가? 아무 언어나 쓰면 제대로 출력되는가?</strong></p><p id="320a52b9-aa50-4607-94d6-e805df961227" class=""><strong>A) </strong>Nope! 인코딩은 종류가 많음! 그걸 컴퓨터 입장에서는 판단할수가 없음! 예를 들어서 바이트가 두 개가 있는데 유니코드인지, EUC-KR인지, 아니면 아스키 코드인지 알 수 없음</p><hr id="7c00f6b8-8343-416b-8f8c-3f41d76dbac6"/><h2 id="3bbbbb87-3b9f-423b-9080-81c868e8244d" class="">멀티바이트 문자</h2><ul id="0c63d003-c65a-40a2-a75d-dd2b1b5d36d1" class="bulleted-list"><li style="list-style-type:disc">컴퓨터에게 문자는 그냥 메모리에 있는 바이트 배열</li></ul><ul id="a422f7f1-3800-4acc-b652-4ccbd43d15d6" class="bulleted-list"><li style="list-style-type:disc">모든 문자는 결국 1개 이상의 바이트(<code>char*</code>)에 저장됨<ul id="1ee2f302-ba39-492d-a392-b1825cd8632a" class="bulleted-list"><li style="list-style-type:circle">아스키는 1문자 = 1바이트</li></ul><ul id="9096f8b1-8038-439e-8b3f-ef30f6db009c" class="bulleted-list"><li style="list-style-type:circle">다른 인코딩의 1문자는 1바이트 또는 그 이상</li></ul></li></ul><ul id="98a3b591-7c89-4b9b-ae1f-eec4d6234461" class="bulleted-list"><li style="list-style-type:disc">어떤 나라의 문자를 바이트에 저장하는 방법(인코딩)은 다양<ul id="cc4946dc-c36c-400a-8c7b-b93a30fbe3de" class="bulleted-list"><li style="list-style-type:circle">예 : 한글 조합형, EUC-KR, CP979(통합 완성형), UTF-8 등</li></ul></li></ul><h3 id="4ffc59d5-668e-46d0-a6cc-14f33a55d847" class="">C에서의 멀티바이트 문자</h3><ul id="99600986-e786-48e1-9873-76ca905a1ee4" class="bulleted-list"><li style="list-style-type:disc">1개 이상의 바이트로 표현된 문자<ul id="00ce7fae-0aa4-474a-9ee4-d41db01aa351" class="bulleted-list"><li style="list-style-type:circle">인코딩에 상관없음</li></ul><ul id="00a79cf3-b285-4c09-89eb-f2ccc6ae5791" class="bulleted-list"><li style="list-style-type:circle"><strong>(중요) 각 문자마다 바이트 크기가 다를 수 있음</strong></li></ul><ul id="0c4ddc47-120f-4840-85e0-993714d07950" class="bulleted-list"><li style="list-style-type:circle">바이트 크기가 고정인 경우도 있음 (예 : 아스키)</li></ul></li></ul><ul id="304e5e37-0beb-4d8f-a510-8a0bb66e7ca7" class="bulleted-list"><li style="list-style-type:disc">C에서 멀티바이트는 <code>char*</code>로 표현</li></ul><ul id="9f5a13c0-9ecd-4ab9-8909-dc19c4b6024d" class="bulleted-list"><li style="list-style-type:disc"><strong>(중요) C에서의 멀티바이트는 문자가 기본</strong><ul id="6b4baf82-6294-41a9-8ce1-8f493f590160" class="bulleted-list"><li style="list-style-type:circle">사용자의 입력과 출력은 모두 멀티바이트 문자를 사용</li></ul><ul id="b0414ea1-c7b9-4f37-a7df-e5942e8aad82" class="bulleted-list"><li style="list-style-type:circle">C의 라이브러리도 기본적으로 멀티바이트 문자를 사용</li></ul></li></ul><h3 id="6b54866c-7201-4eb5-9e68-48f9a0b5dd01" class="">멀티바이트 문자가 제대로 작동하는 조건</h3><ul id="7d2b79da-0ca7-4c85-932d-2bc1397321ab" class="bulleted-list"><li style="list-style-type:disc">아스키가 아닌 문자열을 사용자로부터 입력받았다고 해보면</li></ul><ul id="691a7e5a-a43d-48b3-8d63-edf60389c4e5" class="bulleted-list"><li style="list-style-type:disc">읽어온 멀티바이트 문자열은 <code>char*</code>에 저장됨</li></ul><ul id="2c63403b-678b-4ba0-867f-b90f706f6389" class="bulleted-list"><li style="list-style-type:disc">코딩은 사용자가 컴퓨터 환경에 설정된 것을 따름</li></ul><ul id="1ba5cf60-239b-45c8-ab8f-1c58efa2293f" class="bulleted-list"><li style="list-style-type:disc">이 문자열을 다시 사용자에게 출력해주면 제대로 출력됨<ul id="6e0b9831-cbe1-48c6-970e-8544e8114c81" class="bulleted-list"><li style="list-style-type:circle">컴퓨터 환경이 이미 그 인코딩이기 때문</li></ul></li></ul><ul id="48eb53e5-65bf-42b7-8ad9-ee52f586742d" class="bulleted-list"><li style="list-style-type:disc">아스키 문자열은 입력받거나 출력해도 제대로 작동함<ul id="95bc1863-9757-4c00-8785-af50d2837245" class="bulleted-list"><li style="list-style-type:circle">사용자 인코딩 설정과 상관없음</li></ul><ul id="0989ae04-99ab-4c36-8552-63f26dee439a" class="bulleted-list"><li style="list-style-type:circle">대부분 멀티바이트 문자열은 아스키 값을 그대로 지원하기 때문</li></ul></li></ul><h3 id="1dca4ec5-0a5a-4555-bba5-88e32a2e4396" class=""> 문제점</h3><ul id="23c2a307-d269-4321-9467-64c66feb6c75" class="bulleted-list"><li style="list-style-type:disc">데이터 교환이 동일한 인코딩 환경을 가진 사용자에게 한정</li></ul><ul id="a47e260a-2c6e-4b16-9f8d-d1bf498cbfac" class="bulleted-list"><li style="list-style-type:disc">사실 이게 컴퓨터가 처음 나왔을 때 프로그램을 사용하던 모습</li></ul><ul id="fb561cea-d704-43bf-b00c-519c93792e05" class="bulleted-list"><li style="list-style-type:disc">저차 컴퓨터를 널리 사용함에 따라 그 행태도 바뀜</li></ul><ul id="9efa1840-059b-4569-b4b3-a2ada62a2e94" class="bulleted-list"><li style="list-style-type:disc">이에 따라 C의 다국어 지원도 같이 발전해왔음</li></ul><ul id="069b621b-9157-4d6b-b4c6-51520d78aac0" class="bulleted-list"><li style="list-style-type:disc">그러나 다른 프로그래밍 언어에 비해 매우 미비한 수준</li></ul><ul id="d4c619b4-7a46-4441-beaa-82d4e63fdfc7" class="bulleted-list"><li style="list-style-type:disc">다국어를 제대로 지원하는 C 프로그램은 ICU라는 라이브러리를 사용<ul id="bd50c493-5c67-4e78-94aa-38f94e645d89" class="bulleted-list"><li style="list-style-type:circle">ICU(International Components for Unicode)</li></ul><ul id="4e520221-91d3-4c82-b14c-bc397de201e9" class="bulleted-list"><li style="list-style-type:circle">하지만 용량 및 성능 상의 우려 때문에 사용하지 못하는 프로젝트가 존재</li></ul><ul id="c689bbb8-b0cf-408d-8efd-0fbe4308b2b1" class="bulleted-list"><li style="list-style-type:circle">앞으로 볼 내용 중 C의 한계가 보일 때마다 ICU로 해결 가능하다 생각할 것</li></ul></li></ul><h2 id="cbadc517-23c2-4d73-8134-2aff02b2fb4b" class="">다국어를 지원하기 위한 긴 여정</h2><ul id="ef6f5ee2-fd02-46c7-a762-5f2239a0b8a0" class="bulleted-list"><li style="list-style-type:disc">어쨌든 C 언어는 컴퓨터 사용환경이 변한 것에 많이 뒤쳐져 있음</li></ul><ul id="f737414a-27b8-479d-b2e5-73c35a6ba304" class="bulleted-list"><li style="list-style-type:disc">현재 상황은 데이터 교환에 사용할 수 있는 공통된 표준이 필요<ul id="63b056db-31a7-48d4-9aa2-44c007d312ac" class="bulleted-list"><li style="list-style-type:circle">사용자의 컴퓨터가 어떤 인코딩을 사용하던 무관</li></ul><ul id="a9144af5-fb14-40ed-a047-58cde5f9d80b" class="bulleted-list"><li style="list-style-type:circle">현재 대세인 표준은 그 유명한 유니코드</li></ul><ul id="d9a3e30b-1ff8-45dd-9d60-3ae2b2496f4f" class="bulleted-list"><li style="list-style-type:circle">그 중에서도 웹의 90%를 차지하는 UTF-8 인코딩</li></ul></li></ul><ul id="6cf8ee3a-4dbb-4de6-88d3-061b1033b5cb" class="bulleted-list"><li style="list-style-type:disc">유니코드까지 가기까지의 힘겨운 C의 여정을 살펴보자</li></ul><ul id="9e4c0864-7422-447a-b0df-a0dcc55b2002" class="bulleted-list"><li style="list-style-type:disc">그 힘든 여정의 첫 흔적은 <code>wchar_t</code></li></ul><h2 id="44777cf7-a7c0-42f0-ae6c-d8f23031bbc0" class="">wchar_t</h2><ul id="b2c91537-0d8c-400a-8e68-f34f4b1eadb9" class="bulleted-list"><li style="list-style-type:disc">각 문자가 <strong>고정된 바이트 크기</strong>를 가짐</li></ul><ul id="452a5efd-8252-4e56-aa5a-0a739328e19f" class="bulleted-list"><li style="list-style-type:disc">즉, 모든 문자의 바이트 크기가 같음 (멀티바이트 문자와 다름!)</li></ul><ul id="8f67a92b-7122-40b5-af4a-28ee7bdfc9a2" class="bulleted-list"><li style="list-style-type:disc">그 바이트 크기는?<ul id="4eff6572-c47c-4098-8418-931c12efee7d" class="bulleted-list"><li style="list-style-type:circle">타겟 플램폼에서 지원하는 모든 이놐딩 중 가장 큰 문자를 담을 수 있어야 함</li></ul><ul id="dad91677-07a2-4776-82c8-67d47421fb56" class="bulleted-list"><li style="list-style-type:circle">지금와서 보면 이걸 만족하는 것은 사실상 UTF-32(4바이트)</li></ul></li></ul><ul id="feff5449-8e95-4f20-a8b9-7d2c2b310859" class="bulleted-list"><li style="list-style-type:disc">자료형이니 컴파일 시에 이미 인코딩과 바이트 크기가 정해짐<ul id="010a22f8-006f-4620-a546-89c7aa685b70" class="bulleted-list"><li style="list-style-type:circle">단, 컴파일러와 플랫폼마다 다를 수 있음</li></ul><ul id="a93d577b-3905-4fd2-97f1-5e7a09a7aef4" class="bulleted-list"><li style="list-style-type:circle">표준은 정확히 몇 바이트에 무슨 인코딩인지 정하지 않음</li></ul><ul id="50a9400d-1467-4a64-961f-a9770473571a" class="bulleted-list"><li style="list-style-type:circle">리눅스 : 교양있는 운영체제 답게 4바이트(UTF-32)</li></ul><ul id="fbe70180-d452-406e-8f51-802138d0f4b4" class="bulleted-list"><li style="list-style-type:circle">윈도우 : 2바이트(UCS-2)</li></ul></li></ul><ul id="f85cedb9-f4ec-4b37-ae59-bc2280333c9b" class="bulleted-list"><li style="list-style-type:disc">역시 아스키 문자들은 기존 코드 값을 그대로 유지</li></ul><h3 id="e381a944-873f-4867-9662-0953e6a0a253" class="">wchar_t를 사용하는 방법</h3><pre id="ec480897-30cc-42f9-8603-68e738c29588" class="code"><code>const wchar_t* w_pope = L&quot;포프&quot;;
printf(&quot;%ls\n&quot;, w_pope);</code></pre><ul id="38cefd98-e411-464a-bb59-4e260b33b5f6" class="bulleted-list"><li style="list-style-type:disc">와이드 문자열의 경우 따옴표 앞에 &#x27;<code>L</code>&#x27;을 붙임<ul id="9a297aee-b6fe-474d-81fc-1c44ff874286" class="bulleted-list"><li style="list-style-type:circle">안 붙이면 컴파일 오류</li></ul></li></ul><ul id="3390d0c3-31f3-4289-a0b9-5783db2071f0" class="bulleted-list"><li style="list-style-type:disc">이런 와이드 문자열은 컴파일 중에 적절히 변경됨<ul id="36979d32-08a0-4878-bee0-774163ac447a" class="bulleted-list"><li style="list-style-type:circle">최종 플랫폼에서 사용하는 <code>wchar_t</code> 인코딩에 맞는 비트 패턴으로</li></ul></li></ul><ul id="9bb73ae9-659c-4c97-a30d-079a7367859e" class="bulleted-list"><li style="list-style-type:disc">서식 문자&#x27;<code>%ls</code>&#x27;의 의미<ul id="208ccadc-e492-43b0-a4b5-2d53627e41d2" class="bulleted-list"><li style="list-style-type:circle">와이드 문자열을 알아서 멀티바이트 문자열로 변환한 뒤에 화면에 출력</li></ul><ul id="be14b363-766a-427c-92bf-4c62fce24479" class="bulleted-list"><li style="list-style-type:circle">즉, 사용자가 보는 건 결국 멀티바이트 문자열</li></ul><ul id="d3ee9c29-c43c-4bc4-90d4-3102338b4272" class="bulleted-list"><li style="list-style-type:circle">이 멀티바이트 문자열은 사용자 환경에 설정된 인코딩으로 변환된 것</li></ul></li></ul><h3 id="f51da851-f671-4cbd-8963-4e2cf77bb63d" class="">wchar_t 전용 함수들 (C89)</h3><ul id="b6143088-f6e0-42df-aca6-a69366ce3d84" class="bulleted-list"><li style="list-style-type:disc"><code>wchar_t</code>를 제대로 문자열처럼 다룰 수 있는 함수들은 C95에서 등장</li></ul><ul id="77f9cf60-aecd-4aac-9562-b304db73714d" class="bulleted-list"><li style="list-style-type:disc">C89는 다음 함수들만 제공<ul id="14add622-64fe-4712-9868-36a36b3535c1" class="bulleted-list"><li style="list-style-type:circle"><code>&lt;stdlib.h&gt;</code><p id="649e8a13-4611-4754-8a70-fba21192ef3d" class=""><strong>멀티바이트 문자(열) → 와이드 문자(열)</strong></p><pre id="34ab8810-ce05-423b-8201-6f5152a9b07b" class="code"><code>int mbtowc(wchar_t* pwc, const char* s, size_t n);
size_t mbstowcs(wchar_t* dst, const char* src, size_t len);</code></pre><p id="08bd03e5-18bf-4e5d-95f3-69c76cc72e89" class=""><strong>와이드 문자(열) → 멀티바이트 문자(열)</strong></p><pre id="71837044-767d-4250-ad78-71e10bb2c174" class="code"><code>int wctomb(const char* s, wchar_t wc);
size_t wcstombs(wchar* dst, const wchar_t* src, size_t len);</code></pre><p id="85390af4-136e-42d9-8725-771c90901eda" class=""><strong>멀티바이트 문자열 ↔ 와이드 문자열 변환 예시</strong></p><pre id="5d8d903f-d1ec-4601-87da-703ae38eb168" class="code"><code>const char* pope = &quot;\ud3ec\ud504&quot;;
wchar_t w_buffer[64]
mbstowcs(w_buffer, pope, 64);

const wchar_t* w_pope = L&quot;포프&quot;;
char buffer[64];
wcstombs(buffer, w_pope, 64);
printf(&quot;%s\n&quot;, buffer);</code></pre></li></ul></li></ul><ul id="0a51640f-510a-439c-a32c-444c3a042fba" class="bulleted-list"><li style="list-style-type:disc">문자열 길이 (C89)<ul id="3ae6127c-ddc2-4228-952b-ff61040dcadd" class="bulleted-list"><li style="list-style-type:circle">별도의 문자열 길이를 구하는 함수가 없음</li></ul><ul id="7f06ed4f-04eb-481f-8e30-84d4f16bd4f3" class="bulleted-list"><li style="list-style-type:circle"><code>wchar_t</code>가 고정 크기인 점을 이용하면 쉽게 구할 수 있음</li></ul><ul id="87aca1b7-ea55-47ed-b8b2-7b5179a86fb8" class="bulleted-list"><li style="list-style-type:circle">따라서, 우선 멀티바이트 문자열을 와이드 문자열로 변환</li></ul><ul id="3517d7a8-8bf6-4179-9c53-bcd903d7a3fc" class="bulleted-list"><li style="list-style-type:circle">그 후 널 문자가 나올때 까지 <code>wchar_t</code>가 몇 개인지 세기만 하면 됨</li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6d9965fd-c4f2-43a0-bd14-938388902685"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>하지만 서로 다른 운영체제(리눅스 4바이트, 윈도우 2바이트) 간 못 읽는 문제도 발생함 → </strong><strong><code>wchar_t</code></strong><strong>가 서로 다름! 즉, 인코딩이 달라서 못 읽는 문제가 또 발생함</strong></div></figure><h3 id="0a4f194d-f0e3-4f19-9b91-e5e40805f5dc" class="">wchar_t는 2% 모자란 공통 표준</h3><ul id="622b68f9-3aee-4da5-a9be-3716dace49ce" class="bulleted-list"><li style="list-style-type:disc">데이터 교환용 공통 표준은 어느 플랫폼/언어와도 통용되야 함</li></ul><ul id="cdb6c3b9-a966-4ed6-9622-09ff96d0262b" class="bulleted-list"><li style="list-style-type:disc"><code>wchar_t</code>가 공통 표준이 될 수는 있었음</li></ul><ul id="a06c8004-855f-4202-b6ae-d193769cd4a3" class="bulleted-list"><li style="list-style-type:disc">문제는 C 표준은 <code>wchar_t</code>의 크기와 인코딩을 강제하지 않음</li></ul><ul id="5eed5819-7a67-42e0-bd11-b15c62b73dd8" class="bulleted-list"><li style="list-style-type:disc">모두 상식이 있었다면 UTF-32로 대동단결도 가능했을 것임</li></ul><ul id="2c8fda4a-7fd8-4bff-bb0b-d00e6cd06954" class="bulleted-list"><li style="list-style-type:disc">그러나.. 점유율이 50%가 넘는 특정 운영체제 때문에 불가능 (...윈도우)</li></ul><h3 id="5abe99fc-f875-422f-8d82-482f4dbbbf79" class="">C99에서는 언어 자체적인 해결 방법이 없음</h3><ul id="42382419-c2da-4fbc-bf1c-9517935802b9" class="bulleted-list"><li style="list-style-type:disc">만능 라이브러리(ICU)를 쓰던가</li></ul><ul id="3ec0c984-2ee7-4811-8c58-b2e5e6146dde" class="bulleted-list"><li style="list-style-type:disc">두 플랫폼 사이에 변환하는 라이브러리를 만들던가</li></ul><ul id="5b457ea0-8821-4c1f-a47c-2c82d4a3aff0" class="bulleted-list"><li style="list-style-type:disc">하지만 UCS-2는 모든 유니코드 표현을 하지 못함.. <p id="1995ba30-f4ab-4a8d-a12e-92ef4bbc0fc6" class="">⇒ 유니코드는 4바이트, 윈도우는 2바이트로 특정 4바이트 크기의 문자를 2바이트로 구겨넣을 수가 없음</p></li></ul><h3 id="13da4214-c467-41a4-9103-eaac0ffe5b07" class="">C11 전 C95에서 wchar_t용 문자열 함수</h3><ul id="61f91f2c-765d-414a-80ad-4fa1bdf1ce14" class="bulleted-list"><li style="list-style-type:disc"><code>wprintf(</code>) / <code>fwprintf()</code> / <code>swprintf()</code></li></ul><ul id="f3b5f0ef-5c64-498b-b12c-a6af35692c45" class="bulleted-list"><li style="list-style-type:disc"><code>wscanf(</code>) / <code>fwscanf()</code> / <code>swscanf()</code></li></ul><ul id="368f768b-1f3c-4fd6-9e1b-433327968f01" class="bulleted-list"><li style="list-style-type:disc"><code>fgetwc(</code>) / <code>getwc()</code> / <code>fgetws()</code></li></ul><ul id="284c93cf-a4cb-43d5-950d-2832cc14e6c4" class="bulleted-list"><li style="list-style-type:disc"><code>fputwc(</code>) / <code>putwc()</code> / <code>fputws()</code></li></ul><ul id="21641aeb-235c-4232-8d49-4459f7c03bc6" class="bulleted-list"><li style="list-style-type:disc"><code>getwchar()</code> / <code>putwchar()</code></li></ul><ul id="303070ac-32d4-4858-bffd-c501b82f4a69" class="bulleted-list"><li style="list-style-type:disc"><code>wcslen()</code></li></ul><ul id="0be59b63-35c7-4468-9eb5-b4610855bca6" class="bulleted-list"><li style="list-style-type:disc">입출력 및 문자열 길이 재는 함수까지 모두 제공함</li></ul></div></article></body>

{% endblock post_content %}