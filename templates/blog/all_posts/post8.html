{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">메모리 구조</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 18, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="9821a58d-6f35-4d2b-bd02-451adaae9b18" class="page sans"><header><h1 class="page-title">(3) 메모리 구조의 사본</h1></header><div class="page-body"><ul id="740662b5-930b-402d-9edb-b7d28da07c8f" class="bulleted-list"><li style="list-style-type:disc">흔히 메모리라고 하면 RAM을 지칭함</li></ul><ul id="5c1c82e4-6645-4da0-858b-6bc4c1b9eeda" class="bulleted-list"><li style="list-style-type:disc">메모리와 코딩의 관계<p id="9c25a3a1-4835-4172-913c-90a7cab4ef55" class="">⇒ 한정된 자원 안에서 효율적으로 프로그램이 실행될 수 있도록 하기 위해서는 기본적으로 메모리에 대한 이해 필요</p></li></ul><h2 id="c673b0e5-b1cc-42f7-99cd-7ef304e6f34a" class="">메모리의 구조(Memory Structure)</h2><ul id="a070eca5-a867-45e7-b94b-109786266662" class="bulleted-list"><li style="list-style-type:disc">프로그래밍 언어(C, C++, Java 등)의 코딩을 통해 만들어 진 실행파일을 실행하면 코드에서 작성한 동작에 따라 메모리에 데이터들을 쓰고 읽음</li></ul><ul id="9c8cab17-6560-4cd2-8e1e-3b74fe799ec8" class="bulleted-list"><li style="list-style-type:disc">실행파일의 실행과정<p id="a966f577-5303-468d-9072-4ba07fc6834a" class="">1) 실행파일을 만들어 실행파일로 디스크에 저장</p><p id="849bb18d-ce1e-4a83-a14f-cb4d3c604386" class="">2) 사용자가 실행파일을 더블클릭(실행) ⇒ 운영체제에 실행파일을 실행하도록 요청  </p><p id="93b967e1-271b-4ef2-b42d-c22e976693b8" class="">3) 운영체제는 프로그램의 정보들을 읽고 메인 메모리에 공간을 할당</p><p id="84f5b3ef-8acf-48f6-8ba1-866883f6da89" class="">4) 프로그램의 코드(변수, 함수 등)들을 메모리에 읽고 쓰면서 동작</p></li></ul><h3 id="2089a4c3-9ce7-4854-93b0-311f21c6b63d" class="">메모리 구조의 4가지 영역</h3><p id="642dee54-7c42-4cb5-8337-385cd4f9b78b" class="">⇒ 각 언어마다 조금씩 차이는 있지만 전체적인 구조는 아래와 같이 4가지 영역으로 구분됨</p><p id="271f9ac6-9d92-4e0b-b5b5-650e95c38b48" class="">1) <strong>[ Text ]</strong><div class="indented"><ul id="58ba5cb8-e092-4613-a48d-18c876fa4782" class="bulleted-list"><li style="list-style-type:disc">코드를 실행하기 위해 저장되어있는 영역</li></ul><ul id="3491b16a-359d-48f2-bdeb-a4c33fb64125" class="bulleted-list"><li style="list-style-type:disc">프로그램을 실행시키기 위해 구성되는 것들이 저장되는 영역 (= 코드 영역)</li></ul><ul id="6c07174c-a7a6-4d8b-9537-811c8596555a" class="bulleted-list"><li style="list-style-type:disc">한마디로 명령문들이 저장되는 것인데, 제어문, 함수, 상수들이 이 영역에 저장됨</li></ul></div></p><p id="8f792325-19d4-4357-b63a-f3beeb093955" class="">2) <strong>[ Data ]</strong><div class="indented"><ul id="3d7d645d-da3e-4d75-bc8a-d1bbf5c32e11" class="bulleted-list"><li style="list-style-type:disc">전역변수, 정적변수 등이 저장되는 공간</li></ul><ul id="a3586500-761a-42af-8f2a-e71d3e4403ee" class="bulleted-list"><li style="list-style-type:disc">보통 메인(main)함수 전(프로그램 실행 전)에 선언되어 프로그램이 끝날 때까지 메모리에 남아있는 변수</li></ul><ul id="ea92f661-1147-4ac8-b212-7c5459a4aefd" class="bulleted-list"><li style="list-style-type:disc">좀 더 구체적으로 말하자면 Data영역도 크게 두 가지로 나뉨<ol type="1" id="8677f083-0617-401b-86c5-5aaf76416a86" class="numbered-list" start="1"><li>초기화 된 변수 영역(initialized data segment)</li></ol><ol type="1" id="7ab7f94e-7d0e-4870-97ec-b9652e3fbbe2" class="numbered-list" start="2"><li>초기화되지 않은 변수 영역(uninitialized data segment; BSS(Block Started by Symbol))</li></ol></li></ul></div></p><p id="312b244c-eb92-4aa9-9863-5c7c0067948e" class="">3) <strong>[ Heap ]</strong><div class="indented"><ul id="8a97dfc6-05b3-4cc9-aea5-bf7eb41b14a5" class="bulleted-list"><li style="list-style-type:disc">사용자에 의해 관리되는 영역</li></ul><ul id="387c45b2-5a75-44fa-96e1-7f3891066de3" class="bulleted-list"><li style="list-style-type:disc">동적으로 할당할 변수</li></ul><ul id="96df6bef-ad7f-493a-b3b1-2e9e3e457f98" class="bulleted-list"><li style="list-style-type:disc">Java나 C++에서 new 연산자로 생성하는 경우 또는 class, 참조 변수들도 Heap영역에 차지</li></ul><ul id="f9f4a5c7-24ea-4873-9ce4-81a93d45168e" class="bulleted-list"><li style="list-style-type:disc">언어마다 조금씩 상이 → &#x27;동적 할당 영역&#x27;이라고 알면 됨</li></ul><ul id="85f2e11b-7be0-428e-b3cb-5eefc15b61d9" class="bulleted-list"><li style="list-style-type:disc">Heap 영역은 낮은 주소에서 높은 주소로 할당 (적재)</li></ul></div></p><p id="c8d56ffe-5282-48ce-9340-8de44f208f1a" class="">4) <strong>[ Stack ]</strong><div class="indented"><ul id="bdf9a0f0-3cf7-48b5-aeb9-7f503b677409" class="bulleted-list"><li style="list-style-type:disc">함수를 호출할 때 지역변수, 매개변수들이 저장되는 공간</li></ul><ul id="4bacec06-58fc-4618-b36f-c7035f4a30ca" class="bulleted-list"><li style="list-style-type:disc">메인(main) 함수 안에서의 변수들도 당연히 포함됨 → 함수가 종료되면 해당 함수에 할당된 변수들을 메모리에서 해제</li></ul><ul id="276053aa-bacd-4a96-a5ff-9ba3bfc15de6" class="bulleted-list"><li style="list-style-type:disc">함수를 &#x27;재귀&#x27; 호출시 재귀가 깊어져 Stack Overflow 발생 → 재귀를 반복적으로 호출하면서 Stack 메모리 영역에 해당 함수의 지역변수, 매개변수들이 계속 할당되다가 OS에서 할당해준 Stack영역의 메모리 영역을 넘어버리면 발생하는 오류</li></ul><ul id="2ccc8f98-8bfb-47a4-8f2a-2a015d7fe958" class="bulleted-list"><li style="list-style-type:disc">Stack영역은 Heap영역과 반대로 높은 주소에서 낮은 주소로 메모리에 할당</li></ul></div></p><h2 id="412c63d1-14c3-4cac-a6cc-e8ab4f6ad2e6" class="">메모리 주소 (Memory Address)</h2><ul id="5eba974d-2621-433c-b44c-af9d3ab39155" class="bulleted-list"><li style="list-style-type:disc">Window 운영체제 : x86(32비트) 또는 x64(64비트) → 비트의 너비(폭)<p id="c65e0e49-82e5-4031-9ee1-100f23015274" class="">⇒ 64bit 운영체제 : 데이터 처리 단위가 더 많다보니 당연히 CPU 처리도 고속화 되고, 새로운 명령어들도 만들 수 있음. 그렇다보니 그렇다보니 64bit 운영체제에서는 32bit프로그램을 돌릴 수가 있지만, 32bit에서는 64bit용 프로그램을 돌릴 수가 없음</p></li></ul><h3 id="9f60b69a-58af-456a-82f0-fd2774251bd9" class=""><strong>32bit 운영체제와 64bit 운영체제</strong></h3><p id="a1727b7d-6099-4321-a633-7eeeb2ec54b1" class="">⇒ 메모리 한 칸은 1바이트 크기를 가짐 (메모리의 최소 단위)</p><ul id="221b9e0b-a4af-47d4-a4e0-b417de0ae43e" class="bulleted-list"><li style="list-style-type:disc"><strong>32bit 운영체제</strong><ul id="ba075e83-c4fe-4c3a-9d40-5d8848da964e" class="bulleted-list"><li style="list-style-type:circle">메모리 주소의 길이 : 32비트</li></ul><ul id="0e3dd1b8-3c00-4ee7-be3c-30a5cebaa49d" class="bulleted-list"><li style="list-style-type:circle"> 32비트 = 2^32 = 4,294,967,296</li></ul><ul id="382780de-1614-4eff-a470-1e4511674675" class="bulleted-list"><li style="list-style-type:circle">총 4,294,967,296개의 메모리 주소가 있으며 이는 4,294,967,296개의 바이트를 인식할 수 있다는 것을 의미함<p id="710477c0-33cf-4014-bd1b-c6e59c3076e7" class="">⇒ 즉 메모리의 최대 크기는 4,294,967,296 byte = 4GB<div class="indented"><p id="5eca22ae-7441-4f54-bc89-3995cbf3dbce" class="">과거 32비트 운영체제에서는 램을 최대 4GB 밖에 설치하지 못함</p></div></p></li></ul></li></ul><ul id="a5263841-0c5d-45f2-8448-7a4be42f7a5c" class="bulleted-list"><li style="list-style-type:disc"><strong>64bit 운영체제</strong><ul id="4408b3cf-e723-409e-85a0-66ee79c0a95e" class="bulleted-list"><li style="list-style-type:circle">메모리 주소의 길이 : 64비트</li></ul><ul id="ec743385-1ce0-4468-8e60-6e6ff2c3b472" class="bulleted-list"><li style="list-style-type:circle">64비트 = 2^64 = 18,446,744,073,709,551,616</li></ul><ul id="61a8f78c-c021-46b0-a300-c5a10f66b65b" class="bulleted-list"><li style="list-style-type:circle">총 18,446,744,073,709,551,616개의 메모리 주소가 있으며 이는 18,446,744,073,709,551,616개의 바이트를 인식할 수 있음 <p id="5c9c747b-b824-4b6c-913f-711df0db4977" class="">⇒ 18,446,744,073,709,551,616 byte = 16EB(엑사바이트) = 16384TB(테라바이트)<div class="indented"><p id="ad226c87-69aa-4f8b-9b14-e6a4b828e935" class="">이론적으로는 램을 16EB까지 설치 가능하지만 메인보드에서도 지원 한계량이 있어서 대부분 32GB 또는 64GB까지 지원</p></div></p></li></ul></li></ul><hr id="2b2ffd1c-2ab9-44cb-94f1-af7a1367f4ce"/><p id="bd20a82a-5da4-468b-9f3f-5e1d3c0a376b" class=""><strong>&lt; C의 포인터 &gt;</strong></p><p id="bb0c8405-a79c-43a8-bc3f-12a0f7b50dda" class="">포인터는 &#x27;주소&#x27;를 가리키기 때문에 운영체제가 몇비트냐에 따라 주소의 길이가 달라짐</p><ul id="b3211980-026e-44db-afb6-893d3a697ad4" class="bulleted-list"><li style="list-style-type:disc">32bit : 주소의 길이 4바이트, 포인터의 크기 4바이트</li></ul><ul id="3c7462c1-d0ce-46d3-a60b-9db12bd8d271" class="bulleted-list"><li style="list-style-type:disc">64bit : 주소의 길이가 8바이트, 포인터의 크기 8바이트<p id="35c23c49-2c67-4376-a6bb-0af98c2ad6e5" class="">⇒ 이는 1byte가 8bit인 경우</p></li></ul><hr id="01e94d16-8086-431a-b886-4b87b2955eca"/><h2 id="64d306f3-c5e7-4996-89c4-3544cc5a68a3" class="">코드의 메모리 영역 (Code and Memory Layout)</h2><ul id="3193a0e6-4616-4359-bfbb-f3f0f5c07e65" class="bulleted-list"><li style="list-style-type:disc"><strong>상수, 함수</strong> : Text 영역</li></ul><ul id="a4d3bb72-937d-46af-990f-6b236bd1cc05" class="bulleted-list"><li style="list-style-type:disc"><strong>전역, 정적변수</strong> : Data 영역</li></ul><ul id="b01329fa-6dda-4878-b13d-f981e1d5271a" class="bulleted-list"><li style="list-style-type:disc"><strong>지역변수</strong> :  Stack 영역</li></ul><ul id="1a230383-2970-45f4-9222-50e9de16e2d0" class="bulleted-list"><li style="list-style-type:disc"><strong>동적할당이 되는 변수</strong> : Heap영역 (malloc 함수는 런타임(실행중)에 메모리를 동적으로 할당할 수 있는 함수)</li></ul><ul id="98cb5e97-c66e-4e51-9269-c75d944d0b04" class="bulleted-list"><li style="list-style-type:disc">위 4개의 영역 중 Text영역이 가장 낮은 주소(0에 가까운 주소), Data영역이 그 다음 주소, Heap영역이 Data영역의 다음 주소, Stack영역은 4개 영역 중 가장 높은 주소에 위치함</li></ul><h3 id="fd968ff3-95c7-462c-9262-c449c49cb22b" class="">코드 예시</h3><pre id="2e6f2c65-7117-4259-b391-88f1434ded1e" class="code"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
const int constval = 30;    // 상수
 
int uninitial;  // 초기화되지 않은 전역변수
int initial = 30;   // 초기화된 전역변수
static int staticval = 70;  // 정적변수
 
 
int function() {    // 함수
    return 20;
}
 
 
int main(int argc, const char * argv[]) {
    
    int localval1 = 30;   // 지역변수 1
    int localval2;      // 지역변수 2
    
    printf(&quot;숫자 입력 : &quot;);
    scanf(&quot;%d&quot;, &amp;localval2);
    
    char *arr = malloc(sizeof(char) * 10);  // 동적 할당 변수
    
    
    
    /* 포인터 출력 영역 */
    printf(&quot;상수 Memory Address : \t\t %p \n&quot;, &amp;constval);
    printf(&quot;비초기화 변수 Memory Address :\t %p \n&quot;, &amp;uninitial);
    printf(&quot;초기화 변수 Memory Address : \t %p \n&quot;, &amp;initial);
    printf(&quot;정적 변수 Memory Address : \t %p \n&quot;, &amp;staticval);
    printf(&quot;함수 Memory Address : \t\t %p \n&quot;, function);
    printf(&quot;지역변수1 Memory Address : \t %p \n&quot;, &amp;localval1);
    printf(&quot;지역변수2 Memory Address : \t %p \n&quot;, &amp;localval2);
    printf(&quot;동적할당변수 Memory Address : \t %p \n\n&quot;, arr);
   
    
    return 0;
}</code></pre><p id="cd81f10c-bf86-4786-9c8a-89bcb4673d07" class=""><strong>&lt;64bit 운영체제 컴파일 결과&gt;</strong></p><pre id="cc1e7eb9-97ba-46a5-a042-9ab61137c5d8" class="code"><code>숫자 입력 : 30
상수 Memory Address : 0x100000e64
비초기화 변수 Memory Address : 0x100002028
초기화 변수 Memory Address : 0x100002020
정적 변수 Memory Address : 0x100002024
함수 Memory Address : 0x100000d00
지역변수1 Memory Address : 0x7ffeefbff47c
지역변수2 Memory Address : 0x7ffeefbff478
동적할당변수 Memory Address : 0x100508630</code></pre><ul id="f8c3fcca-c7e5-47ae-ac2b-ca391ff14cc6" class="bulleted-list"><li style="list-style-type:disc">상수의 메모리 주소값인 0x100000e64는 실질적으로 0x0000000100000e64을 의미함</li></ul><p id="203f3f28-1878-4884-b3b5-0fd776b46460" class="">1) <strong>상수 :</strong> Text영역 → 다른 변수들과 비교했을 때 가장 낮은주소에 위치함</p><p id="9bc9b2b0-b6f0-4cd6-9e58-7fe57599a3f0" class="">2) <strong>전역변수 : </strong><div class="indented"><ol type="a" id="e171c80b-b28f-41de-b4f0-ff8616b48bba" class="numbered-list" start="1"><li>Data 영역 → 상수보다는 높은 주소에, Heap영역인 동적할당변수보다는 낮은주소에 위치함</li></ol><ol type="a" id="a024ee94-ab88-48a7-bddf-b60e101de4fc" class="numbered-list" start="2"><li>초기화 된 변수들이 더 낮은주소에 위치하고 모두 메모리에 올려지면 그 다음으로 초기화가 안된 변수들이 할당됨</li></ol></div></p><p id="f4965b8b-0baa-4986-a1ec-5f2023bd4998" class="">3) <strong>정적변수</strong> :<div class="indented"><ol type="1" id="561f7db7-e99a-43ab-88c2-017979dbcfc2" class="numbered-list" start="1"><li>Data영역 → 상수 영역에 있는 데이터보단 높은 주소에, Heap영역에 있는 데이터 주소보단 낮은 주소에 자리함</li></ol></div></p><p id="dba7bad6-bf9c-48ba-a63e-4000e6393d03" class="">4) <strong>함수 :</strong><div class="indented"><ol type="1" id="81fcf66f-b539-43c1-a9ec-1297c10fe3f6" class="numbered-list" start="1"><li>상수와 마찬가지로 Text영역 → Data 영역보다 낮은 주소에 위치함</li></ol><ol type="1" id="7a507576-fa6f-4c34-9f68-75fb7591e8c1" class="numbered-list" start="2"><li>Text영역에 있는 함수를 호출함과 동시에 내부에 있는 변수들은 Stack영역에 할당됨</li></ol><ol type="1" id="39fe0e90-5eb5-434b-8d06-7073926b4729" class="numbered-list" start="3"><li>그리고 해당 함수가 종료되면 Stack메모리에 있던 함수의 변수들은 모두 pop됨</li></ol></div></p><p id="6c333396-92f9-4699-8020-f740bdc470cf" class="">5) <strong>지역변수 :</strong><div class="indented"><ol type="1" id="682db515-8082-49dc-b83d-acb3f93250ab" class="numbered-list" start="1"><li> Stack영역</li></ol><ol type="1" id="8d5da3bc-bc2e-47d7-8cb1-7bfeeca8e8a0" class="numbered-list" start="2"><li>Stack영역은 다른 영역과는 다르게 높은주소에서 낮은 주소로 메모리에 할당됨</li></ol><ol type="1" id="49211162-3f5d-4fa9-8854-8ae75aac2491" class="numbered-list" start="3"><li>즉, 어느정도 높은 주소부터 시작하여 지역변수들이 선언될 때마다 낮은주소로 쌓임<p id="29d9d77c-8601-4af9-a0fc-de60b38c13c2" class="">⇒ 먼저 선언한 지역변수1은 0x7ffeefbff47c 이고, 그 다음으로 선언된 지역변수2는 int형 변수이므로 4byte의 크기이니 4칸만큼 작은 주소인 0x7ffeefbff478에 위치함</p></li></ol></div></p><p id="31f9f594-6e46-4745-aec0-7b7ed1acaf48" class="">6) <strong>동적할당 변수 :</strong><div class="indented"><ol type="1" id="c3ba0972-559a-45d9-9714-7f4fde567e2b" class="numbered-list" start="1"><li>Heap영역 → Text, Data보다는 비교적 높은 주소에서 시작하지만, Stack영역에 비해서는 한없이 작은 주소에서 시작함</li></ol></div></p><h2 id="3bec6b19-dcb8-4617-ac0d-2728617fc90d" class="">Buffer Overflow</h2><ul id="2f5d6ec2-bc07-4ef7-b84e-02303dbe17f9" class="bulleted-list"><li style="list-style-type:disc">버퍼(buffer)를 넘치게(overflow)하게 되는 상태를 말하며, 여기서 버퍼는 보통 메모리를 의미함</li></ul><ul id="cfb4e2f6-cf50-4607-b578-208a7d3a8001" class="bulleted-list"><li style="list-style-type:disc">또 다른 말로는 Buffer Overrun이라고도 함</li></ul><ul id="36136c7b-e6c1-4945-9ed7-234885dca0ed" class="bulleted-list"><li style="list-style-type:disc">메모리에서 프로그램이 실행하면서 생성되는 데이터들이 저장되는 대표적인 Heap과 Stack영역에서 해당 버퍼를 인위적으로 넘치게 만들면 인접한 영역까지 침범하게 만들고 결국 포인터 영역까지 침범하게 됨 → 특정 명령을 넣어 프로그램을 붕괴시키거나 시스템의 권한을 상승시킬 수 있음</li></ul><ul id="fa25d855-1bd3-4674-a998-5a631ff32abb" class="bulleted-list"><li style="list-style-type:disc">물론 영역 간의 침범만이 Overflow인 것은 아님 → 메모리에서 할당된 변수의 크기보다 더 큰 데이터를 입력시키는 경우도 Overflow임<p id="cdcd978c-ebbf-4383-a564-e0924be8a012" class="">⇒ 대표적으로 C언어에서 데이터의 크기를 검사하지 않는 strcpy(), gets(), scanf()가 있음</p></li></ul><ul id="bde5d73b-76c6-444f-ba0c-37d6e0740fd6" class="bulleted-list"><li style="list-style-type:disc">즉, Overflow라는 큰 범주 안에 Heap Overflow, Stack Overflow가 있으며, 그 안에서도 데이터 버퍼의 Overflow 메모리 영역에 대한 Overflow가 있음</li></ul><ul id="d9d38f39-e863-464d-b8d9-9fb3cb06bae3" class="bulleted-list"><li style="list-style-type:disc">어떤 개발도구를 사용하고, 어떤 언어를 사용하느냐에 따라 에러 메세지가 조금씩 다를 수 있고, 어떨때는 그냥 프로그램을 중단시켜버릴 수도 있음</li></ul><h3 id="674a4a01-a5d4-479c-8575-3f1e00f5da57" class="">Stack Overflow</h3><ul id="baf7f98e-5334-4365-ae3f-76d302155163" class="bulleted-list"><li style="list-style-type:disc">호출 스택이 할당된 스택 영역 경계선 밖으로 넘어갈 때 발생함<p id="8fd8752c-295f-437a-900b-b1d092b046f7" class="">⇒ &#x27;재귀호출&#x27;에서 가장 흔히 발생함</p></li></ul><ul id="c37cdd27-cb86-4bae-8af9-4040e6ab8911" class="bulleted-list"><li style="list-style-type:disc">아래와 같이 탈출 없이 계속해서 호출되는 재귀함수의 경우 무한히 stack 영역에 데이터가 push되다가 Stack영역을 넘어가버리게 되면 바로 Stack Overflow가 발생</li></ul><pre id="75dc1682-ca1c-4006-b5b1-08bd241f7e60" class="code"><code>#include &lt;stdio.h&gt;
int count = 1;
 
void func() {
    int a = 1;
    int b = 2;
    
    printf(&quot;depth : %d\ta : %p\tb : %p\n&quot;, count, &amp;a, &amp;b);
    count++;
    func();
}
 
int main(int argc, const char * argv[]) {
    func();
}</code></pre><pre id="2449c62f-805d-4654-9043-3cb62f5bc1bc" class="code"><code>0x100000f10 &lt;+0&gt;:  pushq  %rbp                    // 스택에 push
0x100000f11 &lt;+1&gt;:  movq   %rsp, %rbp              // 첫 번째 인자에 두 번째 인자 값 복사
0x100000f14 &lt;+4&gt;:  subq   $0x10, %rsp             // 두 번째 인자에 첫 번째 인자만큼 뺄셈
0x100000f18 &lt;+8&gt;:  movl   $0x1, -0x4(%rbp)          
0x100000f1f &lt;+15&gt;: movl   $0x2, -0x8(%rbp)
0x100000f54 &lt;+68&gt;: callq  0x100000f10             ; &lt;+0&gt; at main.c:12
0x100000f59 &lt;+73&gt;: addq   $0x10, %rsp
0x100000f5d &lt;+77&gt;: popq   %rbp
0x100000f5e &lt;+78&gt;: retq</code></pre><h3 id="b73eaca7-1de8-4095-afb7-e81b4916899d" class="">Heap Overflow</h3><ul id="2367e1e6-ab15-498e-9783-d335782065a3" class="bulleted-list"><li style="list-style-type:disc">Stack Overflow는 힙 영역에서 할당된 영역의 경계선 밖으로 넘어갈 때 발생<p id="2b343c07-c03b-4566-a588-9bba868427a1" class="">⇒ 가장 흔히 발생하는 경우는 매우 큰 데이터를 생성하려고 할 때 발생</p></li></ul><ul id="feb93975-0e52-4cf8-a99e-f3b1853c6124" class="bulleted-list"><li style="list-style-type:disc">마찬가지로 Heap영역보다 큰 데이터가 들어올 경우 발생<p id="e4120c16-5995-47cd-b6ab-0f4863f5bb8f" class="">⇒ Stack에서는 지역변수들이 스택에 쌓인다면, 반대로 Heap 영역에서는 동적으로 관리되는 데이터들이 일정 공간 이상 차지하게 될 경우 발생</p></li></ul><ul id="cfaf363a-daac-4f7e-852d-e2a618253325" class="bulleted-list"><li style="list-style-type:disc">Heap에서 관리하는 데이터 종류 : malloc()같은 동적 할당 함수, 객체, 참조변수<pre id="95159fb9-2591-49ab-ab16-40454ef831c4" class="code"><code>int arr[10];		// C, C++ : Stack 영역
int *arr = new int[10]	// C++ : Heap 영역
int[] arr = new int[10]	// Java : Heap 영역</code></pre><ul id="76e5bc64-bc9e-4a93-a428-dec52783c764" class="bulleted-list"><li style="list-style-type:circle">대표적으로 C 언어에서는 new 연산자가 없음</li></ul><ul id="7e61066b-345a-48b2-9b06-7247ad6a2e62" class="bulleted-list"><li style="list-style-type:circle">int[] 같은 배열의 경우 전역, 정적변수가 아닌이상 Stack 영역에 쌓임</li></ul><ul id="e42927be-d064-40ac-9ac0-6bd8ce5437fb" class="bulleted-list"><li style="list-style-type:circle">동적할당을 하고 싶은 경우 malloc() 같은 함수 사용</li></ul><ul id="34fe81ad-89a6-4098-acba-3c1134dc4da5" class="bulleted-list"><li style="list-style-type:circle">반대로 C++나 Java같은 경우는 new연산자를 지원하고 있어 하나의 객체로 Heap영역에서 관리됨</li></ul></li></ul><p id="60be9aa3-8dc2-452b-8b28-f4f997f7fdaa" class="">
</p></div></article></body>

{% endblock post_content %}