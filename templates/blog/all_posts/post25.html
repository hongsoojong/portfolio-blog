{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(2) 프로세스 관리</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Oct 14, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="8667b3db-0168-4bbe-8cdc-e064d0aac2f1" class="page sans"><div class="page-body"><h2 id="b6c40692-abed-42dc-90b1-5a9667508aeb" class="">프로세스</h2><ul id="824731e1-a19a-467d-8ca0-5732172a8787" class="bulleted-list"><li style="list-style-type:disc">커널에 등록되어 관리를 받는 작업 또는 실행중인 프로그램<ul id="49e842d6-6d06-44aa-a2df-3904d8f206e4" class="bulleted-list"><li style="list-style-type:circle">커널은 프로세스 관리 블록(PCB)에 프로세스에 관한 정보를 저장</li></ul><ul id="81ab5c03-e580-411a-80c8-809403b7c92b" class="bulleted-list"><li style="list-style-type:circle">프로세스틑 시스템 자원을 사용하여 여러 상태 변화를 겪음</li></ul><ul id="cd79b190-69d7-4939-b0c2-0c63dcaff972" class="bulleted-list"><li style="list-style-type:circle">각 프로세스는 유일한 PID를 가짐</li></ul></li></ul><ul id="25ce40a7-2582-42ee-b721-0314ab950d48" class="bulleted-list"><li style="list-style-type:disc">프로세스 예<ul id="0d27ab79-b43d-40ba-b17c-3e5656c82bd9" class="bulleted-list"><li style="list-style-type:circle">init 프로세스는 PID가 1 ⇒ 모든 사용자 프로세스의 조상</li></ul><ul id="0a93f759-63d0-4860-b6d0-41cbb2146860" class="bulleted-list"><li style="list-style-type:circle">필요에 따라 프로세스는 자식 프로세스를 생성함</li></ul></li></ul><h2 id="06f79050-94aa-4a3b-9b78-a76a23d90c36" class="">PID(Process IDentifier)</h2><ul id="65fc82df-39b7-4808-b16c-fe4ac9e59da1" class="bulleted-list"><li style="list-style-type:disc">프로세스 식별자라 하며 유닉스 커널과 같은 운영체계에서 각 프로세스나 서비스를 식별하기 위해 할당하는 고유한 번호</li></ul><ul id="a09a8f4b-dc22-47a5-beb9-e261ecce09b3" class="bulleted-list"><li style="list-style-type:disc">PID는 &quot;fork&quot;라는 시스템 호출에 의해 생성됨. 이와 같이 프로세스가 생성되면 동시에 고유의 번호가 붙는데, 이것을 프로세스 식별 번호(Process IDentity number - PID 번호)라고 함</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="b6d0255c-58af-48d5-8947-7ae7fe42fc34"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>리눅스 환경에서 사용자가 새로운 프로세스를 생성할 수 있는 방법은 fork와 exec의 두 가지가 있음</strong></div></figure><h2 id="10e1433f-2fe9-4a82-ba55-47dadd981a08" class="">프로세스 생성의 목적</h2><p id="efd2b132-fba1-47c8-b873-692155fdad7e" class="">리눅스에서는 두 가지 목적으로 프로세스를 생성함</p><ul id="553f45b0-5a78-46c4-a5d8-149a8657e1e3" class="bulleted-list"><li style="list-style-type:disc">목적 1 : 같은 프로그램 처리를 여러 개의 프로세스가 나눠서 처리<p id="e7ea586a-e1cb-4172-a664-6ccc69f9bba0" class="">⇒ 웹 서버처럼 리퀘스트가 여러 개 들어왔을 때 동시에 처리해야하는 경우</p></li></ul><ul id="9b91fe9e-2ad9-446c-adfe-61575c010d6c" class="bulleted-list"><li style="list-style-type:disc">목적 2 : 전혀 다른 프로그램 생성<p id="d85da817-a2e5-48c1-a3e8-9726da534402" class="">⇒ bash로부터 각종 프로그램을 새로 생성하는 경우</p></li></ul><h2 id="3360d50c-5995-456e-bd79-f8797b80b827" class="">fork() 함수</h2><ul id="f2650ea1-db3a-4f41-bf4a-e0ed42a45937" class="bulleted-list"><li style="list-style-type:disc">목적 1에 해당하며, 같은 프로그램 처리를 여러 개의 프로세스가 나눠서 처리하기 위해 사용되는 함수</li></ul><ul id="0c9e883a-8376-454b-8baf-bbef4fa1e6e1" class="bulleted-list"><li style="list-style-type:disc"><code>fork()</code> 함수를 실행하면 기존 실행한 프로세스와 함께 새로운 프로세스 1개가 생성됨<ul id="c3be432f-cb9f-43b9-aff7-048bee6f9c9f" class="bulleted-list"><li style="list-style-type:circle">부모 프로세스(parent process)</li></ul><ul id="215e94a1-483a-4a8b-85cf-2ba4b7f00b6f" class="bulleted-list"><li style="list-style-type:circle">자식 프로세스(child process) : 새롭게 생성된 프로세스</li></ul></li></ul><ul id="dbfc8747-78d6-4e98-b147-73475efc54df" class="bulleted-list"><li style="list-style-type:disc"><code>fork()</code> 함수 호출 이후 코드부터 각자의 메모리를 사용하여 실행됨</li></ul><p id="219b02d0-effe-47e6-afdb-3c2c4c846de6" class=""><strong>&lt;프로세스의 생성 순서&gt;</strong><div class="indented"><p id="3918fb9c-d5ef-4735-aff5-e76ffb8d8924" class="">1) 자식 프로세스용 메모리 영역을 작성하고, 거기에 부모 프로세스의 메모리를 복사함</p><p id="84ca6f70-670f-4bb6-b197-79c1a9efe7d7" class="">2) <code>fork()</code> 함수의 리턴값이 각기 다른 것을 이용하여 부모 프로세스와 자식 프로세스가 서로 다른 코드를 실행하도록 분기함</p><ul id="a4997ee5-60ed-407c-acee-73a56a965753" class="bulleted-list"><li style="list-style-type:disc"><code>fork()</code> 함수를 리턴(반환)할 때, <ul id="1710a34b-dbbb-474e-9ae0-b3fe3fc350b9" class="bulleted-list"><li style="list-style-type:circle">부모 프로세스는 자식 프로세스의 프로세스 ID를</li></ul><ul id="02ac6129-efb1-4140-a140-0e6e88dedc04" class="bulleted-list"><li style="list-style-type:circle">자식 프로세스는 0을 리턴 함</li></ul></li></ul></div></p><h2 id="3e45f725-85b3-45d4-9389-36feeb9b7da6" class="">execve() 함수</h2><ul id="8b5c871e-899e-400b-bacf-9a6a5f702f6e" class="bulleted-list"><li style="list-style-type:disc">목적 2에 해당하며, 전혀 다른 프로그램을 생성할 때 사용되는 함수</li></ul><p id="61654454-402a-4f84-b0b0-caa99645b72c" class=""><strong>&lt;각각의 프로세스 실행을 위한 커널의 흐름&gt;</strong><div class="indented"><p id="850273f5-466d-4a67-b5be-28c2118662ea" class="">1) 실행파일을 읽은 다음 다음 프로세스를 메모리 맵에 필요한 정보를 읽어 들임</p><p id="6cf8e36b-bf80-41c1-afa5-12721d9ff200" class="">2) 현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어씀</p><p id="889f6ec2-4820-42dd-95d2-bd64b2b97618" class="">3) 새로운 프로세스의 첫 번째 명령부터 실행함</p><ul id="ac2414c0-4594-45d0-b878-8f7bb0514797" class="bulleted-list"><li style="list-style-type:disc">즉, 전혀 다른 프로그램을 생성하는 경우 프로세스의 수가 증가하는 것이 아닌 기존의 프로세스를 별도의 프로세스로 변경하는 방식으로 수행됨</li></ul></div></p><h3 id="2ac25d9b-391a-4c72-a664-4ab7018229ab" class="">fork and exec</h3><ul id="62654e7e-8eca-4177-b66e-cd7e5e67fb06" class="bulleted-list"><li style="list-style-type:disc">전혀 다른 프로세스를 새로 생성할 때 부모가 될 프로세스로부터 fork() 함수를 호출한 다음 돌아온 자식 프로세스가 exec() 함수를 호출하는 방식을 주로 사용함</li></ul><p id="b795052f-7eef-4a39-8077-7d977311be6d" class=""><strong>&lt;프로세스의 생성 순서&gt;</strong><div class="indented"><p id="837e94e5-eccb-4e89-ae5a-28127830d1ce" class="">1) 시스템 호출 <code>fork()</code>를 호출하여 기존 부모 프로세스가 자신의 복사본 자식 프로세스를 만듦</p><p id="82c68b62-7dba-4768-986d-a85682ca62c1" class="">2) 자식 프로세스는 시스템 호출 <code>exec(program)</code>에 의해 새로운 프로그램으로 대체되어 실행됨</p><p id="e1f6f32e-60cc-4efd-b053-a500c11ce577" class="">3) 프로그램이 종료되면 자식 프로세스가 종료됨</p><p id="6d5a7b4e-405d-425e-960a-35ef5f1592a5" class="">4) 부모 프로세스는 보류 상태에 있다가 자식 프로세스가 종료되면 깨어남</p></div></p><h2 id="74f7c57f-5222-4db5-b779-520723e53912" class="">정리</h2><h3 id="37bddc0c-b533-4cc2-8034-0b40851d1ef1" class="">fork()</h3><ul id="a8be222f-13a3-4a7c-bd1e-e953a2aeb8b6" class="bulleted-list"><li style="list-style-type:disc">자식 프로세스를 만듦</li></ul><ul id="e66d0211-387c-4237-82aa-2798670b7f7a" class="bulleted-list"><li style="list-style-type:disc"><code>fork()</code> 시스템 호출은 어떤 프로세스가 자신의 사본을 생성하는데 사용</li></ul><ul id="46037c02-3eb0-4921-aaa2-757d21bec547" class="bulleted-list"><li style="list-style-type:disc">이 때 <code>fork()</code>를 부른 프로세스를 부모 프로세스라 부르고, 새로 생성된 프로세스를 자식 프로세스라고 부름</li></ul><ul id="fbb1ba9e-4f80-4d55-b6f7-6f93f800a17e" class="bulleted-list"><li style="list-style-type:disc">이와 같은 방법은 프로세스의 수를 증가시키기 위한 전통적인 기법으로 <code>fork()</code> 후에는 프로세스 아이디(PID)만 다르고 두 개가 거의 동일한 프로세스인 부모(Parent)와 자식(Child)이 생김</li></ul><h3 id="d17909b0-ecd2-4add-aa44-bfd4cf71fefd" class="">exec()</h3><ul id="62d4d4ad-adad-4ba7-bd1f-4afd7d8b4650" class="bulleted-list"><li style="list-style-type:disc">실행된 프로세스가 새로운 프로세스를 호출해야 하는 경우에 사용</li></ul><ul id="5f4f0952-573f-40db-b70e-7b2963d5d557" class="bulleted-list"><li style="list-style-type:disc"><code>exec</code>는 호출하는 프로세스를 새로운 프로세스로 변경하는 데 사용되며, 호출하는 프로세스의 특성이 변하지 않는 한 시스템 내의 총 프로세스 수는 변하지 않음</li></ul><ul id="2a2d7d55-dfb0-4b7b-ac87-a8807649aa40" class="bulleted-list"><li style="list-style-type:disc"> 즉, <code>exec()</code> 시스템 호출은 프로세스의 메모리 공간을 수행 가능 파일로 대체하여 다른 프로그램을 호출함</li></ul><h2 id="99861e59-1892-4178-8cff-6a3e9ebce185" class="">종료처리</h2><ul id="03322517-814b-40a4-ae68-f1d67d96b887" class="bulleted-list"><li style="list-style-type:disc"><code>_exit()</code> 함수 사용<p id="0137bf0c-cc56-4aba-a2d8-7abda808d2e6" class="">⇒ 내부에서는 <code>exit_group()</code> 시스템 콜을 호출하여 프로세스에 할당된 메모리를 전부 회수함</p></li></ul><ul id="6afdbcff-2470-48b4-8487-1395c2a7d578" class="bulleted-list"><li style="list-style-type:disc">직접 <code>_exit()</code>를 호출하는 일은 매우 드물며, 보통 표준 C 라이브러리의 <code>exit()</code> 함수를 호출해서 종료함. 이 경우 표준 C 라이브러리는 자신의 종료 처리를 전부 수행한 뒤에 <code>_exit()</code> 함수를 호출함</li></ul><ul id="f31a91cf-67a8-4638-bf29-932aa7109337" class="bulleted-list"><li style="list-style-type:disc"><code>main()</code> 함수로부터 리턴된 경우에도 같은 동작을 실시함</li></ul><p id="13025b5b-ce93-4a44-afce-5c5ad6b1bcd4" class="">
</p></div></article></body>

{% endblock post_content %}