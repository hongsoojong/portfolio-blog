{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(5) 포인터</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 17, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="dbd43f44-0244-4a79-88cb-724f79b05580" class="page sans"><div class="page-body"><pre id="7a05a526-df12-4b4c-958d-f80a332151c9" class="code"><code>/* 메인 함수 */

    int my_nums[5];           /* {0, 1, 2, 3, 4} */
    process(my_nums, 5);
    
    void process(int nums[], const size_t n) {
        size_t i;
        for (i = 0; i &lt; n; ++i) {
            nums[i] *= 2;
        }
    }</code></pre><h3 id="9b246b98-76c5-44a8-87e8-1c46496f20fa" class="">주소를 사용해서 메모리 내 변수 접근</h3><ul id="c397f980-b01a-4279-a1c2-765e98703b79" class="bulleted-list"><li style="list-style-type:disc">다른 언어였다면 불가능</li></ul><ul id="5c6c2549-526d-47b1-bf0d-d89c3c50915b" class="bulleted-list"><li style="list-style-type:disc">하지만 C는 하드웨어와 가장 친한 친구로 가능</li></ul><ul id="35ff3615-60ba-48f8-b5ee-ed7d504212d4" class="bulleted-list"><li style="list-style-type:disc">이것을 활용하여 매우 강력한 일을 할 수 있음</li></ul><h2 id="59d1f8dd-72d4-4eba-a7be-5480b315142c" class="">주소연산자 &amp;</h2><pre id="d1a64a26-90a3-4cee-b475-f0b77469398e" class="code"><code>#include &lt;stdio.h&gt;
    
    void print_address(void)
    {
        int num = 10;
        printf(&quot;Address of num : %p\n&quot;, (void)&amp;num);
    }
    
    int main(void)
    {
        print_address();
    
        return 0;
    }</code></pre><ul id="81291463-0ebf-4b13-83b6-8bfb6ba9e3e0" class="bulleted-list"><li style="list-style-type:disc">일단 어떤 변수가 어느 주소에 저장되어 있는지 알 수 있는 첫 단계</li></ul><ul id="87a0e58b-6323-49c5-86da-22348bbda239" class="bulleted-list"><li style="list-style-type:disc">비트 연산자 <code>&amp;</code>가 아님<p id="016c1d7b-28e7-4fea-82ad-826b31e7058e" class="">⇒ 비트 연산자는 피연산자가 2개, 주소 연산자는 피연산자가 1개</p><pre id="882ab244-4980-4fe0-ab79-0f7dea156058" class="code"><code>const unsigned char result = num1 &amp; num2;          /* 비트 연산자 */
    printf(&quot;Address of num : %p\n, (void)&amp;num);        /* 주소 연산자 */</code></pre></li></ul><ul id="cf0c8a9f-0ba7-4cd0-a8a3-33c3eb0b034a" class="bulleted-list"><li style="list-style-type:disc"><code>num</code>이란 변수가 있으면 <code>&amp;num</code>은 그 변수가 위치한 메모리 주소</li></ul><ul id="54142562-70a0-48c3-8de5-d98236846faa" class="bulleted-list"><li style="list-style-type:disc">보통 주소를 보여줄 때는 16진수를 사용 → <code>printf()</code>에서 서식문자 <code>%p</code>는 주소를 16진수로 보여줌</li></ul><ul id="fb5323de-1de1-4f2c-aeed-84c95233a7f2" class="bulleted-list"><li style="list-style-type:disc">실행할 때마다 주소가 달라질 수 있음 → 요즘 운영체제에서는 보안강화를 위해 실행할 때마다 주소를 바꿔줌(ASLR)</li></ul><h3 id="157dbd97-1851-4aa0-98e7-621cdcef352d" class="">메모리 주소 저장하기</h3><p id="b06c2042-3875-497e-b1c6-e116ec97dccf" class=""><strong>&lt;의문점&gt;</strong></p><ul id="2b99027e-6c23-4099-8b90-248cc7bfc4c1" class="bulleted-list"><li style="list-style-type:disc">주소를 구할 때마다 그 변수가 필요하다면 그냥 그 변수를 쓰고 말지</li></ul><ul id="0f3d970e-f572-472f-9e89-fc14d66dbf5b" class="bulleted-list"><li style="list-style-type:disc">그보다는 그 주소를 어딘가에 저장해 둘 수 있다면 좋을 것 같은데..</li></ul><ul id="af73a112-1a58-475c-9b84-2d175a6eac43" class="bulleted-list"><li style="list-style-type:disc">그러면 변수가 없어도 주소만으로 여기저기 옮겨다닐 수 있을텐데..<p id="5c404a32-40b3-4f26-8a27-4bf459d9694a" class="">⇒ 가령 &#x27;변수의 주소&#x27;의 다음 메모리 위치를 읽는다던가</p></li></ul><p id="114c713b-d509-48f6-ab85-d50b9ef531c6" class=""><strong>&lt;메모리 주소를 변수처럼 저장 시도&gt;</strong></p><pre id="1c2834d9-d4f6-40b9-9568-b446baf2c831" class="code"><code>/* 컴파일 오류 발생 */
    
    
    void try_save_address(void)
    {
        int num = 10;
        int num_address = &amp;num;
    }</code></pre><p id="73fcceb7-19ca-4f3f-bfa9-3cb0ccf79b3b" class="">&lt;<strong>문제점</strong>&gt;</p><pre id="735a4761-e55e-4177-97e0-63cce1c5dc62" class="code"><code>void play_game(void)
    {
        int a = 202020;
        int b = 202020;
    }</code></pre><ul id="cc7be87c-74b0-4c0a-b10d-f9137fd66a77" class="bulleted-list"><li style="list-style-type:disc">둘 중 무엇이 &#x27;주소&#x27;고 무엇이 &#x27;값&#x27;인지 알 수 없음</li></ul><ul id="ec8cc8de-714b-4f08-a94e-4fded36409fe" class="bulleted-list"><li style="list-style-type:disc">따라서 주소를 저장하기 위한 특별한 변수가 필요함 ⇒ 포인터</li></ul><h2 id="04e432f9-6c78-4d92-bebe-11b418c38a5e" class="">포인터의 의미</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9083606c-5e3f-4461-a360-1a29e5f29557"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>포인터는 메모리 주소를 저장하기 위한 변수형으로, 여기서 주소는 값이 저장되어 있는 메모리의 위치를 말한다.</strong></div></figure><ul id="d0e74142-01bc-4559-9ab9-a0548a269f67" class="bulleted-list"><li style="list-style-type:disc"><strong>주소를 저장하기 위한 변수형</strong></li></ul><ul id="d24f0649-27af-4fd9-bde9-1a8d6e0f8255" class="bulleted-list"><li style="list-style-type:disc">즉, 변수인데 속에 담긴 내용은 메모리 주소를 의미함<p id="3db3185d-70d7-4cf2-8da3-ad45db51ddb1" class="">⇒ 주소 : 값이 저장되어 있는 메모리의 위치</p></li></ul><h3 id="6d1e6a50-6d38-4103-a067-6b09bca841b1" class="">메모리 주소에 저장된 자료형</h3><ul id="fb33cc7d-c463-4c48-984c-04b5c74bac6f" class="bulleted-list"><li style="list-style-type:disc">하드웨어는 신경 안씀<p id="2d76848b-d976-461f-bdf3-b1d058185ea9" class="">⇒ 그 비트패턴을 <code>char</code>로 읽으면 <code>char</code>, <code>int</code>로 읽으면 <code>int</code>, <code>float</code>으로 읽으면 <code>float</code>이 됨</p></li></ul><ul id="e5a4f591-2aed-4c53-9ee8-7dd38c75bb4b" class="bulleted-list"><li style="list-style-type:disc">그러나 해당 주소에서부터 몇 바이트를 읽어야하는지는 하드웨어에게 알려줄 필요가 있음. 그래서 포인터 변수를 선언할 때는 &#x27;그 주소에 어떤 형의 데이터가 있는지&#x27; 명시하기 위해 포인터 앞에 자료형을 붙임 (<code>int</code> 포인터, <code>float</code> 포인터, <code>char</code> 포인터)</li></ul><h3 id="8ecd6e7a-e469-4280-ba26-f39b601f0d27" class="">포인터 변수를 선언하는 법 / 부르는 법</h3><pre id="6681894f-bdb2-4e71-8dce-902d86ce03bf" class="code"><code>void save_address(void)
    {
        int num = 10;
        int* num_address = &amp;num;
    }</code></pre><ul id="2eb33f78-3206-4e54-9f7f-d132b3c589e0" class="bulleted-list"><li style="list-style-type:disc">포인터 변수를 선언하려면 자료형 뒤에 별표(<code>*</code>)를 붙임</li></ul><ul id="8ab06e56-01a6-4202-bf78-a7328fb97813" class="bulleted-list"><li style="list-style-type:disc">별표 왼쪽에 있는 자료형은 그 메모리 주소로 가면 저장되어 있는 자료형<ol type="a" id="fc98b515-2353-4fde-bdd4-ed09cb5440d8" class="numbered-list" start="1"><li><code>int*</code> : 주소를 따라가면 <code>int</code>형 자료가 있음</li></ol><ol type="a" id="5a64a06e-9acc-4692-9dd7-262ac94a17c2" class="numbered-list" start="2"><li><code>char*</code> : 주소를 따라가면 <code>char</code>형 자료가 있음</li></ol><ol type="a" id="e15a6050-7ea4-4a76-8070-daf77af1b373" class="numbered-list" start="3"><li><code>float*</code> : 주소를 따라가면 <code>float</code>형 자료가 있음</li></ol></li></ul><ul id="3410cb86-9178-4c8f-8d8b-1905557d9686" class="bulleted-list"><li style="list-style-type:disc">보통 <code>num_adress</code>를 int 포인터라고 부름<p id="adc7e3c8-21df-487b-9950-b32ae09a7d8c" class="">⇒ 영어로는 <code>int</code>로의 포인터(pointer to an int)라고도 함 (뒤에서부터 읽음)</p></li></ul><h3 id="de1a945b-b963-4e27-8121-16aae4cbf568" class="">포인터 변수의 저장 위치</h3><ul id="0192b4d3-f2f2-4021-b585-329de78684c4" class="bulleted-list"><li style="list-style-type:disc"><strong>포인터는 메모리 주소를 저장하는 변수</strong></li></ul><ul id="0e06dfdd-b84f-41e0-9079-9337cdb7fe0a" class="bulleted-list"><li style="list-style-type:disc">그러면 이 변수는 어디에 저장이 되어 있는가 → 메모리 어딘가</li></ul><ul id="4ef11b8f-88f0-4e54-86e8-8a1c8fbeec37" class="bulleted-list"><li style="list-style-type:disc">아래와 같이 저장이 되어 있음</li></ul><ul id="cae4987b-3028-4c84-af47-a9ede4f52c5a" class="bulleted-list"><li style="list-style-type:disc">하지만 이렇게 기억하면 나중에 &#x27;이중 포인터&#x27;가 나올 때 헷갈릴 수 있음</li></ul><ul id="a424863e-ee7c-45d2-9333-9700658cb9b8" class="bulleted-list"><li style="list-style-type:disc"><strong>따라서 기본 개념은 &quot;메모리 주소를 저장하는 변수&quot;라고 기억하고 시각적으로 보는게 필요하면 그려보는게 좋음</strong></li></ul><h3 id="d641b392-06cf-4809-81ec-9e78af0348f0" class="">포인터에 저장된 주소도 바꿀 수 있는가?</h3><ul id="d4df5fa7-e5e7-4d24-abc7-e5e996089a00" class="bulleted-list"><li style="list-style-type:disc">포인터도 변수이기 때문에 포인터에 저장한 값도 변경 가능</li></ul><ul id="da6d291b-7f80-400d-ab4c-b5fc6c16c515" class="bulleted-list"><li style="list-style-type:disc">즉, 다른 주소로 바꿀 수 있음</li></ul><pre id="b0018da7-02f1-4e16-83ca-46be1d16cbc1" class="code"><code>void change_pointer(void)
    {
        char ch1 = &quot;C&quot;;
        char ch2 = &quot;z&quot;;
    
        char* pointer = &amp;ch1;
        printf(&quot;%p: %c\n&quot;, (void*)pointer, *pointer);
        /* 008FFA73 : C */
    
        pointer = &amp;ch2;
        printf(&quot;%p: %c\n&quot;, (void*)pointer, *pointer);
        /* 008FFA73 : C */
        /* 008FFA72 : z */
    }</code></pre><h2 id="20032045-d336-4965-817b-25e73e991d30" class="">역 참조 연산자 *</h2><ul id="8def51ad-919f-49c4-93a1-1930d7ab03d5" class="bulleted-list"><li style="list-style-type:disc">포인터도 변수니까 당연히 변수 쓰는 곳에는 다 쓸 수 있음</li></ul><ul id="6f787c3c-bc05-4ad4-92dc-8910646fe43f" class="bulleted-list"><li style="list-style-type:disc">따라서 매개변수도 가능</li></ul><ul id="cf406031-6cb9-466b-ba65-f4e0c17454ec" class="bulleted-list"><li style="list-style-type:disc">곱하기 연산자가 아님<p id="4916eec8-e8b9-4119-9f25-b113f18803a4" class="">⇒ 곱하기 연산자는 피연산자 2개, 역 참조 연산자는 피연산자가 1개</p><pre id="ab179424-7d36-4c44-a7e6-f223d33d300b" class="code"><code>const int result = num1 * num2         /* 곱하기 연산자 */
    printf(&quot;num : %d\n&quot;, *num);            /* 역 참조 연산자 */</code></pre></li></ul><p id="cad481b9-fe2e-4873-8fcd-b6cf4eaef352" class=""><strong>&lt;예시&gt;</strong></p><pre id="1a07c086-2b05-4945-8fb9-5f4423f004d4" class="code"><code>void print_address(int* num)
    {
        printf(&quot;address of num: %p\n, (void*)num);
    }
    
    /* 메인 함수 */
    int score = 88;
    print_address(&amp;score);</code></pre><p id="89b241b1-b116-4e78-8c85-d1f79bf4feb4" class="">⇒ 하지만 위의 함수는 단순히 주소만 보여주며 별 의미있는 함수가 되지 못함</p><pre id="7a6b287d-ffb4-4fa5-bca4-d9026a193002" class="code"><code>void print_value(void)
    {
        int score = 100;
        int* pointer = &amp;score;
    
        printf(&quot;score: %d\n&quot;, *pointer);
    }
    
    void print_argument(float* arg)
    {
        pinrtf(&quot;argument: %f\n&quot;, *arg);
    }
    
    /* 메인 함수 */
    float pi;
    
    print_value();
    
    pi = 3.14f;
    print_argument(&amp;pi);
    </code></pre><pre id="63e45c0b-761d-46e0-b573-dc5898f54504" class="code"><code>&gt; a.exe
    score: 100
    argument: 3.140000</code></pre><h3 id="ec5eedf6-6596-424c-9b09-76afc8339ac5" class="">참조와 역 참조</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="b5016229-e13e-46f7-946a-4f1d814659cd"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>참조는 포인터가 하고 있는 일로, 값이 어디에 있는지 가리키고 있는 것을 의미한다. 역 참조는 주소로 직접 가서 거기에 저장되어 있는 값에 접근하는 것이다. 이제까지는 모든 데이터를 복사해서 썼다면 역 참조를 통해 원본에 접근이 가능하다.</strong></div></figure><p id="5289bb52-40d9-468c-8136-a2bc7953a1c1" class="">1) 참조<div class="indented"><ul id="dffe5d65-a406-4c08-8396-26e87111e0ad" class="bulleted-list"><li style="list-style-type:disc">포인터가 이미 하고있는 일</li></ul><ul id="0d417777-f10d-4696-b84c-743fc9e26604" class="bulleted-list"><li style="list-style-type:disc">어떤 변수의 값을 직접 가져다 쓰는 게 아니라 그게 어디에 있는지 &#x27;참조&#x27;</li></ul><ul id="e1995777-5c89-4c80-adb5-9d5aa46df005" class="bulleted-list"><li style="list-style-type:disc"><strong>즉, 값이 어디에 있는지 가리키고 있는것</strong></li></ul></div></p><p id="8a77d174-3997-40ae-a606-ee7c3a3c80b4" class="">2) 역 참조<div class="indented"><ul id="c8d1e4eb-8aa2-42f6-987f-a34f1ee7e537" class="bulleted-list"><li style="list-style-type:disc"><strong>주소로 직접 가서 거기 저장되어 있는 값에 접근하는 것</strong></li></ul><ul id="1f2cded5-e1cb-4837-b828-52cf53b4a5d1" class="bulleted-list"><li style="list-style-type:disc">참조(reference)의 반대라 역 참조(de-reference)라 말함</li></ul><ul id="92ca0c13-3790-4b29-9e1f-9ce457567a17" class="bulleted-list"><li style="list-style-type:disc">값에 직접 접근하는게 아니라 주소를 이용해 간접적(한 단계 거쳐서)으로 접근</li></ul><ul id="153c7e65-6a5c-4e6f-b34b-e3d67516268f" class="bulleted-list"><li style="list-style-type:disc">따라서 간접(indirect) 연산자라고도 함<p id="ea4c0f3f-e06a-4d56-a3ad-3f253d37bb53" class=""><strong>⇒ 여태까지는 모든 데이터를 복사해서 썼다면 이는 원본에 접근 가능</strong><div class="indented"><p id="560d9715-5f25-4b18-a14b-a8ab754f3a3f" class="">컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법</p></div></p></li></ul></div></p><h3 id="8dfb715c-a8fa-4406-ad86-03c754c8bb2f" class="">역 참조를 통해 값을 변경하는 예</h3><pre id="23bf1d91-00a5-4b86-8e16-60c31296ec4a" class="code"><code>void update_value(void)
    {
        int score = 100;
        int* pointer = &amp;score;
    
        printf(&quot;score: %d\n&quot;, *pointer);
        *pointer = 50;
        printf(&quot;updated score: %d\n&quot;, *pointer);
    }
    
    void update_argument(float* arg)
    {
        printf(&quot;argument: %f\n&quot;, *arg);
        *arg = 93485.2f;
        printf(&quot;updated argument: %f\n&quot;, *arg);
    }</code></pre><pre id="f71326b1-963b-4446-93fc-61cc642b0d1b" class="code"><code>score: 100
    updated score: 50
    argument: 3.140000
    updated argument: 93485.203125</code></pre><pre id="eb2a4bab-9b02-4e36-84f0-c04969f5f85a" class="code"><code>/* 다음 두 코드는 결과적으로 같음 */
    
    int score = 100;
    score = 50;
    
    int score = 100;
    int* pointer = &amp;score;               /* 포인터 변수 선언(*) */
    *pointer = 50;                       /* 역 참조(*) */</code></pre><h3 id="9205250b-eb14-403e-91ca-9ab485bdb5dc" class="">퀴즈</h3><pre id="f556e581-84a6-4558-b68f-08745ad9841e" class="code"><code>#include &lt;stdio.h&gt;
    
    int main(void)
    {
        int num1 = 15;
        int num2 = 30;
        int num3 = 45;
    
        int* ptr1 = &amp;num1;
        int* ptr2 = &amp;num2;
        int* ptr3 = &amp;num3;
    
        ptr1 = ptr2;
        ptr2 = ptr3;
    
        *ptr3 *= 2;        
        *ptr1 += *ptr3;   
        *ptr2 *= 2;        
    
        printf(&quot;%d %d %d&quot;, num1, num2, num3);
    
        return 0;
    }
    
    /* 정답 : 15, 120, 180 */
    </code></pre><h3 id="b30768b5-e78f-442e-a3f6-7c2c998fd34a" class="">swap()</h3><pre id="704301ca-5bdb-472d-9098-55bb9540bbec" class="code"><code>void swap(int num1, int num2)
    {
        int tmp;
    
        tmp = num1;
        num1 = num2;
        num2 = tmp;
    }
    
    #include &lt;stdio.h&gt;
    int main(void)
    {
        int num1 = 20;
        int num2 = 10;
    
        printf(&quot;num1: %d, num2: %d\n&quot;, num1, num2);       /* num1 : 20, num2 : 10 */
        swap(num1, num2);
        printf(&quot;num1: %d, num2: %d\n&quot;, num1, num2);       /* num1 : 20, num2 : 10 */
    
        return 0;
    }</code></pre><ul id="aded1715-58e9-4edb-a2ea-6c3c2e907e6a" class="bulleted-list"><li style="list-style-type:disc">실제로 교체되지 않음</li></ul><ul id="cc01c958-1fc4-4c89-8172-3addb6ca7288" class="bulleted-list"><li style="list-style-type:disc">스택 메모리에서 값을 복사하기 때문</li></ul><ul id="451b66cf-394e-42ce-be9b-019059dd6d8c" class="bulleted-list"><li style="list-style-type:disc">C#에서는 <code>ref</code> 키워드로 해결, 하지만 C는 그런 키워드 없음<p id="1051bd29-95b2-484b-afb5-df685a31db4d" class="">⇒ 포인터로 해결 가능</p></li></ul><pre id="6c062e0e-0769-42a4-a897-553fd1ec6f46" class="code"><code>void swap(int* arg1, int* arg2)
    {
        int tmp;
    
        tmp = *arg1;
        *arg1= *arg2;
        *arg2= tmp;
    }
    
    /* 메인 함수*/
    
        int num1 = 20;
        int num2 = 10;
    
        swap(&amp;num1, &amp;num2)
        printf(&quot;num1: %d, num2: %d\n&quot;, num1, num2);       /* num1 : 10, num2 : 20 */
    
        return 0;
    }</code></pre><h3 id="1d2a8808-1d31-4c5a-8968-240e815a2edc" class="">값에 의한 전달 vs 참조에 의한 전달</h3><ul id="c34ff01a-a847-420f-b4c8-22f3c7d938d1" class="bulleted-list"><li style="list-style-type:disc">원본이 바뀌니 ⇒ 참조에 의한 전달</li></ul><ul id="cecd052d-62b6-4c55-b352-e86a718ebf81" class="bulleted-list"><li style="list-style-type:disc">하지만 메모리 주소를 복사하였으니 ⇒ 값에 의한 전달</li></ul><ul id="41bb67f1-44a1-4601-b6e0-6b5200a89af2" class="bulleted-list"><li style="list-style-type:disc">함수를 호출할 때 언제나 변수를 복사하므로 값에 의한 전달</li></ul><ul id="32524367-5a8a-4e97-816b-ace11d0e80bb" class="bulleted-list"><li style="list-style-type:disc">단, 포인터를 사용해서 참조에 의한 전달을 흉내낼 뿐</li></ul><ul id="8658076f-7913-4d11-b9e3-c912d2bbde29" class="bulleted-list"><li style="list-style-type:disc">원본이 바뀌는지 안 바뀌는지가 핵심 포인트임</li></ul><ul id="44203f6c-7e19-4e4a-88e5-c427ad0fed14" class="bulleted-list"><li style="list-style-type:disc">굳이 &#x27;~에 의한 전달&#x27;이라고 말해야 한다면 &#x27;참조에 의한 전달&#x27;이라고 말하는게 차라리 나음</li></ul><h2 id="88c41ff3-0b1f-4507-8cf8-0d10f7ebd6d3" class="">포인터와 함수 반환값</h2><ul id="edc28477-ec28-46ae-a602-d882246e1cfa" class="bulleted-list"><li style="list-style-type:disc">당연히 포인터도 변수니까 함수 반환값으로 사용 가능</li></ul><ul id="e21a7dfa-bf01-43e6-b2b1-5381506a263c" class="bulleted-list"><li style="list-style-type:disc">다만 포인터를 반환할 때 조심해야할 것들이 있음</li></ul><h3 id="7c4df117-b8d9-4c70-800a-564eb81beef4" class="">댕글링 포인터(dangling pointer)</h3><pre id="740b9335-66e1-407b-bd23-7b81dcca586d" class="code"><code>int* add(const* int op1, const int op2)
    {
        int result = op1 + op2
    
        return &amp;result
    }
    
    int main(void)
    {
        int* result;
        result = add(10, 20);
    
        return = 0;
    }
    
    /* warning 발생: return &amp;result */</code></pre><ul id="15ab8e73-512e-459b-adf1-3da56a4f28ae" class="bulleted-list"><li style="list-style-type:disc">함수의 지역변수는 스택에 저장됨<p id="8446772d-241c-46ca-a8e2-5dc590863cd5" class="">즉, 함수의 호출이 끝나면 지역 변수도 사라짐 (<code>return</code> <code>&amp;result</code>)</p></li></ul><ul id="3943dd97-77da-4695-997f-02d26e2180c1" class="bulleted-list"><li style="list-style-type:disc">그러나 지역변수가 사용한 &#x27;주소&#x27;자체가 사라지는 것은 아님</li></ul><ul id="af7dacf1-5a2f-40ab-8657-ae9825e9b313" class="bulleted-list"><li style="list-style-type:disc">따라서 그 주소를 반환한다고 컴퓨일 오류가 나지는 않음<p id="4a7db692-cbf9-4900-a336-fbc14811fc67" class="">⇒ 컴파일러에 따라 상기와 같은 경고를 줄 수 있음</p></li></ul><ul id="fb79b7b0-5b4f-463b-a5d4-5cabd099665d" class="bulleted-list"><li style="list-style-type:disc"><strong>문제는 포인터가 유효하지 않은 주소를 가리킴</strong><p id="75acec12-2bcf-429d-a4ea-1a085d5a97f2" class="">⇒ 이 경우 예측하지 못한 결과가 발생할 수 있음</p></li></ul><ul id="76582628-7677-4702-97ce-fd80028e6bab" class="bulleted-list"><li style="list-style-type:disc">이러한 포인터를 댕글링 포인터라고 하며, <strong>절대 작성해서는 안되는 코드</strong>임</li></ul><h3 id="759f303a-8190-4d6f-a8fd-2292553f08eb" class="">포인터와 함수 반환값 정리</h3><ul id="544dadbf-4590-4195-8492-6efba8dea80b" class="bulleted-list"><li style="list-style-type:disc">포인터를 반환할 경우 댕글링 포인트를 조심해야함</li></ul><ul id="2b61726f-d98d-4b4f-9d32-3be9ada44c8e" class="bulleted-list"><li style="list-style-type:disc">포인터를 반환해도 되는 경우<ul id="2628c7cb-fa10-4747-bb59-879f9cbfde7e" class="bulleted-list"><li style="list-style-type:circle">전역변수</li></ul><ul id="241898c9-14b7-4bcb-8a33-8449a0fe124b" class="bulleted-list"><li style="list-style-type:circle">파일 속 <code>static</code> 전역변수</li></ul><ul id="ad62cc4d-fe72-4f01-8a62-1be32f2e2495" class="bulleted-list"><li style="list-style-type:circle">함수 내 <code>static</code> 변수</li></ul><ul id="da29de22-75f7-4aeb-9b4f-92b3451fdbcf" class="bulleted-list"><li style="list-style-type:circle">힙 메모리에 생성한 데이터</li></ul></li></ul><ul id="e039c2a5-db8c-4d30-916c-5ba04608002e" class="bulleted-list"><li style="list-style-type:disc"><strong>포인터 함수 반환값의 사용</strong><ul id="440ff449-3f2b-4071-a051-063f36e42eed" class="bulleted-list"><li style="list-style-type:circle">도우미 함수 안에 생성한 변수를 다른 함수에서 사용하고자 할 때<p id="9ef5a714-fffc-490e-ae4e-31d9e31f9c8d" class="">⇒ 단, 일반 지역변수면 안됨 (함수 호출이 끝나면 사라짐)</p></li></ul><ul id="f7534a4b-c4db-4287-bcf7-da533050674c" class="bulleted-list"><li style="list-style-type:circle">함수 안에서 대용량 데이터를 생성하고 그걸 반환하고자 할 때<p id="1d25429e-5d77-4e44-bf44-363ff8c1b2e6" class="">⇒ 이 경우에는 스택 메모리가 아니라 힙 메모리라는 곳에서 생성함</p></li></ul></li></ul><h2 id="756de3ac-1004-4c4e-9852-3605d323a1b8" class="">널(NULL) 포인터</h2><pre id="1a0a792c-4469-4810-8821-0e2b11df376c" class="code"><code>void do_something()
    {
        int number;
        int* num_ptr = &amp;number;
    
        /* 코드 생략 */
    
        number_ptr = NULL;
    }</code></pre><ul id="55df1003-be74-408f-ab79-9b8eb20ad9be" class="bulleted-list"><li style="list-style-type:disc">반환할 주소가 없는 경우</li></ul><h3 id="b3820d8f-93f5-465e-9d3e-511263d50347" class="">널 포인터</h3><ul id="b1ce5535-d265-4ce8-bedb-b98548f4d800" class="bulleted-list"><li style="list-style-type:disc">아무것도 카리키지 않는 포인터 → 실제 주소가 없음 → 유효한 메모리를 가리키고 있지 않음</li></ul><ul id="7e94b343-4b20-4b52-a2b7-ffc6d0cd0a22" class="bulleted-list"><li style="list-style-type:disc">1) 값이 &#x27;0&#x27;인 정수/상수 표현식, 혹은 2) <code>void*</code>로 캐스팅 된 표현식</li></ul><ul id="2c0b60e3-94d4-4fd6-9eea-c24cd3a50c9a" class="bulleted-list"><li style="list-style-type:disc"><strong>전용 매크로가 있음</strong><pre id="0b3268ce-e0d7-44ce-bc8f-8ee5edcc534a" class="code"><code>#define NULL ((void*)0)</code></pre><p id="77c6578d-c7b9-4468-8e4b-e7514abe1534" class=""><strong>⇒ 널 포인터를 표현할 때 위의 매크로를 사용할 것</strong></p></li></ul><ul id="5e66da64-92cb-4c08-bac9-31479ca97d09" class="bulleted-list"><li style="list-style-type:disc">포인터 변수와 <code>NULL</code>은 비교(<code>==</code>, <code>!=</code>) 가능<pre id="448248f5-e6b2-41ec-8456-98dc1afc484e" class="code"><code>int* ptr;
    
    if (ptr == NULL) {               /* 만약 PTR이 널 포인터면 */
    /* 코드 생략 */
    }
    
    if (ptr != NULL) {               /* 만약 PTR이 널 포인터가 아니라면 */
    /* 코드 생략 */
    }</code></pre></li></ul><h3 id="80410550-44bb-42ac-9e4e-48d502603815" class="">코딩표준 : 매크로 NULL을 반드시 사용할 것</h3><pre id="b461efd9-40a9-4bd6-92b1-1a8a1781b81c" class="code"><code>/* 별로인 코드 */
    
    #define PRICE (2)
    
    void increase_price(int* current_price)
    {
        if (current_price != 0) {
            *current_price += PRICE;
        }
    }
    
    /* 올바른 코드 */
    
    #define PRICE (2)
    
    void increase_price(int* current_price)
    {
        if (current_price != NULL) {
            *current_price += PRICE;
        }
    }</code></pre><ul id="d8a7e468-9fbd-4727-afdc-7973b04f5d3d" class="bulleted-list"><li style="list-style-type:disc">0은 사용하지 않음!</li></ul><ul id="49705765-0adb-43aa-9aae-b6b2c4f360ab" class="bulleted-list"><li style="list-style-type:disc"><code>if (ptr)</code> 만 사용하여도 존재할 때와 아닐 때를 구분할 수 있어 혼돈이 적으나 왠만하면 직접 표시해주는 것이 좋음</li></ul><h3 id="6926b516-aa7c-4d9c-a617-c06b8ee9bb79" class="">널 포인터와 매개변수</h3><ul id="6d1a70b6-4d10-47be-8b87-561764b068ec" class="bulleted-list"><li style="list-style-type:disc">함수 매개변수로 포인터가 들어올 올 때는 언제나 골칫덩어리</li></ul><ul id="3689869b-1982-4335-a56f-5caada752cfd" class="bulleted-list"><li style="list-style-type:disc">누구나 <code>NULL</code>을 넣을 수 있기 때문</li></ul><ul id="68665024-8ef0-413d-a6ab-b820a0d60c22" class="bulleted-list"><li style="list-style-type:disc">함수의 선조건(precondition) 문제</li></ul><ul id="67a4b19e-898e-477f-80f6-8987639bc3ac" class="bulleted-list"><li style="list-style-type:disc">기본적으로 <code>NULL</code>이 안 들어온다고 가정하고 함수 작성</li></ul><ul id="7b7a79e5-0666-4cfd-9b44-36927d05acf9" class="bulleted-list"><li style="list-style-type:disc"><code>NULL</code>이 들어올 수 있는 함수는 매개변수 명에서 분명하게 밝혀야함</li></ul><h3 id="97877092-e586-498c-9574-71fc5fe456d6" class="">코딩 표준 : 널 포인터를 허용하는 매개변수</h3><ul id="5eebf34d-40a5-4ac2-8d6a-86a32c3148af" class="bulleted-list"><li style="list-style-type:disc">함수의 매개변수가 널 포인터를 허용한다면, 매개변수 이름 끝에 &#x27;<code>or_null</code>&#x27;을 붙이는 것이 좋음<pre id="e7204896-24a1-4968-930a-1b32bdbfd8c5" class="code"><code>int get_score(const char* const student_id_or_null)
    {
        /* 코드 생략 */
    }</code></pre></li></ul><ul id="b79e8635-929f-4e07-a98b-06e68260ab4b" class="bulleted-list"><li style="list-style-type:disc"><code>NULL</code>이 안 들어온다고 가정한 경우 <code>assert()</code>를 사용해 검증<pre id="abc8d1e3-387d-4034-9048-6f5e935829a1" class="code"><code>#include &lt;assert.h&gt;
    
    #define PRICE (2)
    
    void increase_price(int* current_price)
    {
        assert(current_price != NULL);
        *current_price =+ PRICE;
    }</code></pre></li></ul><hr id="c28093c1-2c24-4f61-b3af-a156685c0dd3"/><p id="b8649a82-1954-4e9e-889f-eabc70a56dab" class=""><strong>assert 함수</strong></p><ul id="dbd3ca81-ccb7-4aea-8881-47198491d0d0" class="bulleted-list"><li style="list-style-type:disc">디버깅 모드에서 개발자가 오류가 생기면 치명적일 것이라는 곳에 심어 놓는 에러 검출용 코드</li></ul><ul id="d45455c0-c59f-4a71-b640-f9cb847b819e" class="bulleted-list"><li style="list-style-type:disc">디버깅용 함수이기에 release 모드에서는 동작하지 않음 ⇒ 코드를 다 완성하고 동작할 때 돌아가는 함수가 아님</li></ul><ul id="cfb51d14-b5d1-42fd-bc09-b8f0f13d42e8" class="bulleted-list"><li style="list-style-type:disc"><strong>assert함수에 걸리게 되면 버그 발생위치, call stack등 여러 정보를 알 수 있음</strong></li></ul><ul id="901834a0-56a1-4658-99d0-e9260570c6c3" class="bulleted-list"><li style="list-style-type:disc"><code>assert(A != NULL)</code>;<p id="a03cb2a8-6d1f-41a4-a678-a652c8160509" class="">A가 <code>NULL</code>이 아니라면 <code>true(1)</code>가 나오므로 pass</p><p id="75c59194-ee18-499b-a74b-3af2e36bc482" class="">A가 <code>NULL</code>이라면 <code>false(0)</code>가 나오므로 assert error</p></li></ul><hr id="a5a9057d-1881-4270-b550-c0bdbeedfa69"/><h3 id="61f9e099-15ab-4724-97b3-8e5f9deef595" class="">널 포인터와 반환값</h3><ul id="4aa3d4b7-ba89-47b8-af9f-871d9577cdd9" class="bulleted-list"><li style="list-style-type:disc"><code>NULL</code>을 반환할 때도 마찬가지</li></ul><ul id="8b9ad2ac-7131-447e-8f1d-3000d631982d" class="bulleted-list"><li style="list-style-type:disc">기본적으로 안 함</li></ul><ul id="fb4d6f05-8852-4dde-a4c6-b1219a68c4fe" class="bulleted-list"><li style="list-style-type:disc">반환해야 한다면 함수 이름에 <code>NULL</code>을 반환하는 것을 명시</li></ul><h3 id="968117f5-7046-4175-9301-5067ea61c5d3" class="">코딩 표준 : 널 포인터를 반환하는 함수명</h3><pre id="49c505c1-14c1-49db-b9bc-240429e52743" class="code"><code>const char* get_name_or_null(const int id)
    {
        /* 코드 생략 */
        return NULL;
    }</code></pre><h3 id="b7c12ab5-49c4-409d-9c6e-59c58c99c66d" class="">널 포인터의 사용</h3><p id="6a72ef15-a9db-4fef-a8e6-21b2e0826456" class=""><strong>1) 포인터 변수를 초기화하고 싶을 때</strong><div class="indented"><pre id="fc39f7a6-bd88-42e7-b52c-7ef1dd0ba9a5" class="code"><code>void do_something(void)
    {
        int* ptr = NULL;              /* 당장 사용하지 않으므로 널 포인터로 초기화 */
        /* 코드 생략 */
        ptr = &amp;g_monster_count;       /* 후에 전역변수의 주소 저장 */
        /* 코드 생략 */  
    }</code></pre><p id="e01a5126-2a8e-4a13-817c-f22831cf1c65" class="">⇒ 아직 참조할 주소가 없을 때</p></div></p><p id="e21344e4-cfa2-4f34-9283-2aaf5efb05b5" class=""><strong>2) 포인터 변수가 유효하지 않은 주소를 참조하고 있는지 확인하고 싶을 때</strong><div class="indented"><pre id="1704947e-006c-4c1e-8092-be57739240dc" class="code"><code>void do_something(void)
    {
        /* 다른 변수 생략 */
        int* ptr = &amp;num;  
                
        /* 코드 200줄 */
        ptr = NULL;  
         
        /* 코드 500줄 */
        *ptr = 100                      /* 결과가 정의되지 않음 */
    }   </code></pre><p id="7efc00ef-3abe-49d5-a249-d5f15f13800c" class="">⇒ 아무것도 가리키지 않는 포인트 변수를 역 참조하면 결과가 정의되지 않음 (undifined)</p><pre id="2a3e3286-7007-4f7d-961b-ef51929f3f15" class="code"><code>void do_something(void)
    {
        /* 다른 변수 생략 */
        int* ptr = &amp;num;  
                
        /* 코드 200줄 */
        ptr = NULL;  
         
        /* 코드 500줄 */
        if (ptr != NULL) {
        *ptr = 100
        }
    }        </code></pre><p id="de45f89b-6ea7-4ead-9159-375381ab6643" class="">⇒ 역 참조를 하기 전에 널 포인터인지 확인해야함</p></div></p><p id="b81c3892-b778-45f4-90c6-58d340fed54a" class=""><strong>3) 댕글링 포인터를 막기 위해</strong><div class="indented"><pre id="f074b7de-4ac0-428f-a423-875cb55e4c45" class="code"><code>/* 동적 메모리 할당 */
    int* ptr = (int*)malloc(sizeof(int));
    
    /* 코드 100줄 */
    
    /* 더이상 ptr을 사용하지 않음 */
    free(ptr);
    ptr = NULL;</code></pre><p id="33d9b24c-0cef-4bce-8a0b-60012b56baa2" class=""><strong>⇒ 동적 메모리 할당된 메모리를 더이상 필요 없어서 해제했는데, 이를 여전히 가리키는 포인트가 있다면? 더이상 사용할 수 없는 데이터니 포인터 변수에 저장되어 있는 그 주소를 초기화 해야함 → 이때 널 포인터를 이용해서 리셋</strong></p></div></p><p id="f7981fe3-c922-4550-8901-1a47b2376136" class="">결과적으로 존재하지 않는 메모리 주소에서 값을 읽어오려면 여러 가지 문제들이 팡팡 터짐. 항상 조심해야하는 부분임</p><h2 id="f1e27347-1cdb-44ee-8189-2ecaf57993f2" class="">포인터의 비교/크기</h2><h3 id="52364c73-9971-49f6-9169-2b6bccf34196" class="">포인터의 비교</h3><pre id="c5e6f7d4-1173-4f4b-b314-387421a3ef90" class="code"><code>/* 주소를 비교하는 코드 */
    
    void do_somthing(int* num1, int* num2)
    {
        if (num1 == num2) [
            /* 코드 생략 */
    }
    
    /* 값을 비교하는 코드 */
    
    void do_somthing(int* num1, int* num2)
    {
        if (*num1 == *num2) [
            /* 코드 생략 */
    }</code></pre><ul id="ea8b959e-b6b5-42b2-ac2c-f098690dc7dd" class="bulleted-list"><li style="list-style-type:disc">포인터는 비교 연산자를 이용해서 서로 비교할 수 있음 (<code>==</code>. <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>,  <code>&lt;=</code>)</li></ul><h3 id="b6dfadfd-ff0f-45a0-b20c-175504b34f1f" class="">포인터의 크기</h3><ul id="eecdc4a8-b248-408e-9b06-0b048c3d1617" class="bulleted-list"><li style="list-style-type:disc">모든 포인터는 동일한 크기를 가짐</li></ul><ul id="be69c9df-83e9-47fb-b32a-4bc4ed5c00b7" class="bulleted-list"><li style="list-style-type:disc">포인터의 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정됨<p id="bdbb4c13-a924-45f7-a58a-e0001af69cdf" class="">⇒ 보통 CPU가 한 번에 처리할 수 있는 데이터의 크기(word)와 동일함<div class="indented"><p id="746d9205-04c2-4609-808f-762b1d30b0b9" class="">32비트 아키텍쳐에서 포인트 크기는 4바이트</p><p id="ba6ba8c3-292d-4ef1-9965-9fec0408c346" class="">64바이트 아키텍쳐에서 포인트 크기는 8바이트</p></div></p></li></ul><pre id="9316df88-4636-4b13-a170-29f42cfe1e25" class="code"><code>void print_pointer_size()
    {
        char ch = &#x27;c&#x27;;
        int number = 934553;
        float pi = 3.1415f
    
        char* char_ptr = &amp;ch
        int* number_ptr = &amp;number;
        float* pi_ptr = &amp;pi;
    
        print(&quot;char size : %d, char* size : %d\n, sizeof(*char_ptr), sizeof(char_ptr);
        print(&quot;int size : %d, int* size : %d\n, sizeof(*int_ptr), sizeof(int_ptr);
        print(&quot;float size : %d, float* size : %d\n, sizeof(*float_ptr), sizeof(float_ptr);
    }
    
    /* char size: 1, char* size: 4 */
    /* int size: 4, int* size: 4 */
    /* folat size: 4, float* size: 4 */</code></pre><h2 id="6bf7f906-8591-4be5-8e3e-b83572817ad1" class="">포인터와 배열</h2><h3 id="182814cb-91b6-44c6-bc02-f67634097dbe" class="">포인터와 매개변수로 받은 배열</h3><ul id="ce681333-ad0a-493b-a81d-fabb3401c06d" class="bulleted-list"><li style="list-style-type:disc">매개변수로 받은 배열<p id="f0afea0d-2801-40ad-8f8e-fef806274bfc" class="">⇒ 배열은 연속된 메모리 → 그걸 다 스택에 넣을 수 없음 → 시작위치만 전달(메모리 주소)</p><pre id="b0e44313-aa77-4d3d-aafc-de952ddd7a65" class="code"><code>void print_scores(int scores[])
    {
        size_t size = sizeof(int scores[]);
        /* 코드 생략 */
    }
    printf(my_scores)</code></pre><ul id="d966c973-15b5-44fe-908a-9998cd8aefe4" class="bulleted-list"><li style="list-style-type:circle">scores의 크기는 4바이트</li></ul><ul id="cf21ce0f-51b3-45e4-b240-d8f989b72378" class="bulleted-list"><li style="list-style-type:circle">scores는 my_scores의 시작주소를 가지고 있음</li></ul></li></ul><ul id="6b1419ec-11ab-4381-8018-2ac5558a9bac" class="bulleted-list"><li style="list-style-type:disc">포인터<pre id="a336ce7c-a583-4ad4-aea3-f962823831ae" class="code"><code>void money(float* dollar)
    {
        size_t size = sizeof(dollar);
        /* 코드 생략 */
    }
    printf(&amp;my_money)</code></pre><ul id="f5d06f8e-0219-4eee-b738-336330f84ee9" class="bulleted-list"><li style="list-style-type:circle">dollar의 크기는 4바이트</li></ul><ul id="60a22fc8-9799-49af-9d77-f35e78982e06" class="bulleted-list"><li style="list-style-type:circle">dollar는 my_money의 (시작)주소를 가지고 있음</li></ul><h3 id="083a0863-f3bf-4df9-8626-af5e537a8690" class="">배열을 포인터에 대입</h3><pre id="bd7be0ea-1796-4d35-a01b-85d9b72db633" class="code"><code>int nums[6] = { 0, 1, 2, 3, 4, 5 };
    int* ptr = NULL;
    
    ptr = nums;            /* 컴파일 됨 - 1 */
    ptr = nums[0];         /* 컴파일 오류 - 2 */
    ptr = &amp;nums[0];        /* 컴파일 됨 - 3 */</code></pre><ol type="1" id="95382ca2-a106-4c13-bea0-d77d06e30f09" class="numbered-list" start="1"><li><code>nums</code>는 배열로, 시작위치(메모리 주소) 반환</li></ol><ol type="1" id="9e6130db-5f34-437e-860c-440d8d7096e3" class="numbered-list" start="2"><li><code>nums</code>는 시작주소를 반환하지만, <code>nums[0]</code>은 주소가 아닌 <code>int</code>를 반환함<p id="794ef548-6e48-4d69-8cd1-f581b70fc4fe" class="">⇒ 즉, <code>nums[0]</code>은 <code>int</code>이며, <code>int*</code>가 아님!</p></li></ol><ol type="1" id="d7546c85-d7de-4ea0-aed6-f3d9a9051f8b" class="numbered-list" start="3"><li><code>nums[0]</code>의 주소를 얻기 위해서는 주소 연산자를 이용해야함</li></ol></li></ul><hr id="3f6dd2fc-f6b6-4f6e-ad53-12e89f587af0"/><p id="b01bd894-0510-45d8-8784-cd17760a8a2e" class="">정리하자면, 아래의 두 코드는 동일한 결과를 나타냄</p><pre id="aaa6682a-9042-428a-8ed3-12c56be2dd9d" class="code"><code>int* ptr1 = nums;
    int* ptr2 = &amp;nums[0];</code></pre><hr id="acadadaa-c175-4e4a-b190-bdaba8deec54"/><h3 id="8732b40d-2370-41bb-8365-e210ade9e093" class="">배열 속에서 각 요소의 위치</h3><ul id="6f4765c0-f4c7-43a4-9398-949e526848c4" class="bulleted-list"><li style="list-style-type:disc">배열에서 각 요소 사이의 바이트 간격을 일정함<pre id="17350863-43df-46bf-b050-e4bd4a1e59fb" class="code"><code>int nums[5];
    char chars[5];</code></pre></li></ul><ul id="cc33d2bb-9713-4b98-97bc-fa0a36263bf7" class="bulleted-list"><li style="list-style-type:disc">따라서 첫 번째 요소의 주소와 자료형의 크기를 안다면 두번째 요소의 주소를 알 수 있음<p id="d976a693-2487-4b6e-9f6d-302983d6e678" class="">⇒ 두 번째 요소 주소 = 첫 번째 요소 주소 + 자료형의 크기(바이트)</p><p id="81279892-30fa-4132-bc5d-4ad5cc5da4e7" class="">⇒ 세 번째 요소 주소 = 두 번째 요소 주소 + 자료형의 크기(바이트)</p></li></ul><h3 id="4ce3d011-f56c-4a79-971a-6ad4ea9ce655" class="">포인터 주소 계산</h3><pre id="8a95b192-2a78-4002-b7e2-596758a41ed3" class="code"><code>int nums[6] = { 0, 1, 2, 3, 4, 5 };
    int* ptr = NULL;
    
    int* ptr = nums;
    /* nums 0x004ff7e0 {0, 1, 2, 3, 4, 5} */
    /* ptr 0x004ff7e0 {0} */
    
    ptr = ptr + sizeof(int);
    /* nums 0x004ff7e0 {0, 1, 2, 3, 4, 5} */
    /* ptr 0x004ff7f0 {4} */</code></pre><p id="a4a515c3-55ec-4f6a-9bd3-bb98b11550a4" class="">⇒ 첫 번째 요소에서 자료형의 크기를 더 했는데 왜 <code>nums[1]</code>이 아닌 <code>nums[4]</code>가 나온 것일까?</p><h3 id="cc6ca511-efe9-4243-889c-2eefb11d84e4" class="">포인터에 정수의 덧셈 의미</h3><pre id="acf7bb53-b298-41ff-8111-411c289ea304" class="code"><code>ptr = ptr + sizeof(int);</code></pre><ul id="19322f17-9e73-4b0e-b800-8ccb5dd65af9" class="bulleted-list"><li style="list-style-type:disc"><strong>포인터에 정수 1을 더한다는 것은 포인터의 위치를 다음 데이터로의 위치 이동을 의미함</strong><p id="81b0b543-743f-45d1-84f9-57b4cf2426b7" class="">⇒ 1바이트를 더하는게 아님</p><pre id="8d1ac16f-b70e-4644-817b-9de86497a860" class="code"><code>int* ptr = nums;
    ptr = ptr + 3;
    
    /* 0x100 + 4 + 4 + 4 = 0x10c : int의 사이즈를 3번 더함 */
    /* int*가 아니라 short*라면 2바이트씩 증가 */</code></pre></li></ul><ul id="45084571-8506-477f-bbe6-d7390fef68b9" class="bulleted-list"><li style="list-style-type:disc">뺄셈뿐만 아니라, <code>++</code>, <code>--</code>도 마찬가지임</li></ul><hr id="2028872e-9bbd-4fc0-94da-eb1754f08fc0"/><p id="fbdb1686-ce14-4534-9e7b-9d88e2cf7893" class="">정리하자면, 아래의 두 코드는 동일한 결과를 나타냄</p><pre id="81b5ac2c-ed17-4d87-a90c-b541739e6bd3" class="code"><code>int* ptr1 = nums + 3;        /* ptr1는 nums[3]을 가리킴 */
    int* ptr2 - &amp;nums[3]         /* ptr1는 nums[3]을 가리킴 */</code></pre><hr id="abec6563-6b86-42ed-86dd-3d5391d76165"/><h3 id="5e19cb3b-6b7c-44a4-9f6d-0b48de86dbeb" class="">포인터 사칙연산 퀴즈</h3><pre id="a44394b6-baf4-4682-9e60-71ec8cfb4cec" class="code"><code>int main(void)
    {
        int nums[5] = { 10, 20, 30, 40, 50 }; /* nums[0]의 주소는 0x100 */
        int* ptr1 = nums + 4; /* ??? */
        int* ptr2 = ptr1 - 2; /* ??? */
        
        return 0;
    }
    
    /* 정답 : ptr1(0x110), ptr2(0x108) */</code></pre><pre id="c715c920-b15e-4e98-9579-c7f147d8f1a4" class="code"><code>int main(void)
    {
        int nums[5] = { 10, 20, 30, 40, 50 }; /* nums[0]의 주소는 0x100 */
        int* ptr1 = &amp;nums[1] - 1; /* ??? */
        int* ptr2 = ptr1 -1; /* ??? */
        
        return 0;
    }
    
    /* 정답 : ptr1(0x100), ptr2(0x0fc) */</code></pre><h3 id="ae791212-9f8d-455a-9115-673e34bea613" class="">배열 요소에 포인터로 접근하기</h3><pre id="0fe19ed1-268a-4160-ae61-1f9e1d0b82f5" class="code"><code>int nums[3] = { 10, 20, 30 };
    int* ptr = nums;
    
    printf(&quot;%d, &amp;d, %d/n&quot;, nums[1], ptr[1], *(ptr + 1));
    
    /* 결과 : 20, 20, 20 */</code></pre><ul id="2d1e2c78-3e81-404c-9e44-eaf47ea00779" class="bulleted-list"><li style="list-style-type:disc">배열명은 시작 주소이기 때문에 포인터 변수에 대입할 수 있음 (<code>int* ptr = nums;</code>)</li></ul><ul id="506257a1-9bc1-48a8-b2cb-719ef1e5193c" class="bulleted-list"><li style="list-style-type:disc">추가적으로 배열의 첨자 연산자(<code>[]</code>)도 포인터에 쓸 수 있음 (<code>ptr[1] = 20</code>)</li></ul><ul id="c1f72f21-e8be-4ffa-8bfb-9afe4ea407bc" class="bulleted-list"><li style="list-style-type:disc">포인터 산술 연산에도 배열 첨자 연산자에도 동일하게 적용됨 (<code>ptr + 1</code>)</li></ul><h3 id="d6db8d1f-5564-4aaa-a01c-81bc2981591e" class="">배열의 모든 요소 더하기</h3><pre id="35c24a0c-d7d4-4cea-ac77-cb8629e59d1e" class="code"><code>int sum(int* data, const size_t length)
    {
        int result = 0;
        size_t i;
        for (i = 0; i &lt; length; ++1) {
            result += data[i];
        }
    
        return result;
    }
    
    /* 메인 함수 */
    int nums[6] = { 0, 1, 2, 3, 4, 5 };
        int result = sum(nums, 6); /* 15 */</code></pre><h3 id="ece8f104-0066-4d67-9d95-c9c2ff5d7c2a" class="">정리</h3><ul id="fa4858ac-79dc-4613-86cd-53c2426af1c6" class="bulleted-list"><li style="list-style-type:disc">포인터에 들어가는 값은 주소</li></ul><ul id="349bf7fe-4b43-40e2-aa79-c6dd4b887c65" class="bulleted-list"><li style="list-style-type:disc"><strong>C 연산자에서 이 주소를 얻을 수 있는 방법은 딱 두 가지 뿐</strong><ol type="1" id="acb4fa7b-3467-4a86-8919-4a2d3ae24754" class="numbered-list" start="1"><li>주소 연산자(<code>&amp;</code>)</li></ol><ol type="1" id="13efaf81-a08c-49c2-abd9-fceb1976212d" class="numbered-list" start="2"><li>배열의 이름 ⇒ 배열의 이름은 배열의 시작 주소를 알려줌</li></ol><pre id="6fc4af2d-7e3d-4c80-bf4e-a3c38b7c66e3" class="code"><code>float pi = 3.14f;
    float* p = &amp;pi;
    
    int days[] = { 1, 2, 3, 4, ... , 30, 31 };
    int* p = days;</code></pre></li></ul><ul id="beac63f7-3dc3-4052-b57e-9c851bd935e2" class="bulleted-list"><li style="list-style-type:disc">포인터에 정수를 더하면 주소 이동<p id="4d7e1863-271b-4083-8053-c47fc2638910" class="">⇒ 포인터에 정수 n을 더하거나 빼면 언제나 &#x27;<code>sizeof(자료형) X n</code>&#x27;한 만큼 메모리 주소 이동</p><pre id="245b48c9-9992-4c8a-9f42-52fbd13528b0" class="code"><code>char* char_ptr = char_array;          /* 0x100 */
    char_ptr = char_ptr + 10;             /* 0x10a */
    
    int* int_ptr = int_array;             /* 0x100 */
    int_ptr = int_ptr + 10;               /* 0x128 */</code></pre></li></ul><h3 id="2b32e8c2-c1ca-4b4a-943a-90946ba54f23" class="">포인터 캐스팅 : 정말 딱 &#x27;한&#x27; 바이트만 옮기고 싶다면?</h3><pre id="485ba4d4-2689-429b-8d87-a123953add05" class="code"><code>int_ptr = (char*)int_ptr + 1</code></pre><ul id="bacc66de-7cf5-40ca-bb30-de85218f8551" class="bulleted-list"><li style="list-style-type:disc">한 바이트짜리 포인터로 캐스팅</li></ul><h3 id="c265fefd-313d-482a-91a0-c111a343084d" class=""><strong>int* → char* 캐스팅의 의미</strong></h3><ul id="f46dacea-fcdd-4852-8ac7-2836244ede06" class="bulleted-list"><li style="list-style-type:disc">그 메모리 주소에 어떤 형이 들어있는 지 알려주는 것을 의미함<p id="b1cc3e27-05b1-48fd-971f-45cf73950d92" class="">⇒ 그 메모리 주소에 들어있는 값을 캐스팅하는 것이 아님!</p></li></ul><ul id="7cbb9bc9-7f1a-4eb3-9bfa-c18d617110fa" class="bulleted-list"><li style="list-style-type:disc">바꾸고 나면 실제 이 속에 들어 있는 데이터 내용이 <code>char*</code>이 되는 것이 아님</li></ul><pre id="0ba48874-2bfe-4323-aae5-eaff5ceaab2d" class="code"><code>int int_array[] = { 27, 65 };
    int* int_ptr = int_array;
    
    int_ptr = (char*)int_ptr + 1;</code></pre><p id="e5b839a3-8b7c-43f8-b3c3-f48d740030b9" class="">⇒ 메모리주소에 <code>char</code>형이 들어가  +1이 <code>int</code> 4바이트 이동이 아닌 <code>char</code> 1바이트 이동</p><h2 id="fc342c35-9317-4590-944c-e895a5a7c644" class="">두 주소간 사칙연산</h2><pre id="a4a258c8-bd15-47b2-9b1e-ccfff064d300" class="code"><code>int num[6] = { 0, 1, 2, 3, 4, 5 };
    int* ptr = nums + 2.5f;   /* 컴파일 오류 */</code></pre><ul id="2c4ba2af-c97b-4379-84c6-dda276c96a2d" class="bulleted-list"><li style="list-style-type:disc">주소에는 소수점을 더하거나 뺄 수 없으며, 정수만 가능</li></ul><pre id="f7eed103-7195-4d0a-97fa-effb3d593e28" class="code"><code>int* ptr1 = &amp;nums[1] + &amp;nums[2];       /* 컴파일 오류 */
    int sum = &amp;nums[1] + &amp;nums[2];         /* 컴파일 오류 */
    
    int* ptr2 = &amp;nums[5] - &amp;nums[1];       /* 컴파일 오류 */
    int sum = &amp;nums[5] - &amp;nums[1];         /* 컴파일 됨 */
    
    int* ptr3 = &amp;nums[5] * &amp;nums[1];       /* 컴파일 오류 */
    int sum = &amp;nums[5] * &amp;nums[1];         /* 컴파일 오류 */
      
    int* ptr4 = &amp;nums[5] / &amp;nums[1];       /* 컴파일 오류 */
    int sum = &amp;nums[5] / &amp;nums[1];         /* 컴파일 오류 */</code></pre><ul id="8b7eec85-7947-406b-935a-65897ae44ee0" class="bulleted-list"><li style="list-style-type:disc">뺄셈을 제외한 사칙연산은 모두 지원 안함</li></ul><ul id="700ee8c2-5865-4d7f-881f-9b2e528ed80b" class="bulleted-list"><li style="list-style-type:disc">생각해보면 덧셈, 곱셈, 나눗셈은 아무런 의미가 없음</li></ul><ul id="60245e26-6e01-4570-b413-f429d2cb8061" class="bulleted-list"><li style="list-style-type:disc">뺄셈을 이용한다면 두 주소 사이에 들어갈 수 있는 데이터의 개수를 반환할 수 있음<p id="f7bebba7-52e4-4fd4-ae44-5d12011e5dd4" class="">⇒ 따라서 포인터가 아니라 정수를 반환 (<code>ptr2</code>는 컴파일 오류)</p><p id="02a38671-ee32-4975-931a-8b37289fe66e" class="">⇒ 배열의 첫 번째 및 마지막 요소의 주소를 알면 배열의 크기를 구할 수 있음</p><pre id="9114a976-d036-48fe-912e-0d0f9f9add80" class="code"><code>int sub = &amp;nums[5] - &amp;nums[1];
    /* &amp;nums[5] : 0x00afc64{5} */
    /* &amp;nums[1] : 0x00afc54{1} */
    
    /*
    sub = &amp;nums[5] - &amp;nums[1]
    = (0x00afc64 - 0x00afc54) / int의 크기
    = (0x10 - 0x4) / 4 
    = 16 / 4 
    = 4
    */
    
    /* sub = 4 */</code></pre></li></ul><h2 id="8fa2686d-1d65-44a7-b0c9-9a5ecb86fc2f" class="">포인터와 배열의 차이</h2><ul id="7d8c07c7-ce26-4882-a864-6479891254c0" class="bulleted-list"><li style="list-style-type:disc">대부분의 경우 포인터와 배열은 동일하게 처리 가능</li></ul><ul id="06bfb3c7-340e-4dc0-ba36-a41d88125ebd" class="bulleted-list"><li style="list-style-type:disc">그러나 이 둘은 다를 때가 있음</li></ul><h3 id="cb1e0454-2e49-43d3-9a64-74b0e70c3d02" class="">(1) sizeof 연산자</h3><ul id="38a9d38a-e86e-4607-902f-6a4faf0e2056" class="bulleted-list"><li style="list-style-type:disc"><code>sizeof(배열)</code>과 <code>sizeof(포인터</code>는 다른 값을 반환함<p id="61d6da3d-b0c9-4dc2-8544-0dbb34543d62" class="">⇒ <code>sizeof(배열)</code> : 배열의 총 크기를 반환</p><p id="9ae8c2c3-58a6-4e77-993f-68a440690e6c" class="">⇒ <code>sizeof(포인터)</code> : 포인터의 크기를 반환</p></li></ul><pre id="11bde0ce-1a45-4872-bd77-1aee500d3bb1" class="code"><code>int nums[3] = { 34, 145, 49 };
    
    int* ptr = nums;
    
    size_t size1 = sizeof(nums);    /* 12 = 3 * 4 */
    size_t size2 = sizeof(ptr);     /* 4 */</code></pre><h3 id="64e31bd6-8b29-4f46-a377-a4899a355b68" class="">(2) 문자열 초기화</h3><ul id="ff3e2c21-0ac5-4b79-89e4-960040e56c0d" class="bulleted-list"><li style="list-style-type:disc">C는 C#과 JAVA처럼 문자열(string) 자료형이 없음</li></ul><ul id="bb854fc4-8d19-4d1d-b9fe-485c63e40af7" class="bulleted-list"><li style="list-style-type:disc">C의 문자열 표현방법<p id="c5f65501-b7dc-4ae6-8223-3448af0e3791" class="">&quot;Friday&quot;라는 단어를 저장한다면 총 6(+1)개의 요소를 가진 char 배열을 만듬</p><p id="f55b2ab6-498e-4e96-99ff-39803ab52bcb" class="">⇒ 문자열이 끝나는 지점을 알려주기 위해 널 문자(null character)라고 하는 특별한 문자를 항상 맨 마지막에 넣어줌</p><p id="6c2b3d18-5d26-4c4c-b290-b34a2fec1c02" class="">⇒ 널문자 : 값은 0으로 &#x27;<code>\0</code>&#x27;이라 표현함</p></li></ul><ul id="9153c2fc-8792-48f2-ae93-c392783aeb8c" class="bulleted-list"><li style="list-style-type:disc">문자열 초기화의 저장<ol type="1" id="a24c6e60-1f13-4a32-9234-618824ff1bbe" class="numbered-list" start="1"><li><strong>배열(문자열)의 저장</strong><pre id="bbc1f0cc-0c11-4e37-bb32-8b0867e30a80" class="code"><code>char day1[] = &quot;Monday&quot;;</code></pre><p id="1fb1336f-9697-4a5a-ad6a-f30fa5f7d506" class="">⇒ 배열의 마지막에 차례로 &#x27;M&#x27;, &#x27;o&#x27;, &#x27;n&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;y&#x27;가 들어간 후 마지막에 &#x27;<code>\0</code>&#x27;이 들어감</p><p id="a7d01bff-6171-4a3d-9a81-edf49d4b76e8" class="">⇒ 함수 안에서 사용하면 <strong>스택메모리</strong>에 저장됨</p></li></ol><ol type="1" id="bb80d66c-ce77-4767-8718-b44004d56ca2" class="numbered-list" start="2"><li><strong>포인터(문자열)의 저장</strong><pre id="8ecb65b1-d834-4fcf-8554-127caf1c89ab" class="code"><code>char* day2 = &quot;Monday&quot;;</code></pre><p id="8a42b931-c00e-4610-823f-b30dcfadc359" class=""><strong>⇒ 포인터 변수는 스택에 저장</strong></p><p id="bb348ba1-4189-45bb-8f4d-d80e37c7fff6" class=""><strong>⇒ 실제 문자열은 데이터 섹션에 저장</strong></p></li></ol></li></ul><ul id="d4f37353-4f73-4e45-8d00-454450326cf6" class="bulleted-list"><li style="list-style-type:disc">문자열의 초기화<pre id="dd7a1f3d-ae0b-47ba-8dc2-1ed6badb22ca" class="code"><code>char day1[] = &quot;Monday&quot;;
    char* day2 = &quot;Monday&quot;;
    
    day1[0] = &#x27;P&#x27;;      /* OK */
    day2[0] = &#x27;P&#x27;;      /* 결과가 정의되지 않음 */</code></pre><ul id="3706155d-a858-4d8f-a77a-e88f0b4bd7f9" class="bulleted-list"><li style="list-style-type:circle"><strong>스택에 저장된 문자열은 수정해도 괜찮지만, 데이터 섹션에 저장된 문자열은 수정할 경우 &#x27;결과가 정의되지 않음</strong></li></ul><ul id="38c36436-7bee-45a9-9375-f7ca9563a3e0" class="bulleted-list"><li style="list-style-type:circle"><strong>후자의 경우는 문자열이 읽기 전용임</strong></li></ul></li></ul><h3 id="a0c2e38f-04a9-49f0-8738-a9f8a6adb8b2" class="">(3) 대입</h3><ul id="4287edbb-27a9-467d-95f5-1841d83f104a" class="bulleted-list"><li style="list-style-type:disc"><strong>포인터 변수에 값을 대입할 수 있으나 배열 변수에는 할 수 없음</strong></li></ul><pre id="b6da7a03-7807-4c88-83eb-7078c52ea5ed" class="code"><code>int* pointer1;
    int* pointer2;
    int array1[5];
    int array2[5];
    int x = 5;
    
    pointer1 = array1;
    array1 = pointer1;      /* 컴파일 오류 */
    
    pointer1 = &amp;x;
    array = &amp;x;             /* 컴파일 오류 */
    
    pointer1 = pointer2;
    array1 = array2;        /* 컴파일 오류 */</code></pre><h3 id="befdfe2a-aed9-427e-b68f-85516cd1f0de" class="">(4) 포인터 산술 연산</h3><ul id="b7e0bcde-58d6-4ac7-a35e-9819b8ede6a5" class="bulleted-list"><li style="list-style-type:disc"><strong>포인터는 산술 연산이 가능하지만 배열은 불가능</strong></li></ul><ul id="6bcef092-84ca-43b4-b1e2-ca73c7c77d8a" class="bulleted-list"><li style="list-style-type:disc">배열의 주소를 증가하거나 감소하고 싶다면 포인터에 배열의 주소를 대입 후 그 포인터 변수를 증가/감소하면 됨</li></ul><pre id="756141c6-8e56-43bb-bc94-9cab65ea8b90" class="code"><code>++pointer;
    --pointer;
    
    pointer += 1;
    pointer -= 1;
    
    ++array;            /* 컴파일 오류 */
    --array;            /* 컴파일 오류 */
    
    ++array += 1;       /* 컴파일 오류 */
    --array -= 1;       /* 컴파일 오류 */</code></pre><h2 id="99b1729c-bba4-41dd-9964-52f9a5e1aa78" class="">포인터와 연산자</h2><h3 id="b3f7bee4-fc85-4703-9149-cfffe420dbc5" class="">연산자 결합법칙</h3><ul id="05780822-947a-423a-916c-9e3e33d9c990" class="bulleted-list"><li style="list-style-type:disc">연산자 결합법칙은 크게 고민할 이유는 없음</li></ul><ul id="0978792c-4a52-43af-8863-21e0b8fca23f" class="bulleted-list"><li style="list-style-type:disc">익숙한 것들은 그냥 쓰고 아닌 것들은 괄호를 치는 것이 일반적임</li></ul><ul id="1435c27f-3de9-45f4-8369-1abd9e7fe66c" class="bulleted-list"><li style="list-style-type:disc">연산자 결합법칙이란?<p id="b548cdd2-3ab2-45c4-bb0e-a1482b6b21dc" class="">동일한 우선순위를 가지는 연산자들이 있으면 어떤 방향으로 연산자는 적용하는지를 의미함</p><p id="a1a92d34-1994-46be-97a6-527d90fe9e02" class="">⇒ 대부분은 왼쪽에서 오른쪽이지만 몇몇 <code>*</code> 혹은 <code>&amp;</code>과 같은 익숙하지 않은 연산자가 있음</p></li></ul><pre id="927cc369-e0bd-415f-9834-92ff17b462c4" class="code"><code>int nums[] = { 134, 68, 47956 };
    int* p = nums; /* 변수 nums의 주소가 0x104라 가정 */
    int num = *p++;
    
    /* num : 134 , p : 0x108 */</code></pre><pre id="c3a82220-631c-41e1-86aa-bd4dd0cb5f2d" class="code"><code>int nums[] = { 134, 68, 47956 };
    int* p = nums; /* 변수 nums의 주소가 0x104라 가정 */
    int num = *++p;
    
    /* num : 68 , p : 0x108 */</code></pre><pre id="1d8b05cd-cb60-435d-8829-6758561a8d16" class="code"><code>int nums[] = { 134, 68, 47956 };
    int* p = nums; /* 변수 nums의 주소가 0x104라 가정 */
    int num = ++*p;
    
    /* num : 135 , p : 0x104 */</code></pre><h3 id="cdb22d3a-6524-43a7-af38-1a05595c8ea0" class="">조금더 빠른 배열의 요소 더하기 함수</h3><pre id="baaa01da-b5d3-457f-9ffc-a57aeadbee39" class="code"><code>/* 배열 */
    
    int sum(int* data, const size_t length)
    {
        int result = 0;
        size_t i;
        for (i = 0; i &lt; length; ++i) {
            result += data[i];
        }
    
        return result;
    }
    
    /* 포인터 */
    
    int sum(int* start, int* end)
    {
        int result = 0;
        int* p = start
        while (p &lt; end) {
            reult += *p++;
        }
        
        return result;
    }</code></pre><ul id="0d807458-7e35-4a85-9a81-a6e6e465523f" class="bulleted-list"><li style="list-style-type:disc">포인터로 배열을 접근하는 것이 더 빠름 ⇒ <code>*p++</code>를 통해 접근하는 게 배열보다 빠름</li></ul><ul id="a211cd3d-6143-449a-a39b-a9f8365cfc2b" class="bulleted-list"><li style="list-style-type:disc">배열은 언제나 첫 주소 + 요소 위치까지의 오프셋<p id="5567a97f-6630-432c-86fe-3a2e540a649d" class="">⇒<code> &amp;data[0] + 0*4</code> / <code>data[0] + 1*4</code> / <code>&amp;data[0] + 2*4</code>...</p></li></ul><ul id="ef2b9468-5b17-4e13-96e8-176f7b322a61" class="bulleted-list"><li style="list-style-type:disc">포인터는 이미 다음 주소에 가 있기 때문에 그대로 참조<p id="98e013d4-eec9-4a58-a4f8-ce9700671190" class="">⇒ <code>p + 4</code> 반복</p></li></ul><ul id="6226e0ac-b55f-4c5f-b4fb-05586395ff3f" class="bulleted-list"><li style="list-style-type:disc"> 요즘 컴파일러는 최적화를 잘해서 두 코드가 비슷한 성능을 보이기도 하지만 포팅을 생각해서 C에서는 여전히 <code>*p++</code>을 더 많이 씀</li></ul><pre id="9edc0bfb-e838-40d7-a565-f794e1b21c11" class="code"><code>/* 직접 짜본 0~10까지의 합 : 포인터 사용 */
    
    #include &lt;stdio.h&gt;
    
    int add(int* start, int* end) {
        int a = 0;
        int* p = start;
    
        while (p &lt;= end ) {
            a  += *p++;
        }
    
        return a;
    }
    
    int main(void) {
        int nums[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int result;
    
        result = add(&amp;nums[0], &amp;nums[9]);
        printf(&quot;%d&quot;, result);
    
        return 0;
    }</code></pre><h2 id="ad890e30-4862-4568-afa5-30e12e4b846f" class="">포인터와 const</h2><h3 id="cd5a582a-7225-4ba9-adf7-b89870415517" class="">const</h3><pre id="9a8662d9-bbe5-4007-b6a2-ecfe45cb766e" class="code"><code>void do_something(const int op1)
    {
        op1 = 20;    /* 컴파일 오류 */</code></pre><ul id="a36c4772-8a49-4738-8895-0af2f36c80ce" class="bulleted-list"><li style="list-style-type:disc">기본 자료형 변수의 경우 <code>const</code>를 붙이면 그 변수에 저장한 값을 변경할 수 없음<ul id="314e6a33-3f8b-4db1-9893-1ff4f6ede187" class="bulleted-list"><li style="list-style-type:circle">보통 이게 반드시 필요하다고 느끼진 않음</li></ul><ul id="3ffa20bc-ceeb-4495-892b-04ff4fbd425e" class="bulleted-list"><li style="list-style-type:circle">따라서 이걸 반드시 붙이라고 강요하지 않는 코딩 표준도 많음</li></ul><ul id="c32503b1-99fe-4ba8-ba46-1e5655737542" class="bulleted-list"><li style="list-style-type:circle">실수가 발생해도 큰 문제가 발생하지 않기 때문</li></ul><ul id="d7bb42a5-2785-4872-a134-54d097b6de05" class="bulleted-list"><li style="list-style-type:circle">함수범위 내에서 발생할 수 있는 실수를 막는 정도</li></ul></li></ul><h3 id="63ef7f5f-0b23-489e-b8ef-7a527619deb3" class="">const 포인터 : 주소의 보호</h3><pre id="c252d543-a215-465f-b696-b33a79f64863" class="code"><code>int* const p = &amp;num;</code></pre><ul id="8787f86c-f2c0-4253-90d3-0e99bf8dccbe" class="bulleted-list"><li style="list-style-type:disc">메모리 주소를 바꿀 수 없음</li></ul><ul id="c96ed3f8-c036-4052-95d9-f4cc44c06d22" class="bulleted-list"><li style="list-style-type:disc">포인터 변수는 오른쪽에서 왼쪽으로 읽음<p id="485964de-ff79-49b8-a96a-52bb445a4868" class="">⇒ 영어로 표현하면, &quot;p is const pointer to int&quot;</p></li></ul><pre id="1fad1a4f-bc9a-4ed9-a15e-96ecfe94d1dd" class="code"><code>int num1 = 10;
    int num2 = 20;
    
    int* const p = &amp;num1;
    p = &amp;num2;                 /* 컴파일 오류 */
    ++p;                       /* 컴파일 오류 */</code></pre><h3 id="119d65e8-2c03-428e-8034-55b38c44ee4b" class="">const 변수</h3><ul id="7f9502df-ec4a-4759-a02e-27fee7c4cad6" class="bulleted-list"><li style="list-style-type:disc">생성과 동시에 초기화해야 함</li></ul><ul id="eb888f91-d126-4367-b026-380a7836b87a" class="bulleted-list"><li style="list-style-type:disc">초기화 이후 다른 값으로 변경 불가</li></ul><ul id="2f60abca-8ac7-4293-954c-4229df86ad69" class="bulleted-list"><li style="list-style-type:disc"><code>const</code>가 아닌 변수에 대입은 가능</li></ul><ul id="cd6bb851-3205-4338-b1e7-5a324e848200" class="bulleted-list"><li style="list-style-type:disc">(포인터 전용) <code>const</code> 포인터가 가리키는 대상의 값은 변경 가능</li></ul><pre id="6c5e12b2-edcd-4132-a236-10e7b1dbc1c5" class="code"><code>/* const int 변수 */
    
    const int score = 100;      /* 생성과 동시에 초기화해야 함 */ 
    score = 0;                  /* 초기화 이후 다른 값으로 변경 불가 */
    int pop_score = score;      /* const가 아닌 변수에 대입은 가능 */
    
    /* int* const 변수 */
    int* const p = &amp;num;        /* 생성과 동시에 초기화해야 함 */
    p = &amp;score;                 /* 초기화 이후 다른 값으로 변경 불가 */
    int* q = p;                 /* const가 아닌 변수에 대입은 가능 */
    *p = 1024;                  /* const 포인터가 가리키는 대상의 값은 변경 가능 */</code></pre><h3 id="cc82166b-1f00-4fa2-a832-73f815dcb597" class="">const를 가리키는 포인터 : 값의 보호</h3><pre id="126c2e80-dcc8-4c7c-9721-5e1efa7a7c39" class="code"><code>const int* p = &amp;num1;    /* 방법 1 */
    int const * p = &amp;num1;   /* 방법 2 */</code></pre><ul id="b06e4f9c-c8ea-43f0-b240-cb516c0462ba" class="bulleted-list"><li style="list-style-type:disc">실수가 있을 경우 함수 내에서 뿐만 아니라 전역적으로 문제가 발생</li></ul><ul id="f1c5cd9f-9d7e-48c4-b9ef-1dc99c343dfb" class="bulleted-list"><li style="list-style-type:disc">주소 보호보다 더 중요함</li></ul><ul id="6267f2a7-b0b6-4a21-b17e-9f2c6c0e8bac" class="bulleted-list"><li style="list-style-type:disc">값을 보호하기 위한 <code>const</code>는 반드시 신경써야함</li></ul><ul id="e503b580-d746-4044-aa9e-60bfc7dbcbfd" class="bulleted-list"><li style="list-style-type:disc">그 주소에 저장되어 있는 값을 변경하는 것을 방지</li></ul><ul id="a4f97f2c-3eb0-43ee-bec6-6a063facafbf" class="bulleted-list"><li style="list-style-type:disc">포인터 변수는 오른쪽에서 왼쪽으로 읽음<p id="1bec67e4-d960-4a05-a91a-449bdf1fed99" class="">⇒ 방법 1 : &quot;p is a pointer to int, which is const&quot;</p><p id="27b910a6-a16e-4ba3-af13-c9b2a484189b" class="">⇒ 방법 2 : &quot;p is a pointer to const int&quot;</p></li></ul><ul id="302085fc-4076-4ce0-8156-846267635913" class="bulleted-list"><li style="list-style-type:disc">논리적으로 방법 2가 더 말이 되나 흔히 방법 1로 표현함. 혹은 포인터가 아닌 <code>int</code>를 <code>const</code>를 만들 때도 <code>const int</code>라고 하므로 비슷하게 보이려고 방법 1을 더 많이 씀</li></ul><h3 id="2e7115c6-c94a-4c58-985c-51dcb6eb3904" class="">두 const 정리</h3><pre id="91a9689e-20c9-4094-8549-e419003229a2" class="code"><code>int* const p = &amp;num;   /* 메모리 주소 변경 금지 */
    
    const int* p = &amp;num;   /* 메모리 주소에 저장되어 있는 값 변경 금지 */</code></pre><p id="3d3d31af-8aa9-444b-8ef8-4344a9e0f728" class="">⇒ 헷갈릴 땐 오른쪽에서 왼쪽으로, <code>*</code>을 &quot;포인터, 무엇을 가리키냐면&quot;라고 바꿔 읽어보면 쉬움</p><h3 id="930a86dd-371f-4dc8-8373-ddaeb50f6a60" class="">두 const 합체</h3><pre id="6e9f05f4-20c5-42da-b244-d44c14e9f734" class="code"><code>const int* const p = &amp;num;  /* 메모리 주소와 그 주소 저장값 둘다 변경 금지 */</code></pre><ul id="e8ff6647-6b91-4943-b60c-d317c234dc46" class="bulleted-list"><li style="list-style-type:disc">&quot;p is a const pointer to const int&quot;</li></ul><ul id="62d35a9c-df65-404b-bd6f-5693bafa8a42" class="bulleted-list"><li style="list-style-type:disc">초기화된 후 절대 바뀌지 않는 변수가 있을 때 정도만 유용<p id="97d43600-ff57-4d53-9ed8-52804a8f39b9" class="">⇒ 전역변수, 구조체 멤버 변수</p></li></ul><h3 id="655fbea7-6298-46c9-8508-816e09253454" class="">절대 하지말아야 할 const 제거</h3><pre id="b8c651a6-2d6f-4ca7-bc71-b682e77af265" class="code"><code>void print_array(const int* data, const int length)
    {
        *((int*)data) = 10;
    }
    
    /* 메인 함수 */
    int nums[] = { 1024, 9 };
    print_array(nums, 2); /* 함수 호출 후 nums[0] 값이 10이 됨 */</code></pre><ul id="1211cb2e-94c1-4ac8-8bc3-e80ed44ea2f0" class="bulleted-list"><li style="list-style-type:disc">캐스팅을 통해서 <code>const</code>를 제거할 수 있음 (<code>const int*</code> → <code>int*</code>로 바꿔버림)</li></ul><ul id="07ac553b-a0db-4b08-961d-4e29c88f31d5" class="bulleted-list"><li style="list-style-type:disc">기본 자료형에서는 큰 문제가 아님<p id="212e5539-b347-4c3c-9d45-e1e7119ddbf3" class="">⇒ 매개변수의 값을 복사해서 오기 때문에 그 매개변수의 값을 바꾼다고 원본이 바뀌지 않음</p></li></ul><ul id="d699b7d7-66d8-4b60-a88f-fb53088fdb94" class="bulleted-list"><li style="list-style-type:disc">그러나 <code>const</code>를 가리키는 포인터의 경우 문제가됨<p id="2ecabfe1-5eb6-4ca1-ba34-1ad4819bd618" class="">⇒ <code>const</code>를 제거하고 값을 바꾸면 원본이 바뀜</p></li></ul><h3 id="76ca6224-a4c5-4a9b-b50d-835d1b51633b" class="">const : BEST PRACTICES</h3><ul id="ac82afad-8c5f-4081-9a51-18175685b97e" class="bulleted-list"><li style="list-style-type:disc"><code>const</code>는 반드시 <code>const</code>가 필요없는 경우가 아니라면 최대한 다 붙일 것</li></ul><ul id="e70c41c7-a5b9-47bb-b9e5-f16ea8c2e586" class="bulleted-list"><li style="list-style-type:disc"><code>const</code> 캐스팅은 하지 말 것</li></ul><h2 id="031b0cf9-80e0-4435-87d8-d615f6034a64" class="">포인터의 용도</h2><h3 id="3e254da9-e2b5-4063-b0ab-956581a3ab00" class="">(1) 큰 데이터를 매개변수로 전달할 때</h3><ul id="21f0a7ee-fdc0-40ed-89b7-cd9ddcf41717" class="bulleted-list"><li style="list-style-type:disc">큰 데이터 매개변수 ⇒ 배열</li></ul><ul id="240a0137-bb21-49d9-9e7f-1a17a8906bf1" class="bulleted-list"><li style="list-style-type:disc">배열의 요소가 커질수록 데이터를 복사하느라 시간을 낭비함</li></ul><ul id="c9a846c9-822d-4ebc-a41e-f6d037cb0c56" class="bulleted-list"><li style="list-style-type:disc">그래서 배열이 매개변수로 전달될 경우, 첫 번째 요소의 주소를 전달</li></ul><h3 id="9ac2bd21-b59f-4031-9e99-b6439f07ae30" class="">(2) 반환값이 둘 이상일 때</h3><ul id="abef8c5a-37ab-4f8c-9069-c2417899452d" class="bulleted-list"><li style="list-style-type:disc">C에서 return문으로 불가능 ⇒ 언제나 하나만 반환해야함</li></ul><ul id="39922e04-357d-4d4e-98fc-9584915324fd" class="bulleted-list"><li style="list-style-type:disc">하지만 포인터를 사용하면 함수 안에서 원본을 직접 변경할 수 있음</li></ul><ul id="0d6d3ae1-5f08-4c4f-83cf-1a65bc1a833c" class="bulleted-list"><li style="list-style-type:disc">원본의 값을 읽지 않고 그냥 덮어쓰는 거라면 반환이나 마찬가지</li></ul><h3 id="e4f13f9e-0407-472e-876b-641a9a666b6f" class="">(3) 동적 메모리 할당</h3><ul id="aabfbdd0-e09b-405e-8ccf-69994edbe656" class="bulleted-list"><li style="list-style-type:disc">함수의 범위에 상관없이 한동안 사용하고자 하는 데이터가 다음과 같은 경우에 해당하면<p id="9fbcc027-49dd-41aa-9042-1f68161f5a9c" class="">1) 그 데이터의 크기를 컴파일 도중에 알 수 없거나</p><p id="ad20354e-096a-489b-9202-a96c58fcfb97" class="">2) 프로그램 실행수명보다 짧은 시간동안만 사용하려고 할 때</p></li></ul><ul id="1fea1589-fcca-4de8-ab33-d330e9cdbc91" class="bulleted-list"><li style="list-style-type:disc">동적으로 할당된 메모리는 역시 연속된 메모리 덩어리</li></ul><ul id="1ffa6c22-8eb4-41e9-bb60-b5676a041ae0" class="bulleted-list"><li style="list-style-type:disc">따라서 포인터가 적합 ⇒ 배열과 비슷한 이유</li></ul><h3 id="43688ae6-361f-454b-8c46-b3d5eefb7c75" class="">(4) 그 외...</h3><ul id="7aec255d-3882-4546-8024-6286c2ab9414" class="bulleted-list"><li style="list-style-type:disc">데이터 구조를 구현할 때<p id="02428d35-e1ee-4a9d-90f0-2613809effe0" class="">⇒ 연결 리스트, 트리 등과 같은 데이터 구조</p></li></ul><ul id="9b17fb22-3d6b-43da-bfbc-90f5c7ec7179" class="bulleted-list"><li style="list-style-type:disc">임베디드 프로그래밍 등에서 하드웨어에 있는 메모리에 직접 접근해야할 때<p id="50917121-68f3-498f-b733-c1496a0c2ce8" class="">⇒ 예 : 어떤 하드웨어는 화면을 보여주려면 특정 메모리 위치에 이미지 데이터를 직접 복사해줘야 함</p></li></ul><h2 id="1cfef301-727b-45a7-b299-6b951a818a1f" class="">포인터 배열</h2><ul id="da98b97d-baea-4570-9c7e-b132c4fb1e6e" class="bulleted-list"><li style="list-style-type:disc">포인터도 그냥 변수니 당연히 포인터를 저장하는 배열도 있음</li></ul><ul id="c763467a-6787-47cf-99c2-8c0ccef6e48c" class="bulleted-list"><li style="list-style-type:disc">배열의 선언<pre id="3dcb2c8b-3b0e-4e11-842e-4139ab9a7953" class="code"><code>/* int를 담는 배열 선언 */
    int nums[3];
    
    /* int*를 담는 배열 선언 */
    int* num_pointer[3];</code></pre></li></ul><ul id="de2a473b-7a8d-4a46-8c95-891f4133b7f9" class="bulleted-list"><li style="list-style-type:disc">&#x27;배열의 배열&#x27;과 비슷한 개념<p id="bfdc3a92-44f8-48f9-8ea6-c54371635af0" class="">⇒ 바깥 쪽 배열은 행, 안쪽 배열은 열</p><p id="790c595a-97d3-4474-ab3d-b9e992e72cee" class="">⇒ 각 행마다 열의 길이가 달라질 수 있음</p></li></ul><h3 id="69e00540-7a9f-4df4-8eb1-24d519b3f9aa" class="">포인터 배열 예시</h3><pre id="f67ce651-388b-4fdc-b2a1-5c74a2990ce8" class="code"><code>int nums1[3] = { 11, 22, 33 };
    int nums2[1] = { 90 };
    int nums3[4] = { 88, 36, 37 };
    
    int* num_pointer[3];
    num_pointer[0] = nums1;
    num_pointer[1] = nums2;
    num_pointer[2] = nums3;</code></pre><h3 id="3ba1835e-ac49-4b18-a1fe-653c8cca5eff" class="">함수의 포인터 배열 접근</h3><ul id="c7469a7b-5d6c-4e26-b0c4-1acbf32596fe" class="bulleted-list"><li style="list-style-type:disc">함수에서 포인터 배열을 접근하려면 각 내부의 길이를 알려주는 <code>size_t</code> 배열이 필요</li></ul><pre id="9957bff7-6208-4473-8733-d708fd92bff0" class="code"><code>void print_array(int* const data[], const size_t size, const size_t lengths)
    {
        size_t i;
        size_t j;
        const int* p;
    
        for (i = 0; i &lt; size; ++i) {
            p = data[i];
            printf(&quot;nums[%d]:&quot;, i)
            
            for (j = 0; j &lt; lengths[i]; ++j) {
                printf(&quot;%d&quot;, p[j]);
            }
        }
    }
    
    /*
    아래와 같은 형식의 데이터가 나오게 됨
    num[0] = { 11, 22, 33 };
    num[1] = { 90 };
    num[2] = { 88, 36, 37 };
    */</code></pre><h3 id="e8b1c453-697f-416a-a8cb-1e5f8bbac095" class="">2차원 배열</h3><p id="c017ea5b-5e7e-4289-97c5-653414bf59d6" class="">배열과 포인트가 같다면 2D 배열도 위와 같이 사용이 가능할까?</p><pre id="4f2f48c5-efcd-4967-94ac-c103e0194622" class="code"><code>/* 컴파일 오류 */
    
    void do_magic(int* matrix[5])
    {
        /* 코드 생략 */
    }
    
    int main(void)
    {
        int matrix[5][10] = {
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
        };
    
        do_magic(matrix);
    }</code></pre><ul id="e93db037-2da1-498e-9a5b-6d7f9dd448a8" class="bulleted-list"><li style="list-style-type:disc">2차원 배열은 한 덩어리 메모리라 주소의 값이 저장된 곳이 없음</li></ul><ul id="12333135-503b-440e-ab7e-5e58f502f121" class="bulleted-list"><li style="list-style-type:disc">올바른 방법<pre id="be3aaf41-4266-4f5c-9eb7-50cbde3a0b35" class="code"><code>void do_magic(int matrix[][10], size_t m)   /* m : 행의 수 */
    {
        /* 코드 생략 */
    }</code></pre><p id="e453c8ae-e455-4801-ad53-e6e5c9b26c03" class="">⇒ 컴파일러가 매개변수가 2차원 배열이라는 것을 인지하며 <code>matrix[1][ ]</code> 할 때 몇개를 건너 뛰어야 하는지 알 수 있음</p></li></ul><pre id="00b33139-ece5-46cb-b926-f5d590f46563" class="code"><code>/* 컴파일 */
    
    void do_magic(int* matrix[][10], size_t m)
    {
        /* 코드 생략 */
    }
    
    int main(void)
    {
        int matrix[5][10] = {
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
        };
    
        do_magic(matrix, 5);
    }</code></pre><p id="518a39e1-707d-47fa-ba95-85af299cc24e" class="">
    </p><p id="b8a38e8d-6996-44ef-99ed-3399d9b0eba3" class="">
    </p></div></article></body>

{% endblock post_content %}