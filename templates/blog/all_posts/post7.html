{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(5) 포인터</a>
{% endblock post_title %}

{% block post_content %}

    {% block post_date %}
        <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 17, 2021 ]</div>    
    {% endblock post_date %}

    <main class="container w-1/2 mx-auto font_kor">
        <div>
            <div class="post_subheading">주소를 사용해서 메모리 내 변수 접근</div>
            <div class="post_text">
                <img src="{% static 'img/sourcecode/post7-1.png' %}">
                <li>다른 언어였다면 불가능</li>
                <li>하지만 C는 하드웨어와 가장 친한 친구로 가능</li>
                <li>이것을 활용하여 매우 강력한 일을 할 수 있음</li>
            </div>
        </div>
        <div id="주소연산자">
            <div class="post_heading">주소연산자 &</div>
            <div class="post_text">
                <img src="{% static 'img/sourcecode/post7-2.png' %}">
                <li>일단 어떤 변수가 어느 주소에 저장되어 있는지 알 수 있는 첫 단계</li>
                <li>비트 연산자 &가 아님</li>
                <p class="ml-7">⇒ 비트 연산자는 피연산자가 2개, 주소 연산자는 피연산자가 1개</p>
                <img src="{% static 'img/sourcecode/post7-3.png' %}" class="ml-7">
                <li>num이란 변수가 있으면 &num은 그 변수가 위치한 메모리 주소</li>
                <li>보통 주소를 보여줄 때는 16진수를 사용 → printf()에서 서식문자 %p는 주소를 16진수로 보여줌</li>
                <li>실행할 때마다 주소가 달라질 수 있음 → 요즘 운영체제에서는 보안강화를 위해 실행할 때마다 주소를 바꿔줌(ASLR)</li>
            </div>
            <div class="post_subheading">메모리 주소 저장하기</div>
            <div class="post_text">
                <p class="font-bold">< 의문점 ></p>
                <li>주소를 구할 때마다 그 변수가 필요하다면 그냥 그 변수를 쓰고 말지</li>
                <li>그보다는 그 주소를 어딘가에 저장해 둘 수 있다면 좋을 것 같은데..</li>
                <li>그러면 변수가 없어도 주소만으로 여기저기 옮겨다닐 수 있을텐데..</li>
                <p class="ml-7">⇒ 가령 '변수의 주소'의 다음 메모리 위치를 읽는다던가</p>
                <p class="font-bold">< 메모리 주소를 변수처럼 저장 시도 ></p>
                <img src="{% static 'img/sourcecode/post7-4.png' %}">
                <p class="font-bold">< 문제점 ></p>
                <img src="{% static 'img/sourcecode/post7-5.png' %}">
                <li>둘 중 무엇이 '주소'고 무엇이 '값'인지 알 수 없음</li>
                <li>따라서 주소를 저장하기 위한 특별한 변수가 필요함 ⇒ <span class="font-bold">포인터</span></li>
            </div>
        </div>
        <div id="포인터의미">
            <div class="post_heading">포인터의 의미</div>
            <div class="post_text">
                <li>주소를 저장하기 위한 변수형</li>
                <li>즉, 변수인데 속에 담긴 내용은 메모리 주소를 의미함</li>
                <p class="ml-7">⇒ 주소 : 값이 저장되어 있는 메모리의 위치</p>
            </div>
            <div class="post_subheading">메모리 주소에 저장된 자료형</div>
            <div class="post_text">
                <li>하드웨어는 신경 안씀</li>
                <p class="ml-7">⇒ 그 비트패턴을 char로 읽으면 char, int로 읽으면 int, float으로 읽으면 float이 됨</p>
                <li>그러나 해당 주소에서부터 몇 바이트를 읽어야하는지는 하드웨어에게 알려줄 필요가 있음. 그래서 포인터 변수를 선언할 때는 '그 주소에 어떤 형의 데이터가 있는지' 명시하기 위해 포인터 앞에 자료형을 붙임 (int 포인터, float 포인터, char 포인터)</li>
            </div>
            <div class="post_subheading">포인터 변수를 선언하는 법 / 부르는 법</div>
            <img src="{% static 'img/sourcecode/post7-6.png' %}">
            <div class="post_text">
                <li>포인터 변수를 선언하려면 자료형 뒤에 별표(*)를 붙임</li>
                <li>별표 왼쪽에 있는 자료형은 그 메모리 주소로 가면 저장되어 있는 자료형</li>
                <div class="ml-7">
                    <p>a. int* : 주소를 따라가면 int형 자료가 있음</p>
                    <p>b. char* : 주소를 따라가면 char형 자료가 있음</p>
                    <p>c. float* : 주소를 따라가면 float형 자료가 있음</p>
                </div>
                <li>보통 num_adress를 int 포인터라고 부름</li>
                <p class="ml-7">⇒ 영어로는 int로의 포인터(pointer to an int)라고도 함 (뒤에서부터 읽음)</p>
            </div>
            <div class="post_subheading">포인터 변수의 저장 위치</div>
            <div class="post_text">
                <li>포인터는 메모리 주소를 저장하는 변수</li>
                <li>그러면 이 변수는 어디에 저장이 되어 있는가 → 메모리 어딘가</li>
                <li>기본적으로 "메모리 주소를 저장하는 변수"라고 기억하고 시각적으로 보는게 필요하면 그려보는게 좋음</li>
            </div>
            <div class="post_subheading">포인터에 저장된 주소도 바꿀 수 있는가?</div>
            <img src="{% static 'img/sourcecode/post7-7.png' %}">
            <div class="post_text">
                <li>포인터도 변수이기 때문에 포인터에 저장한 값도 변경 가능</li>
                <li>즉, 다른 주소로 바꿀 수 있음</li>
            </div>
        </div>
        <div id="역참조연산자">
            <div class="post_heading">역 참조 연산자 *</div>
            <div class="post_text">
                <li>포인터도 변수니까 당연히 변수 쓰는 곳에는 다 쓸 수 있음</li>
                <li>따라서 매개변수도 가능</li>
                <li>곱하기 연산자가 아님</li>
                <p class="ml-7">⇒ 곱하기 연산자는 피연산자 2개, 역 참조 연산자는 피연산자가 1개</p>
                <img src="{% static 'img/sourcecode/post7-8.png' %}" class="ml-7">
            </div>
            <div class="post_subheading">역 참조 연산자 예시</div>
            <div class="post_text">
                <img src="{% static 'img/sourcecode/post7-9.png' %}">
                <p>⇒ 하지만 위의 함수는 단순히 주소만 보여주며 별 의미있는 함수가 되지 못함</p>
                <img src="{% static 'img/sourcecode/post7-10.png' %}">
            </div>
            <div class="post_subheading">참조와 역 참조</div>
            <div class="post_text">
                <p>< 참조 ></p>
                <li>포인터가 이미 하고있는 일</li>
                <li>어떤 변수의 값을 직접 가져다 쓰는 게 아니라 그게 어디에 있는지 '참조'</li>
                <li>즉, 값이 어디에 있는지 가리키고 있는것</li>
                <p>< 역 참조 ></p>
                <li>주소로 직접 가서 거기 저장되어 있는 값에 접근하는 것</li>
                <li>참조(reference)의 반대라 역 참조(de-reference)라 말함</li>
                <li>값에 직접 접근하는게 아니라 주소를 이용해 간접적(한 단계 거쳐서)으로 접근</li>
                <li>따라서 간접(indirect) 연산자라고도 함</li>
                <p class="ml-7">⇒ 여태까지는 모든 데이터를 복사해서 썼다면 이는 원본에 접근 가능</p>
                <p class="ml-7">⇒ 컴퓨터 구조에서 데이터를 오랫동안 메모리에 저장하는 방법</p>
            </div>
            <div class="post_subheading">역 참조를 통해 값을 변경하는 예</div>
            <img src="{% static 'img/sourcecode/post7-11.png' %}" class="mb-6">
            <img src="{% static 'img/sourcecode/post7-12.png' %}" class="mb-6">
            <div class="post_subheading">퀴즈</div>
            <img src="{% static 'img/sourcecode/post7-13.png' %}" class="mb-6">
            <div class="post_subheading">swap()</div>
            <img src="{% static 'img/sourcecode/post7-14.png' %}">
            <div class="post_text">
                <li>실제로 교체되지 않음</li>
                <li>스택 메모리에서 값을 복사하기 때문</li>
                <li>C#에서는 ref 키워드로 해결, 하지만 C는 그런 키워드 없음</li>
                <p class="ml-7 font-bold">⇒ 아래와 같이 포인터로 해결 가능</p>
                <img src="{% static 'img/sourcecode/post7-15.png' %}">
            </div>
            <div class="post_subheading">값에 의한 전달 vs 참조에 의한 전달</div>
            <div class="post_text">
                <li>원본이 바뀌니 ⇒ 참조에 의한 전달</li>
                <li>하지만 메모리 주소를 복사하였으니 ⇒ 값에 의한 전달</li>
                <li>함수를 호출할 때 언제나 변수를 복사하므로 값에 의한 전달</li>
                <li>단, 포인터를 사용해서 참조에 의한 전달을 흉내낼 뿐</li>
                <li>원본이 바뀌는지 안 바뀌는지가 핵심 포인트임</li>
                <li>굳이 '~에 의한 전달'이라고 말해야 한다면 '참조에 의한 전달'이라고 말하는게 차라리 나음</li>
            </div>
        </div>
        <div id="포인터함수반환값">
            <div class="post_heading">포인터와 함수 반환값</div>
            <div class="post_text">
                <li>당연히 포인터도 변수니까 함수 반환값으로 사용 가능</li>
                <li>다만 포인터를 반환할 때 조심해야할 것들이 있음</li>
            </div>
            <div class="post_subheading">댕글링 포인터(dangling pointer)</div>
            <img src="{% static 'img/sourcecode/post7-16.png' %}">
            <div class="post_text">
                <li>함수의 지역변수는 스택에 저장됨</li>
                <li class="font-bold">즉, 함수의 호출이 끝나면 지역 변수도 사라짐 (return &result)</li>
                <li>그러나 지역변수가 사용한 '주소'자체가 사라지는 것은 아님</li>
                <li>따라서 그 주소를 반환한다고 컴퓨일 오류가 나지는 않음</li>
                <p class="ml-7">⇒ 컴파일러에 따라 상기와 같은 경고를 줄 수 있음</p>
                <li>문제는 포인터가 유효하지 않은 주소를 가리킴</li>
                <p class="ml-7">⇒ 이 경우 예측하지 못한 결과가 발생할 수 있음</p>
                <li>이러한 포인터를 댕글링 포인터라고 하며, <span class="font-bold">절대 작성해서는 안되는 코드</span>임</li>
            </div>
            <div class="post_subheading">포인터와 함수 반환값 정리</div>
            <div class="post_text">
                <li>포인터를 반환할 경우 댕글링 포인트를 조심해야함</li>
                <li>포인터를 반환해도 되는 경우</li>
                <div class="ml-7">
                    <p>a. 전역변수</p>
                    <p>b. 파일 속 static 전역변수</p>
                    <p>c. 함수 내 static 변수</p>
                    <p>d. 힙 메모리에 생성한 데이터</p>
                </div>
                <li>포인터 함수 반환값의 사용</li>
                <div class="ml-7">
                    <p>a. 도우미 함수 안에 생선한 변수를 다른 함수에서 사용하고자 할 때</p>
                    <p class="ml-5">⇒ 단, 일반 지역변수면 안됨 (함수 호출이 끝나면 사라짐)</p>
                    <p>b. 함수 안에서 대용량 데이터를 생성하고 그걸 반환하고자 할 때</p>
                    <p class="ml-5">⇒ 이 경우에는 스택 메모리가 아니라 힙 메모리라는 곳에서 생성함</p>
                </div>
            </div>

        </div>
        <div id="널포인터">
            <div class="post_heading">널(NULL) 포인터</div>
            <img src="{% static 'img/sourcecode/post7-17.png' %}">
            <div class="post_text">
                <li>반환할 주소가 없는 경우</li>
            </div>
            <div class="post_subheading">널 포인터</div>
            <div class="post_text">
                <li>아무것도 카리키지 않는 포인터 → 실제 주소가 없음 → 유효한 메모리를 가리키고 있지 않음</li>
                <li>1) 값이 '0'인 정수/상수 표현식, 혹은 2) void*로 캐스팅 된 표현식</li>
                <li>전용 매크로가 있음</li>
                <img src="{% static 'img/sourcecode/post7-18.png' %}" class="ml-7">
                <p class="ml-7">⇒ 널 포인터를 표현할 때 위의 매크로를 사용할 것</p>
                <li>포인터 변수와 NULL은 비교(==, !=) 가능</li>
                <img src="{% static 'img/sourcecode/post7-19.png' %}" class="ml-7">
            </div>
            <div class="post_subheading">코딩표준 : 매크로 NULL을 반드시 사용할 것</div>
            <img src="{% static 'img/sourcecode/post7-20.png' %}">
            <div class="post_text">
                <li>0은 사용하지 않음!</li>
                <li>if (ptr) 만 사용하여도 존재할 때와 아닐 때를 구분할 수 있어 혼돈이 적으나 왠만하면 직접 표시해주는 것이 좋음</li>
            </div>
            <div class="post_subheading">널 포인터와 매개변수</div>
            <div class="post_text">
                <li>함수 매개변수로 포인터가 들어올 올 때는 언제나 골칫덩어리</li>
                <li>누구나 NULL을 넣을 수 있기 때문</li>
                <li>함수의 선조건(precondition) 문제</li>
                <li>기본적으로 NULL이 안 들어온다고 가정하고 함수 작성</li>
                <li>NULL이 들어올 수 있는 함수는 매개변수 명에서 분명하게 밝혀야함</li>
            </div>
            <div class="post_subheading">코딩 표준 : 널 포인터를 허용하는 매개변수</div>
            <div class="post_text">
                <li>함수의 매개변수가 널 포인터를 허용한다면, 매개변수 이름 끝에 'or_null'을 붙이는 것이 좋음</li>
                <img src="{% static 'img/sourcecode/post7-21.png' %}" class="ml-7">
                <li>NULL이 안 들어온다고 가정한 경우 assert()를 사용해 검증</li>
                <img src="{% static 'img/sourcecode/post7-22.png' %}" class="ml-7">
            </div>
            <div class="post_box post_text">
                <p class="font-bold">assert 함수</p>
                <li>디버깅 모드에서 개발자가 오류가 생기면 치명적일 것이라는 곳에 심어 놓는 에러 검출용 코드</li>
                <li>디버깅용 함수이기에 release 모드에서는 동작하지 않음 ⇒ 코드를 다 완성하고 동작할 때 돌아가는 함수가 아님</li>
                <li>assert함수에 걸리게 되면 버그 발생위치, call stack등 여러 정보를 알 수 있음</li>
                <li>assert(A != NULL);</li>
                <p class="ml-7">A가 NULL이 아니라면 true(1)가 나오므로 pass</p>
                <p class="ml-7">A가 NULL이라면 false(0)가 나오므로 assert error</p>
            </div>
            <div class="post_subheading">널 포인터와 반환값</div>
            <div class="post_text">
                <li>NULL을 반환할 때도 마찬가지</li>
                <li>기본적으로 안 함</li>
                <li>반환해야 한다면 함수 이름에 NULL을 반환하는 것을 명시</li>
            </div>
            <div class="post_subheading">코딩 표준 : 널 포인터를 반환하는 함수명</div>
            <img src="{% static 'img/sourcecode/post7-23.png' %}" class="mb-6">
            <div class="post_subheading">널 포인터의 사용</div>
            <div class="post_text">
                <p>1. 포인터 변수를 초기화하고 싶을 때</p>
                <img src="{% static 'img/sourcecode/post7-24.png' %}" class="ml-7">
                <p class="ml-7">⇒ 아직 참조할 주소가 없을 때</p>
                <p>2. 포인터 변수가 유효하지 않은 주소를 참조하고 있는지 확인하고 싶을 때</p>
                <img src="{% static 'img/sourcecode/post7-25.png' %}" class="ml-7">
                <p class="ml-7">⇒ 아무것도 가리키지 않는 포인트 변수를 역 참조하면 결과가 정의되지 않음 (undifined)</p>
                <img src="{% static 'img/sourcecode/post7-26.png' %}" class="ml-7">
                <p class="ml-7">⇒ 역 참조를 하기 전에 널 포인터인지 확인해야함</p>
                <p>3. 댕글링 포인터를 막기 위해</p>
                <img src="{% static 'img/sourcecode/post7-27.png' %}" class="ml-7">
                <p class="ml-7">⇒ 동적 메모리 할당된 메모리를 더이상 필요 없어서 해제했는데, 이를 여전히 가리키는 포인트가 있다면? 더이상 사용할 수 없는 데이터니 포인터 변수에 저장되어 있는 그 주소를 초기화 해야함 → 이때 널 포인터를 이용해서 리셋</p>
            </div>
            <div class="post_text">
                <p class="font-bold">결과적으로 존재하지 않는 메모리 주소에서 값을 읽어오려면 여러 가지 문제들이 팡팡 터짐. 항상 조심해야하는 부분임</p>
            </div>
        </div>
        <div id="포인터비교/크기">
            <div class="post_heading">포인터의 비교/크기</div>
            <div class="post_subheading">포인터의 비교</div>
            <img src="{% static 'img/sourcecode/post7-28.png' %}">
            <div class="post_text">
                <li>포인터는 비교 연산자를 이용해서 서로 비교할 수 있음 (==. !=, >, >=, < <=)</li>
            </div>
            <div class="post_subheading">포인터의 크기</div>
            <div class="post_text">
                <li>모든 포인터는 동일한 크기를 가짐</li>
                <li>포인터의 크기는 코드를 컴파일하는 시스템 아키텍쳐에 따라 결정됨</li>
                <p class="ml-7">⇒ 보통 CPU가 한 번에 처리할 수 있는 데이터의 크기(word)와 동일함</p>
                <p class="ml-11">32비트 아키텍쳐에서 포인트 크기는 4바이트</p>
                <p class="ml-11">64바이트 아키텍쳐에서 포인트 크기는 8바이트</p>
                <img src="{% static 'img/sourcecode/post7-29.png' %}" class="mb-6">
            </div>
        </div>
        <div id="포인터와배열">
            <div class="post_heading">포인터와 배열</div>
            <div class="post_subheading">포인터와 매개변수로 받은 배열</div>
            <div class="post_text">
                <li>매개변수로 받은 배열</li>
                <p class="ml-7">⇒ 배열은 연속된 메모리 → 그걸 다 스택에 넣을 수 없음 → 시작위치만 전달(메모리 주소)</p>
                <img src="{% static 'img/sourcecode/post7-30.png' %}" class="ml-7">
                <p class="ml-7">a. scores의 크기는 4바이트</p>
                <p class="ml-7">b. scores는 my_scores의 시작주소를 가지고 있음</p>
                <li>포인터</li>
                <img src="{% static 'img/sourcecode/post7-31.png' %}" class="ml-7">
                <p class="ml-7">a. dollar의 크기는 4바이트</p>
                <p class="ml-7">b. dollar는 my_money의 (시작)주소를 가지고 있음</p>
            </div>
            <div class="post_subheading">배열을 포인터에 대입</div>
            <img src="{% static 'img/sourcecode/post7-32.png' %}">
            <div class="post_text">
                <p>1. nums는 배열로, 시작위치(메모리 주소) 반환</p>
                <p>2. nums는 시작주소를 반환하지만, nums[0]은 주소가 아닌 int를 반환함</p>
                <p class="ml-5">⇒ 즉, nums[0]은 int이며, int*가 아님!</p>
                <p>3. nums[0]의 주소를 얻기 위해서는 주소 연산자를 이용해야함</p>
                <p>⇒ 정리하자면, 아래의 두 코드는 동일한 결과를 나타냄</p>
                <img src="{% static 'img/sourcecode/post7-33.png' %}">
            </div>
            <div class="post_subheading">배열 속에서 각 요소의 위치</div>
            <img src="{% static 'img/sourcecode/post7-34.png' %}">
            <div class="post_text">
                <li>배열에서 각 요소 사이의 바이트 간격을 일정함</li>
                <li>따라서 첫 번쨰 요소의 주소와 자료형의 크기를 안다면 두번째 요소의 주소를 알 수 있음</li>
                <p class="ml-7">⇒ 두 번째 요소 주소 = 첫 번째 요소 주소 + 자료형의 크기(바이트)</p>
                <p class="ml-7">⇒ 세 번째 요소 주소 = 두 번째 요소 주소 + 자료형의 크기(바이트)</p>
            </div>
            <div class="post_subheading">포인터 주소 계산</div>
            <img src="{% static 'img/sourcecode/post7-35.png' %}">
            <div class="post_text">
                <p class="font-bold">⇒ 첫 번째 요소에서 자료형의 크기를 더 했는데 왜 nums[1]이 아닌 nums[4]가 나온 것일까?</p>
            </div>
            <div class="post_subheading">포인터에 정수의 덧셈 의미</div>
            <img src="{% static 'img/sourcecode/post7-36.png' %}">
            <div class="post_text">
                <li>포인터에 정수 1을 더한다는 것은 포인터의 위치를 다음 데이터로의 위치 이동을 의미함</li>
                <p class="ml-7">⇒ 1바이트를 더하는게 아님</p>
                <li>뺄셈뿐만 아니라, ++, --도 마찬가지임</li>
                <p>⇒ 정리하자면, 아래의 두 코드는 동일한 결과를 나타냄</p>
                <img src="{% static 'img/sourcecode/post7-37.png' %}">
            </div>
            <div class="post_subheading">포인터 사칙연산 퀴즈</div>
            <img src="{% static 'img/sourcecode/post7-38.png' %}">
            <img src="{% static 'img/sourcecode/post7-39.png' %}">
            <div class="post_subheading">배열 요소에 포인터로 접근하기</div>
            <img src="{% static 'img/sourcecode/post7-40.png' %}">
            <div class="post_text">
                <li>배열명은 시작 주소이기 때문에 포인터 변수에 대입할 수 있음 (int* ptr = nums;)</li>
                <li>추가적으로 배열의 첨자 연산자([])도 포인터에 쓸 수 있음 (ptr[1] = 20)</li>
                <li>포인터 산술 연산에도 배열 첨자 연산자에도 동일하게 적용됨 (ptr + 1)</li>
            </div>
            <div class="post_subheading">배열의 모든 요소 더하기</div>
            <img src="{% static 'img/sourcecode/post7-41.png' %}" class="mb-6">
            <div class="post_subheading">정리</div>
            <div class="post_text">
                <li>포인터에 들어가는 값은 주소</li>
                <li>C 연산자에서 이 주소를 얻을 수 있는 방법은 딱 두 가지 뿐</li>
                <div class="ml-7">
                    <p>1. 주소 연산자(&)</p>
                    <p>2. 배열의 이름 ⇒ 배열의 이름은 배열의 시작 주소르를 알려줌</p>
                    <img src="{% static 'img/sourcecode/post7-42.png' %}">
                </div>
                <li>포인터에 정수를 더하면 주소 이동</li>
                <div class="ml-7">
                    <p>⇒ 포인터에 정수 n을 더하거나 빼면 언제나 'sizeof(자료형) X n'한 만큼 메모리 주소 이동</p>
                    <img src="{% static 'img/sourcecode/post7-43.png' %}">
                </div>
            </div>
            <div class="post_subheading">포인터 캐스팅 : 정말 딱 '한' 바이트만 옮기고 싶다면?</div>
            <img src="{% static 'img/sourcecode/post7-44.png' %}">
            <div class="post_text">
                <li>한 바이트짜리 포인터로 캐스팅</li>
            </div>
            <div class="post_subheading">int* → char* 캐스팅의 의미</div>
            <img src="{% static 'img/sourcecode/post7-45.png' %}">
            <div class="post_text">
                <p>⇒ 메모리주소에 char형이 들어가  +1이 int 4바이트 이동이 아닌 char 1바이트 이동</p>
                <li>그 메모리 주소에 어떤 형이 들어있는 지 알려주는 것을 의미함</li>
                <p class="ml-7">⇒ 그 메모리 주소에 들어있는 값을 캐스팅하는 것이 아님!</p>
                <li>바꾸고 나면 실제 이 속에 들어 있는 데이터 내용이 char*이 되는 것이 아님</li>
            </div>
        </div>
        <div id="두주소간사칙연산">
            <div class="post_heading">두 주소간 사칙연산</div>
            <img src="{% static 'img/sourcecode/post7-46.png' %}">
            <div class="post_text">
                <li>주소에는 소수점을 더하거나 뺄 수 없으며, 정수만 가능</li>
            </div>
            <img src="{% static 'img/sourcecode/post7-47.png' %}">
            <div class="post_text">
                <li>뺄셈을 제외한 사칙연산은 모두 지원 안함</li>
                <li>뺄셈을 이용한다면 두 주소 사이에 들어갈 수 있는 데이터의 개수를 반환할 수 있음</li>
                <p class="ml-7">⇒ 따라서 포인터가 아니라 정수를 반환 (ptr3는 컴파일 오류)</p>
                <p class="ml-7">⇒ 배열의 첫 번째 및 마지막 요소의 주소를 알면 배열의 크기를 구할 수 있음</p>
                <img src="{% static 'img/sourcecode/post7-48.png' %}" class="ml-7">
            </div>
        </div>
        <div id="포인터와배열의차이">
            <div class="post_heading">포인터와 배열의 차이</div>
            <div class="post_text">
                <li>대부분의 경우 포인터와 배열은 동일하게 처리 가능</li>
                <li>그러나 이 둘은 다를 때가 있음</li>
            </div>
            <div class="post_subheading">(1) sizeof 연산자</div>
            <img src="{% static 'img/sourcecode/post7-49.png' %}">
            <div class="post_text">
                <li>sizeof(배열)과 sizeof(포인터는 다른 값을 반환함</li>
                <p class="ml-7">⇒ sizeof(배열) : 배열의 총 크기를 반환</p>
                <p class="ml-7">⇒ sizeof(포인터) : 포인터의 크기를 반환</p>
            </div>
            <div class="post_subheading">(2) 문자열 초기화</div>
            <div class="post_text">
                <li>C는 C#과 JAVA처럼 문자열(string) 자료형이 없음</li>
                <li>C의 문자열 표현방법</li>
                <div class="ml-7">
                    <p>"Friday"라는 단어를 저장한다면 총 6(+1)개의 요소를 가진 char 배열을 만듬</p>
                    <p>' F ' / ' r ' / ' i ' / ' d ' / ' a ' / ' y ' / ' \0 '</p>
                    <p>⇒ 문자열이 끝나는 지점을 알려주기 위해 널 문자(null character)라고 하는 특별한 문자를 항상 맨 마지막에 넣어줌</p>
                    <p>⇒ 널문자 : 값은 0으로 '\0'이라 표현함</p>
                </div>
                <li>문자열 초기화의 저장</li>
                <div class="ml-7">
                    <p>1. 배열(문자열)의 저장</p>
                    <img src="{% static 'img/sourcecode/post7-50.png' %}" class="ml-5">
                    <p class="ml-5">a. 배열의 마지막에 차례로 'M', 'o', 'n', 'd', 'a', 'y'가 들어간 후 마지막에 '\0'이 들어감</p>
                    <p class="ml-5">b. 함수 안에서 사용하면 스택메모리에 저장됨</p>
                    <p>2. 포인터(문자열)의 저장</p>
                    <img src="{% static 'img/sourcecode/post7-51.png' %}" class="ml-5">
                    <p class="ml-5">a. 포인터 변수는 스택에 저장</p>
                    <p class="ml-5">b. 실제 문자열은 데이터 섹션에 저장</p>
                </div>
                <li>문자열의 초기화</li>
                <div class="ml-7">
                    <img src="{% static 'img/sourcecode/post7-52.png' %}">
                    <p>a. 스택에 저장된 문자열은 수정해도 괜찮지만, 데이터 섹션에 저장된 문자열은 수정할 경우 '결과가 정의되지 않음'</p>
                    <p>b. 스택에 문자열이 저장되는 경우는 문자열이 읽기 전용임</p>
                </div>
            </div>
            <div class="post_subheading">(3) 대입</div>
            <img src="{% static 'img/sourcecode/post7-53.png' %}">
            <div class="post_text">
                <li>포인터 변수에 값을 대입할 수 있으나 배열 변수에는 할 수 없음</li>
            </div>
            <div class="post_subheading">(4) 포인터 산술 연산</div>
            <img src="{% static 'img/sourcecode/post7-54.png' %}">
            <div class="post_text">
                <li>포인터는 산술 연산이 가능하지만 배열은 불가능</li>
                <li>배열의 주소를 증가하거나 감소하고 싶다면 포인터에 배열의 주소를 대입 후 그 포인터 변수를 증가/감소하면 됨</li>
            </div>
        </div>
        <div id="포인터와 연산자">
            <div class="post_heading">포인터와 연산자</div>
            <div class="post_subheading">연산자 결합법칙</div>
            <div class="post_text">
                <li>연산자 결합법칙은 크게 고민할 이유는 없음</li>
                <li>익숙한 것들은 그냥 쓰고 아닌 것들은 괄호를 치는 것이 일반적임</li>
                <li>연산자 결합법칙이란?</li>
                <p class="ml-7">동일한 우선순위를 가지는 연산자들이 있으면 어떤 방향으로 연산자는 적용하는지를 의미함</p>
                <p class="ml-7">⇒ 대부분은 왼쪽에서 오른쪽이지만 몇몇 * 혹은 &과 같은 익숙하지 않은 연산자가 있음</p>
                <img src="{% static 'img/sourcecode/post7-55.png' %}" class="mb-3">
                <img src="{% static 'img/sourcecode/post7-56.png' %}" class="mb-3">
                <img src="{% static 'img/sourcecode/post7-57.png' %}">
            </div>
            <div class="post_subheading">조금더 빠른 배열의 요소 더하기 함수</div>
            <img src="{% static 'img/sourcecode/post7-58.png' %}">
            <div class="post_text">
                <li>포인터로 배열을 접근하는 것이 더 빠름 ⇒ *p++를 통해 접근하는 게 배열보다 빠름</li>
                <li>배열은 언제나 첫 주소 + 요소 위치까지의 오프셋</li>
                <p class="ml-7">⇒ &data[0] + 0*4 / data[0] + 1*4 / &data[0] + 2*4....</p>
                <li>포인터는 이미 다음 주소에 가 있기 때문에 그대로 참조</li>
                <p class="ml-7">⇒ p + 4 반복</p>
                <li> 요즘 컴파일러는 최적화를 잘해서 두 코드가 비슷한 성능을 보이기도 하지만 포팅을 생각해서 C에서는 여전히 *p++을 더 많이 씀</li>
            </div>

        </div>
        <div id="포인터와const">
            <div class="post_heading">포인터와 const</div>
            <div class="post_subheading">const</div>
            <img src="{% static 'img/sourcecode/post7-59.png' %}">
            <div class="post_text">
                <li>기본 자료형 변수의 경우 const를 붙이면 그 변수에 저장한 값을 변경할 수 없음</li>
                <div class="ml-7">
                    <p>a. 보통 이게 반드시 필요하다고 느끼진 않음</p>
                    <p>b. 따라서 이걸 반드시 붙이라고 강요하지 않는 코딩 표준도 많음</p>
                    <p>c. 실수가 발생해도 큰 문제가 발생하지 않기 때문</p>
                    <p>d. 함수번위 내에서 발생할 수 있는 실수를 막는 정도</p>
                </div>
            </div>
            <div class="post_subheading">const 포인터 : 주소의 보호</div>
            <img src="{% static 'img/sourcecode/post7-60.png' %}" class="mb-1">
            <img src="{% static 'img/sourcecode/post7-61.png' %}">
            <div class="post_text">
                <li>메모리 주소를 바꿀 수 없음</li>
                <li>포인터 변수는 오른쪽에서 왼쪽으로 읽음</li>
                <p class="ml-7">⇒ 영어로 표현하면, "p is const pointer to int"</p>
            </div>
            <div class="post_subheading">const 변수</div>
            <img src="{% static 'img/sourcecode/post7-62.png' %}">
            <div class="post_text">
                <li>생성과 동시에 초기화해야 함</li>
                <li>초기화 이후 다른 값으로 변경 불가</li>
                <li>const가 아닌 변수에 대입은 가능</li>
                <li>(포인터 전용) const 포인터가 가리키는 대상의 값은 변경 가능</li>
            </div>
            <div class="post_subheading">const를 가리키는 포인터 : 값의 보호</div>
            <img src="{% static 'img/sourcecode/post7-63.png' %}">
            <div class="post_text">
                <li>실수가 있을 경우 함수 내에서 뿐만 아니라 전역적으로 문제가 발생</li>
                <li>주소 보호보다 더 중요함</li>
                <li>값을 보호하기 위한 const는 반드시 신경써야함</li>
                <li>그 주소에 저장되어 있는 값을 변경하는 것을 방지</li>
                <li>포인터 변수는 오른쪽에서 왼쪽으로 읽음</li>
                <p class="ml-7">⇒ 방법 1 : "p is a pointer to int, which is const"</p>
                <p class="ml-7">⇒ 방법 2 : "p is a pointer to const int"</p>
                <li>논리적으로 방법 2가 더 말이 되나 흔히 방법 1로 표현함. 혹은 포인터가 아닌 int를 const를 만들 때도 const int라고 하므로 비슷하게 보이려고 방법 1을 더 많이 씀</li>
            </div>
            <div class="post_subheading">두 const 정리</div>
            <img src="{% static 'img/sourcecode/post7-64.png' %}">
            <div class="post_text">
                <p>⇒ 헷갈릴 땐 오른쪽에서 왼쪽으로, *을 "포인터, 무엇을 가리키냐면"라고 바꿔 읽어보면 쉬움</p>
            </div>
            <div class="post_subheading">두 const 합체</div>
            <img src="{% static 'img/sourcecode/post7-65.png' %}">
            <div class="post_text">
                <li>"p is a const pointer to const int"</li>
                <li>초기화된 후 절대 바뀌지 않는 변수가 있을 때 정도만 유용</li>
                <p class="ml-7">⇒ 전역변수, 구조체 멤버 변수</p>
            </div>
            <div class="post_subheading">절대 하지말아야 할 const 제거</div>
            <img src="{% static 'img/sourcecode/post7-66.png' %}">
            <div class="post_text">
                <li>캐스팅을 통해서 const를 제거할 수 있음 (const int* → int*로 바꿔버림)</li>
                <li>기본 자료형에서는 큰 문제가 아님</li>
                <p class="ml-7">⇒ 매개변수의 값을 복사해서 오기 때문에 그 매개변수의 값을 바꾼다고 원본이 바뀌지 않음</p>
                <li>그러나 const를 가리키는 포인터의 경우 문제가됨</li>
                <p class="ml-7">⇒ const를 제거하고 값을 바꾸면 원본이 바뀜</p>
            </div>
            <div class="post_subheading">const : BEST PRACTICES</div>
            <div class="post_text">
                <li>const는 반드시 const가 필요없는 경우가 아니라면 최대한 다 붙일 것</li>
                <li>const 캐스팅은 하지 말 것</li>
            </div>
        </div>
        <div id="포인터의용도">
            <div class="post_heading">포인터의 용도</div>
            <div class="post_subheading">(1) 큰 데이터를 매개변수로 전달할 때</div>
            <div class="post_text">
                <li>큰 데이터 매개변수 ⇒ 배열</li>
                <li>배열의 요소가 커질수록 데이터를 복사하느라 시간을 낭비함</li>
                <li>그래서 배열이 매개변수로 전달될 경우, 첫 번째 요소의 주소를 전달</li>
            </div>
            <div class="post_subheading">(2) 반환값이 둘 이상일 때</div>
            <div class="post_text">
                <li>C에서 return문으로 불가능 ⇒ 언제나 하나만 반환해야함</li>
                <li>하지만 포인터를 사용하면 함수 안에서 원본을 직접 변경할 수 있음</li>
                <li>원본의 값을 읽지 않고 그냥 덮어쓰는 거라면 반환이나 마찬가지</li>
            </div>
            <div class="post_subheading">(3) 동적 메모리 할당</div>
            <div class="post_text">
                <li>함수의 범위에 상관없이 한동안 사용하고자 하는 데이터가 다음과 같은 경우에 해당하면</li>
                <div class="ml-7">
                    <p>1. 그 데이터의 크기를 컴파일 도중에 알 수 없거나</p>
                    <p>2. 프로그램 실행수명보다 짧은 시간동안만 사용하려고 할 때</p>
                </div>
                <li>동적으로 할당된 메모리는 역시 연속된 메모리 덩어리</li>
                <li>따라서 포인터가 적합 ⇒ 배열과 비슷한 이유</li>
            </div>
            <div class="post_subheading">(4) 그 외...</div>
            <div class="post_text">
                <li>데이터 구조를 구현할 때</li>
                <p class="ml-7">⇒ 연결 리스트, 트리 등과 같은 데이터 구조</p>
                <li>임베디드 프로그래밍 등에서 하드웨어에 있는 메모리에 직접 접근해야할 때</li>
                <p class="ml-7">⇒ 예 : 어떤 하드웨어는 화면을 보여주려면 특정 메모리 위치에 이미지 데이터를 직접 복사해줘야 함</p>
            </div>
        </div>
        <div id="포인터배열">
            <div class="post_heading">포인터 배열</div>
            <div class="post_text">
                <li>포인터도 그냥 변수니 당연히 포인터를 저장하는 배열도 있음</li>
                <li>배열의 선언</li>
                <img src="{% static 'img/sourcecode/post7-67.png' %}" class="ml-7">
                <li>'배열의 배열'과 비슷한 개념</li>
                <p class="ml-7">⇒ 바깥 쪽 배열은 행, 안쪽 배열은 열</p>
                <p class="ml-7">⇒ 각 행마다 열의 길이가 달라질 수 있음</p>
            </div>
            <div class="post_subheading">포인터 배열 예시</div>
            <img src="{% static 'img/sourcecode/post7-68.png' %}" class="mb-6">
            <div class="post_subheading">합수의 포인터 배열 접근</div>
            <img src="{% static 'img/sourcecode/post7-69.png' %}">
            <div class="post_text">
                <li>함수에서 포인터 배열을 접근하려면 각 내부의 길이를 알려주는 size_t 배열이 필요</li>
            </div>
            <div class="post_subheading">2차원 배열 : 배열과 포인트가 같다면 2D 배열도 위와 같이 사용이 가능할까?</div>
            <img src="{% static 'img/sourcecode/post7-70.png' %}">
            <div class="post_text">
                <li>2차원 배열은 한 덩어리 메모리라 주소의 값이 저장된 곳이 없음</li>
                <li>올바른 방법</li>
                <p class="ml-7">⇒ 컴파일러가 매개변수가 2차원 배열이라는 것을 인지하며 matrix[1][ ] 할 때 몇개를 건너 뛰어야 하는지 알 수 있음</p>
                <img src="{% static 'img/sourcecode/post7-71.png' %}" class="ml-7 mb-2">
                <img src="{% static 'img/sourcecode/post7-72.png' %}" class="ml-7">
            </div>
            
        </div>
    </main>
{% endblock post_content %}