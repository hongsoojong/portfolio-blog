{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(3) C 언어의 기본 문법 2</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 07, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="a64ee036-e680-4436-8011-5e1e7da53cd3" class="page sans"><div class="page-body"><ul id="82a1c0a1-dce6-427a-818b-1dec7beb982e" class="bulleted-list"><li style="list-style-type:disc">C의 함수는 기본적으로 모두 전역(global)함수<p id="b070afad-0969-4ad9-977c-1467efa4d6dc" class="">⇒ 즉, C함수는 어디서든 호출할 수 있음! 물론 이걸 제한할 수 있는 키워드는 따로 존재함</p></li></ul><ul id="07e969b7-4305-4dca-8be7-2e918177af18" class="bulleted-list"><li style="list-style-type:disc">함수의 오버로딩 없음 ⇒ 따라서 함수를 다르게 만들어야 함<p id="db081e59-3abe-48aa-a3ea-56669c3a13bf" class="">⇒ <strong>오버로딩 </strong>: 함수의 이름은 같고 매가변수의 타입이나 수만 다른 경우</p></li></ul><h2 id="6584ab72-cc91-4333-859e-d204c436afbb" class="">함수</h2><ul id="a150daa9-56c5-4b05-b536-c707310dcc0c" class="bulleted-list"><li style="list-style-type:disc">일종의 작은 프로그램 단위</li></ul><ul id="f41c8784-3806-4202-ad29-81d5b2f2ff3f" class="bulleted-list"><li style="list-style-type:disc">지금까지 사용해온 <code>printf()</code>나 <code>scanf()</code>등도 C언어에서 미리 만들어 제공한 함수로, 메인 함수 &#x27;<code>main()</code>&#x27; 도 프로그램이 실행될 때 처음으로 실행하도록 약속된 함수를 말함</li></ul><ul id="e466738e-3465-46ac-b6f8-038a73407eae" class="bulleted-list"><li style="list-style-type:disc">이처럼 &#x27;함수&#x27;는 특정한 기능을 하는 코드들을 묶어 하나의 명령어처럼 사용 가능</li></ul><ul id="d4cefa3f-25fd-4f4a-ab03-92c4bbce1279" class="bulleted-list"><li style="list-style-type:disc">기본적으로 이미 만들어서 제공하는 <code>printf()</code> 같은 함수 이외에 새로운 함수를 만들 수도 있음</li></ul><h3 id="3a4c1ef5-d70d-42a4-8a9e-68e41bc666bd" class="">함수 선언(function declaration)</h3><ul id="78f81de2-eeed-4191-a232-1bc4b35ec593" class="bulleted-list"><li style="list-style-type:disc">함수의 구현체 없이 함수 원형(prototype)만 선언해 주는 것<p id="6e29f7fc-f5a7-4d23-92c0-cdafc393d392" class="">⇒ 함수의 원형은 다음 사항들을 명시<div class="indented"><p id="4aad1572-d2e0-4a1b-9b36-c31defed9a85" class="">1) 함수의 이름</p><p id="fdc8e0f9-585a-4abc-9b0c-bb490d8a9104" class="">2) 반환형</p><p id="215231ec-df3a-4b4e-9a4f-ccfeb2f5f5e0" class="">3) 매개변수들의 자료형</p></div></p></li></ul><h3 id="38cda400-a5ee-4c0f-8540-ba21512bb922" class="">함수 정의(function definition)</h3><ul id="a0571803-4d66-4b4a-b3f8-fa0bfa56e86c" class="bulleted-list"><li style="list-style-type:disc">실제로 함수를 구현해놓은 것</li></ul><ul id="48bd2207-e731-45b3-b79b-c1b179fc1207" class="bulleted-list"><li style="list-style-type:disc">함수 정의는 그 자체로 함수 선언이기도 함</li></ul><pre id="8391509f-38ae-45a1-8aa0-4836298f1fcc" class="code"><code>#include &lt;stdio.h&gt;

void foo(void)                           /* 함수 정의 (+ 선언) */
{
	printf(&quot;foo called&quot;);
}

int main(void)
{
	foo();
	getchar();
	return 0;
}</code></pre><ul id="53939c55-5984-485b-9ad0-0608ab5c87c7" class="bulleted-list"><li style="list-style-type:disc">함수를 사용하기 전에 그 함수를 선언 (혹은 헤더 파일에)</li></ul><ul id="6a53df07-6c5d-4987-8bc8-3b5cba4e5e1c" class="bulleted-list"><li style="list-style-type:disc"><strong>C 언어에서는 위에서 아래 방향으로 프로그램이 실행되고, 아래에서 사용할 것들은 반드시 위에서 선언이 되어야함</strong></li></ul><ul id="9ad60ab4-e91b-475e-9642-26c179328bb2" class="bulleted-list"><li style="list-style-type:disc">하지만 위에 많은 함수들을 선언하게 되면 보기 좋지 못하고, 메인 함수를 찾기 위해 스크롤바를 한참 내려야 할 수도 있음<p id="37be9e7a-324a-459b-b3f0-78244eb25010" class="">⇒ 전방 선언을 통해 함수를 메인 함수 밑으로 내릴 수 있음</p></li></ul><h3 id="09573bbe-a2ca-4e21-985e-4d71d75d67f0" class="">전방 선언</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="2ad78b5a-e321-41c2-a39b-bfc49af6bb98"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong> C 언어는 위에서 아래 방향으로 읽는다. 그러므로 main 함수가 실행되기 전에 함수가 정의되거나 선언이 되어야한다. 여기서 함수의 정의는 선언을 포함하므로 그 자체가 선언이 될 수 있다. 일반적으로 코드의 가독성을 위해 main 함수 뒤에 함수의 정의가 이루어지며, 전방선언을 통해 함수 작성이 이루어진다. 전방선언이 이루어지면 컴파일러는 함수의 이름, 반환형, 매개변수를 알 수 있으며, 실제로 어디로 가서 코드를 찾아야하는지 모르니 구멍으로 남겨둔다. 컴파일 다음 링크가 이루어질 때 실제 코드 위치를 찾아 그 구멍을 메워주는 방식으로 작동하게 된다.</strong></div></figure><pre id="4aa59749-03c0-4cba-aa40-2cda542da3d1" class="code"><code>#include &lt;stdio.h&gt;

void foo(void);                        /* 함수 선언 (전방 선언) */

int main(void)
{
	foo();
	getchar();
	return 0;
}

void foo(void)                          /* 함수 정의 */
{
	printf(&quot;foo called&quot;);
}</code></pre><ul id="b18385a1-68ec-424a-ae4f-a2b616d65d1c" class="bulleted-list"><li style="list-style-type:disc">함수를 사용하기 전에 그 함수를 선언 (혹은 헤더 파일에)</li></ul><ul id="0640425c-5899-4ac1-8247-abd92ac72ff2" class="bulleted-list"><li style="list-style-type:disc"><strong>전방선언의 작동원리</strong><p id="8587d59b-45fa-4243-b02c-cd6592cff304" class=""><strong>1) 컴파일러가 함수의 이름과 반환형 그리고 매개변수를 알 수 있음</strong></p><p id="ee49dd79-f482-4377-a8df-68b4e26c061b" class=""><strong>2) 실제 어디로 가서 코드를 찾아야하는지 모르니 구멍으로 남겨둠</strong></p><p id="5de4fbcb-3c63-47bc-a148-d504d5707232" class=""><strong>3) 컴파일의 다음 단계인 링크(link) 단계에서 실제 코드 위치를 찾아 그 구멍에 메워줌</strong></p></li></ul><h3 id="ab1a84b7-5aa9-49c6-af29-3f4870866dfe" class="">int main과 void main</h3><p id="1cabc4a3-3855-4a81-863a-5f11a0011e5f" class=""><strong>&lt; int를 반환하는 main이 표준 문법 ! &gt;</strong></p><ul id="86bc79af-29af-437e-a466-1e2250c3c8b6" class="bulleted-list"><li style="list-style-type:disc">C 언어 표준 안에서는 <code>void main</code>을 허용하지 않고 <code>int main</code>만 사용이 가능함</li></ul><ul id="82a2a96a-d915-4aab-a02e-09a736004270" class="bulleted-list"><li style="list-style-type:disc">main 함수가 반환하는 값은 해당 프로그램의 종료상태를 의미하는 값으로 사용되기 때문에 종료상태가 없다는 의미인 <code>void main</code>의 형식은 잘못된 형식임</li></ul><ul id="672ddf3e-60f6-40a8-96b4-d94fc42bb802" class="bulleted-list"><li style="list-style-type:disc">그렇다면 왜 컴파일러들이 오랜 기간 동안 잘못된 <code>void main</code>을 허용한 것인가 ? 이유는 매우 단순함 (컴파일러를 개발하는 입장에서 개발자가 main 함수의 반환값을 사용하지도 않으면서 return문을 적는 것이 불편할 수도 있다고 판단해서 <code>void main</code>이라는 표현을 추가적으로 제공 ⇒ 즉, 개발자 입장에서 코드를 적게 쓸 수 있도록 도와주기 위해서 <code>void main</code>이라는 문법을 제공한 것)</li></ul><ul id="d8d7769b-d2bf-4866-b606-fdedfc9e63d1" class="bulleted-list"><li style="list-style-type:disc">컴파일러 입장에서는 <code>void main</code> 함수를 컴파일할 때 내부적으로 <code>int main</code> 함수와 다르게 처리하는 것이 없음 ⇒ <code>void main</code>, <code>int main</code>은 동일하게 처리가 됨</li></ul><ul id="4d0c97e4-04b3-4cba-a7e5-c57c2cb2cd53" class="bulleted-list"><li style="list-style-type:disc">하지만 최근 컴파일러를 하나로 통합하려는 시도를 하고 있는 많은 컴파일러 회사들이 이 노력에 동참하고 있으며, 비표준화된 <code>void main</code> 함수 또한 사라지고 있는 추세로 앞으로 C 프로그래밍을 할 때 <code>void main</code>을 사용하면 오류가 나는 컴파일러는 늘어날 것임</li></ul><h2 id="7908a3d8-9444-4118-b71b-c88bfae1c215" class="">함수 매개변수/피연산자 평가순서</h2><h3 id="72a36362-e5b3-4d6b-a4e0-3c905de778cf" class="">함수 매개변수 평가순서</h3><pre id="5f28538a-036e-40dc-a4d4-53488cdd0e3b" class="code"><code>#include &lt;stdio.h&gt;

int add(int op1, int op2)
{
	printf(&quot;add()\n&quot;);
	return op1 + op2;
}

int substract(int op1, int op2)
{
	printf(&quot;substract()\n&quot;);
	return op1 - op2;
}

int main(void)
{
	int num1 = 128;
	int num2 = 256;

	printf(&quot;%d, %d\n&quot;, add(num1, num2), substract(num1, num2));

	return 0;
}

/*
경우 1 : 뺄셈 함수부터 호출
substract()
add()
384, -128
*/

/*
경우 2 : 덧셈 함수부터 호출
add()
substract()
384, -128
*/</code></pre><ul id="277da16c-a93e-441a-a422-47cdca8e3288" class="bulleted-list"><li style="list-style-type:disc">표준에 따르면, 함수 매개변수의 평가순서는 명시되지 않음 (<strong>unspecified</strong>)<p id="0060638e-83fd-4ba8-8e96-790918f3a140" class="">⇒ 즉, 컴파일러에 따라 평가 순서가 달라질 수 있음</p></li></ul><ul id="de7240d4-2d8c-473c-b7d1-3cdb693c1715" class="bulleted-list"><li style="list-style-type:disc">하지만 <code>printf()</code>가 실제로 실행되기 전에 <code>add()</code>와 <code>substract()</code>가 모두 호출된다는 것은 보장</li></ul><h3 id="d9a04b13-3a9d-4396-9026-7bbcf973a09e" class="">피연산자 평가순서</h3><pre id="044b2721-3060-4dae-8512-580de4f72f97" class="code"><code>size_t g_boss = 0;

/* 던전을 찾으면 1을 반환, 함수 내부에서 g_boss 변수 셋팅 */
int find_next_dungeon(void);

/* g_boss가 1이면 보스 몹도 같이 소환 */
int spawn_monster(void);

/* 또 다른 함수 내부 */
if (find_next_dungeon() + spawn_monster() == 2)
{
	/* 멋진 코드 : Game Start 문구 호출! */
}</code></pre><ul id="5faca5d7-d347-43f6-8089-8706c12ecf61" class="bulleted-list"><li style="list-style-type:disc">역시나 <code>find_next_dungeon()</code>이 먼저 호출된다는 보장이 없음 ⇒ 역시나 평가순서가 명시되지 않음</li></ul><ul id="4f0b441c-dabc-44f2-ac26-29ced3911877" class="bulleted-list"><li style="list-style-type:disc">한 줄에 있는 함수 호출 순서에 의존해서 코드를 작성하면 안됨</li></ul><ul id="675bfd46-a235-4e26-9263-a5f3c14d726b" class="bulleted-list"><li style="list-style-type:disc">해법 : 두 함수를 두줄에 따로 호출 할 것!!</li></ul><h3 id="c5e2e36c-0c5d-4237-a516-5fb99ae826ce" class="">Undefined behavior(결과가 정의되지 않음)</h3><pre id="0d802ca3-c9a0-4b09-a285-415440240af0" class="code"><code>#include &lt;stdio.h&gt;
float divide(int op1, int op2)
{
	printf(&quot;%d / %d = &quot;, op1, op2);
	return op1 / (float)op2;
}

int main(void)
{
	int num = 0;
	float result = divide(++num, ++num);      /* 어떤 인자가 먼저 평가될지 알 수 없음 */

	printf(&quot;%f\n&quot;, result);

	return 0;
}

/*
첫 번째 인자가 먼저 평가될 경우, 1 / 2 = 0.50000
두 번째 인자가 먼저 평가될 경우, 2 / 1 = 2.00000
동시에 평가될 경우, ?? / ?? = ??
*/</code></pre><ul id="34447b37-921b-4fac-bc3c-68f33f221813" class="bulleted-list"><li style="list-style-type:disc">기본적으로 한 줄에 동일한 변수를 여러 번 바꾸면 위험 ⇒ 함수 매개변수의 평가순서는 컴파일러마다 다를 수 있음<p id="298493cd-1479-4f6e-9906-766ae914f63d" class="">1) 한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 정의되지 않음</p><p id="944a5028-2b54-473b-963c-8fe80b00a08b" class="">2) 한 줄에서 같은 변수를 여러 번 수정하면 정의되지 않은 결과<div class="indented"><p id="7a99f96d-8985-4647-b0c6-9f2f73925f80" class=""><strong>unspecified </strong>: 위험하지는 않지만 컴파일러에 따라 결과가 다를 수 있음</p><p id="33b13937-958c-4e7f-8ff3-b91eeb5d2924" class=""><strong>undefined</strong>: 위험함! 무슨 일이 일어날지 모름</p><pre id="ac54e30b-b101-40f0-bc93-2a6d793a2830" class="code"><code>/* 1 */
add(++i, ++i);                     /* 어떤 일이 일어날 지 정의되지 않음 */
add(i = -1, i = -1);               /* 어떤 일이 일어날 지 정의되지 않음 */
add(i, ++i);                       /* 어떤 일이 일어날 지 정의되지 않음 */

/* 2 */
i = ++i, i++                       /* 어떤 일이 일어날 지 정의되지 않음 */
i = i++ + 1;                       /* 어떤 일이 일어날 지 정의되지 않음 */
array[i] = i++                     /* 어떤 일이 일어날 지 정의되지 않음 */</code></pre></div></p></li></ul><h2 id="c8207683-9996-47c5-9f57-2e82338864e1" class="">연산자 우선순위와 평가순서</h2><pre id="2db0a7cc-13ab-4ba8-b51d-bf8a1c581b07" class="code"><code>/* add(), substract(), divide() 함수 생략 */

int main(void)
{
	int num1 = 10;
	int num2 = 20;

	int result =  add(num1, num2) + substract(num1, num2) * divide(num1, num2)
	printf(&quot;result: %d\n&quot;, result);

	return 0;
}</code></pre><ul id="923897ba-1936-4956-8a28-d1316437106f" class="bulleted-list"><li style="list-style-type:disc">연산자 우선순위와 평가순위는 서로 아무런 연관이 없음 ⇒ <code>add()</code>, <code>substract()</code>, <code>divide()</code>의 평가순서는 알 수 없음</li></ul><ul id="97c30039-62dd-49fb-a7fa-5e7063572d24" class="bulleted-list"><li style="list-style-type:disc">함수 호출(평가)의 순서는 알 수 없으나, 최종적으로 연산이 이루어질땐 곱셈이 먼저 이루어짐</li></ul><h3 id="563e7308-f911-4fbd-a1f5-3fa2150a2ff2" class="">&amp;&amp;와 ||는 평가순서를 강제하는 연산자</h3><pre id="e9a57d70-0ee9-4ed1-81e4-8c180793b8d7" class="code"><code>int i = 0;
int j = 0;
int k = 0;

if (++i || ++j &amp;&amp; ++k)
{
	printf(&quot;true!\n&quot;);
}

printf (&quot;%d, %d, %d\n&quot;, i, j, k);

/*
연산자 우선순위와 평가순위는 전혀 관련이 없음
&amp;&amp;은 ||보다 우선순위는 높지만, ||는 sequence point로 왼쪽부터 먼저 평가되어야함
++i는 1(참)으로 ||의 오른쪽 피연산자를 평가할 필요도 없이 참이 됨
이를 short circuit이라고 함
정답 : true!, 1, 0, 0
*/

int i = 0;
int j = 0;
int k = 0;

if (i++ || ++j &amp;&amp; ++k)
{
	printf(&quot;true!\n&quot;);
}

printf (&quot;%d, %d, %d\n&quot;, i, j, k);

/*
후위 연산자의 경우 i로 먼저 평가된 후 실행이 됨 : 0(거짓) &gt; 1
|| 연산자의 왼쪽 피연산자 평가결과는 거짓이므로 오른쪽 피연산자 평가 및 실행
정답 : true!, 1, 1, 1
*/</code></pre><ul id="c40e3d77-11e0-48d2-a26b-d55fae699f79" class="bulleted-list"><li style="list-style-type:disc">논리연산자 <code>&amp;&amp;</code>와 <code>||</code>의 경우 왼쪽 피연산자를 먼저 실행함<p id="d522ec81-e8c0-49fa-bb6c-f74a02981ee8" class="">⇒ 왼쪽 피연산자의 평가만으로 오른쪽 피연산자를 평가 안 할 수도 있음</p><pre id="13113f7b-1e23-48a5-bbaa-8442570f77de" class="code"><code>hp++ || mp++           /* 왼쪽 피연산자가 참이면 오른쪽 피연산자를 평가 안함 */
exp++ &amp;&amp; atk++         /* 왼쪽 피연산자가 거짓이면 오른쪽 피연산자를 평가 안함 */</code></pre></li></ul><h2 id="8e2205a1-ceab-4981-abaf-48f47f8cba68" class="">평가순위 정리</h2><ul id="73ed7a7a-99bc-4aa4-b1a0-b7c354ebaa23" class="bulleted-list"><li style="list-style-type:disc">한 줄에 있는 피연산자들은 기본적으로 평가순서가 보장 안됨</li></ul><ul id="470e27fc-0077-49ac-b31d-7076fa7ed41b" class="bulleted-list"><li style="list-style-type:disc"><code>&amp;&amp;</code>와 <code>||</code> 정도만 됨 (short circuit, sequence point )</li></ul><ul id="d55c85eb-8f80-44b3-bc14-67e1d7e6b389" class="bulleted-list"><li style="list-style-type:disc">추가적으로 삼항(<code>?:</code>)도 평가순서가 보장됨 ⇒ <code>if/else</code>를 줄여 써 놓은 것이라고 생각하면 됨</li></ul><ul id="9104488b-a753-4621-95e8-77a6ef89aedd" class="bulleted-list"><li style="list-style-type:disc">함수를 실제 실행하기 전에 모든 매개변수와 ;은 우선 평가 됨 ⇒ 이건 너무나도 당연한 내용!</li></ul><h2 id="12bce779-cff0-4ddb-883a-5ee6e90d27d7" class="">범위(scope) - 블록 범위 / 파일 범위 / 함수 범위 / 함수 선언 범위</h2><p id="4f90b13a-d9ce-4156-a835-0c3bb24376f4" class="">총 4가지의 범위로 분류할 수 있음<div class="indented"><p id="88d835eb-5233-45c7-8255-fc6943f4ff29" class="">1. 블록 범위</p><p id="076f5877-408c-400e-b602-550bfefe109f" class="">2. 파일 범위</p><p id="949d2b77-e141-4953-a1c8-8c90e3c4df0e" class="">3. 함수 범위</p><p id="72ff01a4-28d5-4092-a7ad-6e324f16b58e" class="">4. 함수 선언 범위</p></div></p><h3 id="a5d5dfe9-4b16-47d7-be26-f3da31c90826" class="">블록 범위</h3><ul id="ebfe6aa4-2a01-48fb-a493-cf1374fd1055" class="bulleted-list"><li style="list-style-type:disc">중괄호(<code>{}</code>) 안에 선언한 것들은 그 블록 안에서만 사용 가능</li></ul><ul id="99a5f3ea-95d2-4651-b7a5-b7a8201789e2" class="bulleted-list"><li style="list-style-type:disc">블록 안에 또다른 블록을 넣을 수도 있음 ⇒ 그러면 안쪽 블록은 바깥 블록에 접근 가능, 그 반대는 안됨</li></ul><h3 id="8ca58195-62f1-4680-8472-d9db335f64f5" class="">블록 범위와 변수 선언 위치</h3><pre id="7ae6adb0-e7f7-4f00-b4da-3ca6d476fda0" class="code"><code>/* 컴파일 오류 나는 코드 */

int main(void)
{
	int num1 = 10;

	printf(&quot;num: %d\n&quot;, num1);

	int num2 = 100;                                /* 컴파일 오류 */
	int result = num1 + num2;                      /* 컴파일 오류 */

	printf(&quot;result: %d\n&quot;, result);

	return 0;
}

/* 컴파일 되는 코드 */

int main(void)
{
	int num1 = 10;

	printf(&quot;num: %d\n&quot;, num1);
	{
		int num2 = 100;
		int result = num1 + num2;
	
		printf(&quot;result: %d\n&quot;, result);
	}
	
	/* num2, result 접근 못함*/

	return 0;
}</code></pre><ul id="1bb13664-cb70-4d59-a67c-fac34efd1d51" class="bulleted-list"><li style="list-style-type:disc"><strong>함수 중간에 블록을 열고 변수 선언 가능</strong></li></ul><ul id="b68ae6db-d711-46f6-84d0-5990a7ccd498" class="bulleted-list"><li style="list-style-type:disc"><strong>함수 시작 지점에서 모든 변수를 선언하면 실수할 여지가 없음</strong><p id="ab4c5ade-d905-4eac-91c2-36c7c997bf36" class="">⇒ 하지만 정확하게 어느 지점에서 사용하는 변수인지 파악 불가능<div class="indented"><p id="a35f9fa1-e1ca-49e4-82cb-984dfd1ee74e" class="">중간에 그 값이 바뀔 수도 있음</p></div></p></li></ul><ul id="352a3667-5c2e-4df9-b9a8-79a10883fd3d" class="bulleted-list"><li style="list-style-type:disc">블록을 이용해서 함수 중간에 선언하는 것도 하나의 방법임</li></ul><h3 id="8c101415-9952-4790-a337-68f7bf9c254e" class="">파일 범위</h3><pre id="d9466232-04c6-440e-af24-743502af9ee6" class="code"><code>#include &lt;stdio.h&gt;

static int s_num = 1024;      /* 파일 범위 */

int add(int op1, int op2);

int main(void)
{
	s_num = add(10, 30);

	return 0;
}</code></pre><ul id="de431f55-6c6a-416c-bef8-da3d43884e27" class="bulleted-list"><li style="list-style-type:disc"><strong>어떤 블록이나 매개변수 목록에도 안 속하고, 파일 안에 있는 것 (translation unit)</strong></li></ul><ul id="c716071d-69da-4267-b684-d0ffa8b00fb6" class="bulleted-list"><li style="list-style-type:disc">파일 범위에 있는 변수</li></ul><ul id="8074b0e1-7808-47cb-8b32-3e1a8783e01a" class="bulleted-list"><li style="list-style-type:disc">다른 소스 파일에서 링크 가능</li></ul><ul id="11fefa04-0807-45e8-9405-74d34c5f65ca" class="bulleted-list"><li style="list-style-type:disc">프로그램 실행동안 공간을 차지<p id="9f48144f-27ac-49e4-9680-d69609bb9c3d" class="">⇒ 즉, 스택 메모리에 들어가는 것이 아니라 데이터 섹션에 들어감</p></li></ul><ul id="d11633b4-adcb-4bcb-879d-a8575c084ca7" class="bulleted-list"><li style="list-style-type:disc">이게 바로 <strong>전역변수</strong>!</li></ul><h3 id="e6e2b32c-b41c-4731-b725-764210b48853" class="">함수 범위</h3><ul id="3c4fc217-3f25-4b59-8c1d-f4bc78b7039f" class="bulleted-list"><li style="list-style-type:disc">유일한 예 : 레이블(label)</li></ul><ul id="7811784c-4ad4-4fa9-a0a9-674e96556b49" class="bulleted-list"><li style="list-style-type:disc">goto문</li></ul><ul id="504abe6f-8465-4b81-a389-02096b0f45fd" class="bulleted-list"><li style="list-style-type:disc">함수 안에서 선언된 레이블은 함수 어디에서라도 접근 가능<p id="4ad48f2b-4105-416e-b74b-9ce3fc52b607" class="">⇒ 다른 범위들은 위에서 이미 선언된 것만 접근이 가능했음</p></li></ul><h3 id="f4115e40-3433-4e17-a159-84f1d28d1038" class="">함수 선언 범위</h3><pre id="e10a30f9-a6cd-443b-9076-fb0a3ac1e445" class="code"><code>void do_something(
	double value,                             /* 함수 선언 범위 */
	char array[10 * sizeof(value)]            /* value는 첫 번째 매개변수 */
);</code></pre><ul id="8f82e09a-616d-45da-853a-bedd7dd5519d" class="bulleted-list"><li style="list-style-type:disc">함수 선언의 매개변수 목록에 있는 것은 그 목록 안에서 접근 가능</li></ul><ul id="aaf1d17b-1fa2-4550-a776-f352c5f16dd5" class="bulleted-list"><li style="list-style-type:disc">많이 쓸 일은 없음</li></ul><h2 id="a7e67e97-e692-4fa1-9e80-e2bc5451edd2" class="">const</h2><pre id="e398c4ad-0f49-43c4-a475-2ecbb323bc03" class="code"><code>void update_dimension(int w, int h, int data[])
{
	int i = 0;
	const int area = w * h;

	/* 코드 1000줄 */

	area = area +1;                   /* 컴파일 오류 : const 값 변경 불가능, 변경으로 인한 코드 오류 막을 수 있음 */

	/* 코드 1000줄 */
	
	for (i = 0; i &lt; area; ++i)
	{
		data[i] = 1;
	}
}</code></pre><ul id="39949084-c208-4dcf-89e1-a3593c6f2957" class="bulleted-list"><li style="list-style-type:disc">이름 달린 상수를 만들어주기 좋음 ⇒ 개발자의 실수를 막아줄 수 있는 KEY</li></ul><ul id="209e97ce-71db-4913-8ecc-07e0333e01d7" class="bulleted-list"><li style="list-style-type:disc">기본적으로 모든 변수에 <code>const</code>를 붙이는 것이 좋음</li></ul><ul id="d9f315c0-3a29-427a-95c4-14a528ff6632" class="bulleted-list"><li style="list-style-type:disc">정말 값 변경이 필요한 변수에만 <code>const</code>를 생략</li></ul><h2 id="529fdf16-a6e6-44a0-914a-5e324805fb5e" class="">goto문</h2><ul id="a06c5970-5da6-4567-b397-6abbca19bed9" class="bulleted-list"><li style="list-style-type:disc">C는 위에서 아래로 순차적으로 코드를 실행함</li></ul><ul id="3de47a16-1eb2-497b-ad9d-f2d56d176be4" class="bulleted-list"><li style="list-style-type:disc"><strong>goto를 쓰면 순서를 어기고 다음에 실행할 코드를 마음대로 지정 가능</strong><p id="e977de5c-65f8-4c7c-b2a1-ddd79befeb55" class=""><strong>⇒ 같은 함수 내에 있는 label로 점프함</strong></p></li></ul><h3 id="d16b541b-570a-4096-b4e7-19bcac103a41" class="">goto문과 while문</h3><pre id="5a6207f7-56d1-4475-89e2-0420451c20c5" class="code"><code>void do_work(void)
{
	infinity:
		printf(&quot;work time\n&quot;)

		goto infinity;                      /* 이와 같은 goto문은 좋지 않음 */
}

/* 위/아래 같은 코드 */

void do_work(void)
{
	while (1) {
		printf(&quot;work time\n&quot;_
}</code></pre><h3 id="cb795ee7-6164-4a74-bc77-107c006f2475" class="">goto문과 do-while문</h3><pre id="01260da4-81f4-4c3d-800a-937aa783307a" class="code"><code>int main(void)
{
	int counter = 3;

	do {
		printf(&quot;play time\n&quot;);
	} while (counter-- &gt; 0);
}

/* 위 아래 둘은 같은 코드 : 같은 동작 */

int main(void)
{
	counter = 3;
loop:
	printf(&quot;play time\n&quot;);

	if (counter-- &gt; 0) {
		goto loop;
	}
}</code></pre><h3 id="c560c415-a205-4008-afa4-ccb4ed0992d2" class="">반복문은 결국 goto를 사용하는 코드</h3><ul id="85414ac6-f085-403d-bbd0-78107d8c275c" class="bulleted-list"><li style="list-style-type:disc">어셈블리어는 반복문이란게 없음</li></ul><ul id="011cc1ef-a094-42ef-9cab-497005797b60" class="bulleted-list"><li style="list-style-type:disc">원래 어셈블리어 프로그래밍을 하다가 C로 넘어온거라 초기엔 goto문을 많이 썼음</li></ul><ul id="0311eb3c-792f-4cc0-89f2-1d2887e0dac4" class="bulleted-list"><li style="list-style-type:disc"><strong>당연히 이보다 안전한 방법이 보통의 반복문을 쓰는 것</strong><p id="68b1929c-aa45-405a-91cb-fb2ef80c197c" class=""><strong>⇒ 이건 명백한 사실이라 누구나 동의, 따라서 goto를 자주 쓰지는 않음</strong></p></li></ul><h3 id="b1ed054e-0728-4743-ac18-27f0c75e2887" class="">goto는 정말로 악마인가?</h3><ul id="8519c7bb-3c23-421a-8f0e-af518ddd02c1" class="bulleted-list"><li style="list-style-type:disc">물론..</li></ul><ul id="cf81c9d4-7caa-47df-8c39-924949ddd42a" class="bulleted-list"><li style="list-style-type:disc">goto를 난잡하게 사용하게 되면 코드가 이리 뛰고 저리 뛰고 꼬이게 됨</li></ul><ul id="4bac24df-c4ab-46d0-a30d-1374f1154c15" class="bulleted-list"><li style="list-style-type:disc">이러한 코드를 스파게티 코드라고 부름 (아주 꼬임)</li></ul><ul id="d6c4f3de-56ff-43b1-a0f6-9bcfd5ac0848" class="bulleted-list"><li style="list-style-type:disc">이로 인해 코드를 쓰고 읽는데 실수가 발생하게 됨</li></ul><h3 id="771b8292-198a-40bf-9a12-eeb32662d9d0" class="">허나 goto가 늘 악마인 것은 아님!</h3><p id="848f78a9-50c3-444c-89de-a38d56906017" class=""><strong>&lt; 경우 1 &gt;</strong></p><p id="06d354f3-7ec2-49b4-bf7f-f40ca607718d" class="">goto없이 안쪽 for문에서 탈출하려면 쓸데없이 if문을 여러 개 써야함</p><p id="e701c0a7-1df7-4694-996a-eff300e4b22e" class="">[ goto를 안 쓰는 3중 for문 ]</p><pre id="6ee4b341-961d-4093-85c7-1702f2d3647b" class="code"><code>exit = 0;
for (i = 0; i &lt; DEPTH &amp;&amp; !exit; ++i) {
	for (j = 0; j &gt; HEIGHT; ++j) {
		for (k = 0; k &lt; WIDTH; ++k) {
			if (data[i][j][k] == 1) {
				printf(&quot;%d&quot;, data[i][j][k]);
			}
			else {
				exit = 1;
				break;
			}
		}
		if (exit) {
			break;
		}
	}
}

/* 반복문 탈출 후 로직 코드 */</code></pre><p id="7001a8a2-3c49-4116-a122-1c218e41e44c" class="">[ goto를 쓰는 3중 for문 ]</p><pre id="c54e3d34-2692-4618-b6fd-841f2f452ab3" class="code"><code>for (i = 0; i &lt; DEPTH &amp;&amp; !exit; ++i) {
	for (j = 0; j &gt; HEIGHT; ++j) {
		for (k = 0; k &lt; WIDTH; ++k) {
			if (data[i][j][k] == 1) {
				printf(&quot;%d&quot;, data[i][j][k]);
			}
			else {
				goto loop_exit;
			}
		}
	}
}

loop_exit:
	/* 반복문 탈출 후 로직 코드 */</code></pre><p id="daa33a43-d20d-4e2a-8d5f-2c929c8ff743" class=""><strong>&lt; 경우 2 &gt;</strong></p><pre id="9d33c146-a86d-4e18-b4da-999052c9e59b" class="code"><code>if (id &lt; 0) {
	fprintf(stderr, &quot;invalid id %d&quot;, id);
	pass = 0;
}
if (pass == 1 &amp;&amp; amount &lt; 10000) {
	fprintf(stderr, &quot;insufficient amount %d&quot;, amount);
	pass = 0;
}
if (pass == 1 &amp;&amp; /* 어쩌고 */) {
	fprintf(stderr, &quot;여러 메세지 출력&quot;);
	pass = 0;
}
if (pass == 1 &amp;&amp; /* 저쩌고 */) {
	fprintf(stderr, &quot;여러 메세지 출력&quot;);
	pass = 0;
}
if (pass == 0) {
	log_error(error_code);
	rollback_transaction();
	/* 기타 공통 오류처리 코드 100줄 생략 */
	return 1;
}

/* 실제 로직 코드 */

return 0;</code></pre><ul id="ae589a2d-e51b-435c-8e88-b60659413d2b" class="bulleted-list"><li style="list-style-type:disc">goto없이 쓰려면 bool 변수를 하나 만들어서 계속 검사를 진행해야함</li></ul><pre id="8cc35ca9-0f4c-46a5-9fcc-29701448720e" class="code"><code>if (id &lt; 0) {
	fprintf(stderr, &quot;invalid id %d&quot;, id);
	log_error(1);
	rollback_transaction();
	return 1; /* early exit */
}
if (pass == 1 &amp;&amp; amount &lt; 10000) {
	fprintf(stderr, &quot;insufficient amount %d&quot;, amount);
	log_error(1);
	rollback_transaction();
	return 1; /* early exit */
}
if (pass == 1 &amp;&amp; /* 어쩌고 */) {
	fprintf(stderr, &quot;여러 메세지 출력&quot;);
	log_error(1);
	rollback_transaction();
	return 1; /* early exit */
}
if (pass == 1 &amp;&amp; /* 저쩌고 */) {
	fprintf(stderr, &quot;여러 메세지 출력&quot;);
	log_error(1);
	rollback_transaction();
	return 1; /* early exit */
}

/* 실제 로직 코드 */

return 0;</code></pre><ul id="fda0a30e-e97c-452e-909f-2d9410bcfd8e" class="bulleted-list"><li style="list-style-type:disc">물른 early exit을 해도 됨 ⇒ 하지만 오류를 처리하는 코드들이 if문 안에 반복되어 사용</li></ul><ul id="a2f4b806-ba7c-491e-9972-0c18c4b67736" class="bulleted-list"><li style="list-style-type:disc">오류를 처리하는 코드를 함수로 만들어됨 ⇒ 하지만 한 군데서만 쓰는 코드를 함수로 만드는 것은 유지/보수 문제를 유발하기도 함</li></ul><pre id="17c15d3c-a908-4f17-9e50-2837911dc496" class="code"><code>if (id &lt; 0) {
	fprintf(stderr, &quot;invalid id %d&quot;, id);
	error_code = 1;
	goto error;
}
if (pass == 1 &amp;&amp; amount &lt; 10000) {
	fprintf(stderr, &quot;insufficient amount %d&quot;, amount);
	error_code = 1;
	goto error;
}
if (pass == 1 &amp;&amp; /* 어쩌고 */) {
	fprintf(stderr, &quot;여러 메세지 출력&quot;);
	error_code = 1;
	goto error;
}
if (pass == 1 &amp;&amp; /* 저쩌고 */) {
	fprintf(stderr, &quot;여러 메세지 출력&quot;);
	error_code = 1;
	goto error;
}

/* 실제 로직 코드 */

return 0;

error:
	log_error(error_code);
	rollback_transaction();

	/* 기타 공통 오류처리 코드 100줄 생략 */

	return error_code;</code></pre><ul id="9f7033ab-44b1-4276-aa0f-de766d8a938a" class="bulleted-list"><li style="list-style-type:disc">goto를 쓰면 해결됨</li></ul><p id="aafed360-9656-4655-bca2-c02fde542f26" class=""><strong>&lt; 경우 3 &gt;</strong></p><p id="f1beafa0-9f1a-4dcf-8937-8617f43f3257" class="">로버트 러브(Robert Love)가 리눅스 커널 관련 토론에서 사랑을 담아 댓글로 남긴 goto 활용법</p><pre id="548a9d55-98e5-4196-aa12-6de6d9950bf1" class="code"><code>	do A
	if (error)
		goto out_a;
	do B
	if (error)
		goto out_b;
	do C
	if (error)
		goto out_c;
	goto out;
out c:
	undo C
out_b:
	undo B
out a;
	undo A
out:
	return ret;</code></pre><ul id="91542b07-4d6e-403e-84e1-6bde202f7f70" class="bulleted-list"><li style="list-style-type:disc">중간에 에러가 나면 이미 수행한 작업을 되돌림</li></ul><ul id="eb235392-217f-4044-93ae-438cf81ed774" class="bulleted-list"><li style="list-style-type:disc">A만 수행했다면 A만 되돌리고, A &gt; B를 수행했다면 B &gt; A 순으로 되돌림</li></ul><h3 id="1c4468f7-7bc9-458e-843d-6e36fe18af73" class="">goto문의 BEST PRACTICES</h3><ul id="20a40c37-c773-4802-a886-aa4619a88d4b" class="bulleted-list"><li style="list-style-type:disc">goto문은 언제나 전방(아래쪽)으로만 점프할 것<p id="7af7b3cb-94ee-4190-857a-0cc09f0b515d" class="">⇒ 후방(위)으로만 점프하면 스파게티처럼 코드가 꼬이기 쉬움</p></li></ul><ul id="e6aa9205-84a3-4434-a4d0-5352888e5b69" class="bulleted-list"><li style="list-style-type:disc">내포된(nested) 루프에서 빠져나올 때는 자유로이 쓸 것</li></ul><ul id="2812a934-41c5-488a-87ef-75da17ad7373" class="bulleted-list"><li style="list-style-type:disc">한 함수 안에 있는 여러 개의 조건문이 공통된 코드로 실행해야할 때도 써도 됨<p id="6fc85943-b350-46f0-9214-33d4e257cfcd" class="">⇒ 예 : 함수 마지막에 성공 / 오류 조건 처리</p></li></ul><h2 id="07ca3f64-34b4-44a8-9675-425f94479023" class="">배열</h2><pre id="a78de22f-c619-4f27-a80f-51b76afbae36" class="code"><code>/* C# */
int[] nums = new int[5]
float[] GPAs = new float[] { 3.1f, 2.2f, -13.0f };

/* C */
int nums[5];
float GPAs[3] = { 3.1f, 2.2f, -13.0f };

/* C 배열 예시 */
int nums[5] = { 1, 2, 3, 4, 5 };
int i;
int sum;

for (i = 0; i &lt; 5; ++i) {
	num[i] += i * 2;
}

sum = 0;
for (i = 0; i &lt; 5; ++i) {
	sum += nums[i];
}</code></pre><ul id="62e235b8-a6c2-4549-86d4-3b9274ee8e8e" class="bulleted-list"><li style="list-style-type:disc">C#과 달리 new를 반드시 사용할 필요가 없음</li></ul><h2 id="dfe6ea71-e75c-4af5-a2be-6d85ad743194" class="">스택 메모리</h2><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="28540531-bce7-4970-ba21-72169b3db42f"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>C는 스택 메모리 덕분에 값형으로 배열을 작성할 수 있다. 각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간으로, 그 크기는 프로그램 빌드시,  위치는 실행시 결정이 된다.  함수가 호출될 떄마다 그 함수에서 필요한 공간을 스택에 뗴어줬다가 그 함수가 반환하면 그냥 지워버리는 개념으로 동작한다. 스택 메모리를 빌리고 반환할 때는 언제나 빈 공간없이 차곡차곡 쌓여 스택 메모리라 불린다.</strong></div></figure><ul id="e4f0085c-cf47-40dd-9f60-9c2ef2ac7403" class="bulleted-list"><li style="list-style-type:disc">C는 스택 메모리 덕분에 값형으로도 배열을 만들 수 있음</li></ul><ul id="51531491-b8df-484f-b63f-c2fb06c106e1" class="bulleted-list"><li style="list-style-type:disc"><strong>우선 자료구조인 스택이랑 헷갈리지 말 것 ⇒ 둘 다 작동방법이 동일해서(LIFO; last in first out) 스택이란 이름을 쓸 뿐</strong></li></ul><ul id="1105d69b-5160-4a6e-9f89-eddecbfaab8c" class="bulleted-list"><li style="list-style-type:disc">각 함수에서 사용하는 지역 변수 등을 임시적으로 저장하는 공간</li></ul><ul id="bbcecfaa-c002-4320-acb3-399f381baf92" class="bulleted-list"><li style="list-style-type:disc">스택 메모리의 크기는 프로그램 빌드 시에 결정됨</li></ul><ul id="33506922-fe60-4793-9056-a6e091d1e6f5" class="bulleted-list"><li style="list-style-type:disc">스택 메모리의 위치는 실행 시에 결정 됨</li></ul><ul id="addbc5bb-e6ce-4c87-a34d-a989d20f247a" class="bulleted-list"><li style="list-style-type:disc"><strong>함수가 호출될 때마다 그 함수에서 필요한 공간을 스택에서 떼어줬다가 그 함수가 반환하면 그냥 지워버리는 개념 (실제 지우진 않음)</strong></li></ul><h3 id="1467eb8f-d052-4fb7-9159-e09f8bdb2c9e" class="">기본 자료형 변수는 스택 메모리를 차지!</h3><ul id="e859e589-8847-43ff-80e1-28308d8670b3" class="bulleted-list"><li style="list-style-type:disc">여태까지 모든 기본형 변수(<code>char</code>, <code>int</code>, <code>float</code>)를 <code>new</code>없이 사용할 수 있었던 이유가 바로 스택 메모리에 할당됬기 때문</li></ul><ul id="4d2d6fac-fd24-4115-803e-8088f4b79d71" class="bulleted-list"><li style="list-style-type:disc">기본 자료형을 함수 매개변수로 전달하면 스택에 복사본을 만듦 ⇒ 이것이 바로 값형</li></ul><ul id="b0284f2d-7edc-4146-9b6f-c2cde5b5d7f3" class="bulleted-list"><li style="list-style-type:disc">스택 메모리를 빌리고 반환할 때마다 언제나 빈 공간 없이 차곡차곡 쌓여있음</li></ul><ul id="8d5726b5-b16a-4489-bd4f-fe82e28aad15" class="bulleted-list"><li style="list-style-type:disc">new로 만든 데이터는 힙(heap) 메모리에 할당됨 ⇒ 이 경우 메모리에 구멍이 뚫릴 수 있음</li></ul><h3 id="181ce862-cc0b-4a92-95cb-80c20ff467d8" class="">배열의 요소 개수를 구하는 방법</h3><pre id="4108b45a-61a3-4976-b66a-31d5ef3c4684" class="code"><code>/* 방법 1 */
const size_t num_vals = sizeof(values) / sizeof(values[0]);

/* 방법 2 */
#define ARRAY_LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))     /* 함수 밖에서 */
const size_t num_vals = ARRAY_LENGTH(values);                /* 매크로 함수 사용 */</code></pre><h3 id="fcdb3f2c-b936-4b60-8fdb-807f53c72b50" class="">sizeof(매개변수)와 배열의 총 바이트 수</h3><pre id="e65b5a50-ff78-494f-adf4-60a8e3c3faae" class="code"><code>int do_something(int num, int data[])

int main(void)
{
	int score;              /* 10 */
	int values[3];          /* { 2, 3, 4 } */
}</code></pre><ul id="8d6b2f0b-5c05-4f81-b3d9-6058c0dcd8cb" class="bulleted-list"><li style="list-style-type:disc"><code>sizeof()</code>가 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면<p id="72387638-cfc9-4e01-b57a-97a62e399a75" class="">1) 그 배열의 모든 요소가 스택에 다 복사되어 전달되어야 함</p><p id="ccabab79-d98a-4a2b-b48a-28b3f57e5412" class="">2) 그리고 호출되는 모든 함수는 스택에 복사된 모든 요소의 크기를 정확히 알아야함</p></li></ul><h3 id="b1d709d6-0d1a-4b6f-b599-8375274e7d2c" class="">함수의 스택 메모리 사용량은 고정</h3><ul id="6a00d527-73a6-4681-b013-cd4be369c8df" class="bulleted-list"><li style="list-style-type:disc">함수는 호출자가 누구든 간에 딱 정해진 수와 크기의 매개변수가 들어온다는 가정으로 동작</li></ul><ul id="e373c28d-be0c-4b62-9788-0f33cc662d3e" class="bulleted-list"><li style="list-style-type:disc">함수가 먼저 결정되고, 호출자는 그 함수를 호출할 뿐</li></ul><h3 id="87fe2a49-0ce4-4e34-be76-55243e0a8b16" class="">sizeof(매개변수)가 4를 반환한 이유는?</h3><pre id="780dac3c-e54e-411e-bbeb-487036672195" class="code"><code>int do_something(int data[]);

int main(void)
{
	int values[3];
	do_something(value);             /* { 2, 3, 4 } */
}</code></pre><ul id="2c8310df-00d4-4da6-84d8-af825e448b8d" class="bulleted-list"><li style="list-style-type:disc">배열을 매개변수로 전달할 때는 실제 모든 요소를 스택에 넣진 않음</li></ul><ul id="e4ba3495-d8de-4f05-8ef9-94fa9e442c4c" class="bulleted-list"><li style="list-style-type:disc">그 대신 <strong>그 배열의 시작 위치(주소)를 스택에 넣어줌</strong></li></ul><ul id="fcb032dc-2918-4794-9cc3-599df408bb18" class="bulleted-list"><li style="list-style-type:disc">이 주소의 크기 = 포인터 데이터형의 크기</li></ul><ul id="3b796c83-042f-4bb9-a55e-a1eeee58a5ee" class="bulleted-list"><li style="list-style-type:disc">32비트 플랫폼에서는 4바이트, 64비트 플랫폼에서는 8바이트<p id="0dae8977-a399-49de-a1c5-9a1d4c87cc39" class="">그래서 <code>sizeof()</code>를 하면 4바이트가 나옴</p></li></ul><h3 id="ff4766bc-17d7-47a2-831b-9e60c3faf62f" class="">길이가 명시된 매개변수 배열</h3><pre id="044052c0-c0a8-48b8-a9d7-a2fcffd765ae" class="code"><code>void process(int num[5]) {
	size_t i;
	for (i = 0; i &lt; 5; ++i) {
		nums[i] *= 2;
	}
}</code></pre><ul id="c75e44a9-02ee-4664-b987-524a0e203d6b" class="bulleted-list"><li style="list-style-type:disc">위와 같은 코드는 길이가 5인 배열을 넣은 것이 아닌가?<p id="f8e238f1-c686-4dae-bb0d-bd5520c70e2f" class="">⇒ 이는 단순히 프로그래머가 읽기 편하기 위해 [5]를 써준 것<div class="indented"><p id="86312e21-91c1-4657-b6ec-75f2ca070520" class="">컴파일을 진행하면 <code>void process(int nums[])</code>와 동일</p></div></p></li></ul><ul id="3fff382e-6fb2-41de-80eb-92b2d6fabc97" class="bulleted-list"><li style="list-style-type:disc">원본 배열의 변화 ⇒ 위 코드는 복사본이 아니라 원본을 바꿈</li></ul><ul id="36acb0c3-5c5a-4037-9975-750b76d9a83a" class="bulleted-list"><li style="list-style-type:disc">어떤 사람들은 이것을 원본을 바꾸기 때문에 &#x27;참조에 의한 호출&#x27;이라 함</li></ul><ul id="a44f7631-9f9e-4182-9d3c-4f476641cb2a" class="bulleted-list"><li style="list-style-type:disc">어떤 사람들은 이것을 위치를 바꾸기 때문에 &#x27;값에 의한 호출&#x27;이라 함</li></ul><ul id="837bbffd-3c00-4b82-bb21-4c557e0654f0" class="bulleted-list"><li style="list-style-type:disc">어떤 사람들은 이것을 C는 참조에 의한 호출이 없고 그냥 주소를 전달하는 방법을 통해 &#x27;참조에 의한 호출을 시뮬레이션 하는 방법&#x27;이라고도 말함</li></ul><ul id="8958891e-f0d3-45aa-836b-b4b896eaba45" class="bulleted-list"><li style="list-style-type:disc">중요하지 않음 : 원본이 바뀐다는 사실만 알면 됨</li></ul><h3 id="22afac98-c795-4b77-a78e-d2a6a7fb0e04" class="">매개변수 배열의 길이를 알 수 있는 방법 : 없음!!</h3><ul id="045e36c7-7fad-4c23-b21f-7aa10a11ec18" class="bulleted-list"><li style="list-style-type:disc">배열 자체에서 크기를 알아올 수 있는 방법은 없음<p id="ce0cb899-5a7a-4fd2-ab86-be4268fadc21" class="">예외 : 앞서 설명한 <code>ARRAY_LENGTH()</code> 꼼수(매크로)를 쓸 경우</p><p id="6dc6f1b7-fb53-4692-9523-b4f9f8ff4bd7" class="">즉, <strong>배열의 크기는 따로 기억해둬야 함</strong></p><pre id="0ec3104c-f219-4691-802d-4f7f2fafbc08" class="code"><code>void process(size_t n, int nums[5]) {         /* size_t n 작성 필요 */
	size_t i;
	for (i = 0; i &lt; 5; ++i) {
		nums[i] *2;
	}
}</code></pre></li></ul><h3 id="2a37c40f-3ad0-4d30-a63a-e6f0fc521d70" class="">배열 요소의 초깃값</h3><ul id="3f8905ab-2da5-4943-ae33-5b3980fadc6b" class="bulleted-list"><li style="list-style-type:disc">C는 배열 요소의 값을 초기화해주지 않음</li></ul><ul id="cb380749-885f-4499-a724-72e14e8c87e4" class="bulleted-list"><li style="list-style-type:disc">따라서 그 전에 그 메모리에 남아있던 값을 그대로 사용 (변수도 마찬가지)<pre id="9f871bb1-3000-439a-8196-e95e3223d397" class="code"><code>int nums[30];              /* 속에 무슨 값이 들어있는지 모름 (쓰레기 값) */
int val;                   /* 마찬가지 */</code></pre></li></ul><h3 id="c03acbca-ed70-4a21-8367-4098e5e2a140" class="">배열 요소의 초기화</h3><pre id="007d80b2-3831-4b41-93eb-01e7538eabbf" class="code"><code>int nums1[4];                             /* 쓰레기만 잔뜩 */
int nums2[4] = { 10, 15, 3, -1 };         /* 모두 초기화 됨 */
int nums3[4] = { 10, 15 };                /* { 10, 15, 0, 0 } */
int nums4[2] = { 10, 15, 3 };             /* 컴파일 오류 */
int nums5[] = { 10, 15, 3 };              /* 배열의 크기 3, 컴파일러가 배열의 크기 결정 */</code></pre><h3 id="6a54a0c4-6f78-467b-8066-cf48ef011213" class="">배열 요소의 초기화 : BEST PRACTICE</h3><pre id="2f88c5f7-2a45-44c7-ac74-2e1a2ecb6f5b" class="code"><code>int nums[10] = { 0, };</code></pre><ul id="40b7b571-c6bc-478b-b7e5-1be18f129b68" class="bulleted-list"><li style="list-style-type:disc">배열의 모든 값을 0으로 초기화</li></ul><ul id="b5828b87-cee8-4778-abfd-8ce2a2782367" class="bulleted-list"><li style="list-style-type:disc">0 뒤에 쉼표</li></ul><ul id="20a0f260-0dfb-426e-928a-eb50a1bb6490" class="bulleted-list"><li style="list-style-type:disc">이를 통해 초기화 목록이 모든 값을 직접 초기화해주지는 않지만 쉼표 뒤가 모두 0으로 초기화 됨</li></ul><ul id="776ef8ed-8dac-4965-9139-c1c807ff516e" class="bulleted-list"><li style="list-style-type:disc">초기화를 제대로 진행하지 않는다면 초기화 안된 지역변수를 모른 채 사용할 수 있으며, 버퍼 오버플로도 가능 ⇒ 버퍼 오버플로를 아무도 체크해주지 않음</li></ul><h2 id="5cf929f8-353f-4b22-9503-cf1f077c02e9" class="">다차원 배열 (2차원, 3차원 배열)</h2><pre id="5548e3e0-3a08-4f96-b7dc-d955b6de7010" class="code"><code>/* 2차원 배열 예시 */

int table[2][3];

for (int i = 0; i &lt; 2; ++i)                /* y */
{
	for (int j = 0; j &lt;3; ++j)               /* x */
	{
		table[i][j] = (i + 1) * (j + 1);
	}
}</code></pre><pre id="52e8fcc8-272a-4500-bf76-6dbdbaa15be0" class="code"><code>/* 아래 2차원 배열과 1차원 배열은 같음! */

/* 2차원 배열 */

int buffer[3][2];
int i;
int j;

for (int i = 0; i &lt; 3; ++i)
{
	for (int j = 0; j &lt;2; ++j)
	{
		table[i][j] = (i + 1) * (j + 1);
	}
}

/* 1차원 배열 */

int buffer[3 * 2];
int i;
int j;

for (int i = 0; i &lt; 3; ++i)
{
	for (int j = 0; j &lt;2; ++j)
	{
		table[i][j] = (i + 1) * (j + 1);
	}
}</code></pre><p id="2e0d1a14-ae1c-4b7e-a1d6-941f817a9f26" class="">
</p></div></article></body>

{% endblock post_content %}