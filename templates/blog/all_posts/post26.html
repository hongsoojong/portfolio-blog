{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(3) 프로세스 스케줄러</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Oct 16, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="cc8cd087-799d-474b-ab3c-40f4834c15ee" class="page sans"><div class="page-body"><h2 id="868cd02b-f146-4cbe-8da1-e50a31ac82e7" class="">프로세스 스케줄러</h2><p id="df140dd7-b2dc-4e64-92de-12fa7cef455d" class="">리눅스 커널은 프로세스 스케줄러 기능을 통해 여러 개의 프로세스를 동시에 동작 시킴. 정확히는 동시에 동작시키는 것처럼 보이게 함</p><ul id="b2ec33fe-4714-414c-b195-e6bac36de568" class="bulleted-list"><li style="list-style-type:disc">하나의 CPU는 동시에 하나의 프로세스만 처리할 수 있음</li></ul><ul id="f4f823d5-fe08-4fcf-ad5b-c9f41e7eb8ca" class="bulleted-list"><li style="list-style-type:disc">하나의 CPU에 여러 개의 프로세스를 실행해야 할 떄는 각 프로세스를 적절히 시간으로 쪼개서(타임 슬라이스) 번갈아 처리함</li></ul><p id="ced91953-0a45-4863-a0da-c6cb11e21d0e" class=""><strong>&lt;정리&gt;</strong></p><ul id="bd7f9a9a-97e2-4689-bf15-1f4ce2cdc56f" class="bulleted-list"><li style="list-style-type:disc">동시에 프로세스를 여러 개 실행하더라도 특정 순간에 논리 CPU에서 동작되는 프로세스는 1개</li></ul><ul id="f4c16a76-2f31-4e5a-8b58-ca48c153245c" class="bulleted-list"><li style="list-style-type:disc">논리 CPU에는 여러 개의 프로세스가 순차적으로 1개씩 동작<ul id="0848ff8d-b984-4afc-9e33-cf2d15b91cb2" class="bulleted-list"><li style="list-style-type:circle">첫 번쨰 프로세스부터 마지막 프로세스까지 프로세스가 한 바퀴 다 돌고 나면 다시 첫 번쨰 프로세스로부터 동작하는 라운드 빈 방식으로동작</li></ul></li></ul><ul id="5ee912e5-8cff-41a1-ac6a-5289bf7b2615" class="bulleted-list"><li style="list-style-type:disc">각 프로세스는 대략 같은 타임 슬라이스를 가짐</li></ul><ul id="a0082128-b203-41e5-ae6f-2b6793f79601" class="bulleted-list"><li style="list-style-type:disc">프로세스를 종료할 때까지의 경과 시간은 프로세스 수에 비례하여 증가</li></ul><h2 id="7dd5ce46-d036-43bd-b55e-c4444a990ab1" class="">컨텍스트 스위치</h2><ul id="55f8e96e-9027-485f-896f-08f8de74b7e0" class="bulleted-list"><li style="list-style-type:disc">논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 컨텍스트 스위치(context switch)라고 부름</li></ul><ul id="c6200738-7b42-4344-97b2-2eaae0916617" class="bulleted-list"><li style="list-style-type:disc">프로세스가 전환되는 타임 슬라이스 타이밍에 컨텍스트 스위치가 발생함</li></ul><pre id="6f2b189a-c27d-4f12-866a-7cb5c5765240" class="code"><code>void main(void) {
	...
	foo()
	bar()
	...
}</code></pre><ul id="ce350451-4c54-4b57-af6b-cc75786eb324" class="bulleted-list"><li style="list-style-type:disc">잘못된 이해 <ul id="e9c145e1-441b-453f-95d9-aa9c487f0d41" class="bulleted-list"><li style="list-style-type:circle"><code>foo()</code>의 직후에 <code>bar()</code>가 실행<p id="229b7968-c6af-4cf1-89b4-5c774cfe08b7" class="">⇒ 이 추측은 보장할 수 없음</p></li></ul></li></ul><ul id="f21162c1-8ba8-4ae0-94a6-c12d59505e01" class="bulleted-list"><li style="list-style-type:disc"><code>foo()</code>의 실행 직후 타임 슬라이스가 모두 소비되었다면 <code>bar()</code>는 한 참 뒤에 실행<ul id="937aaa35-9e93-4e1d-8ec8-104e19502180" class="bulleted-list"><li style="list-style-type:circle">즉, <code>foo()</code>의 호출 뒤에 <code>bar()</code>를 호출하기 전에 다른 프로세스가 동작할 가능성이 있음<hr id="64c5ec7a-49c6-4025-8620-25287b8fa8b5"/><p id="fc819c5f-0363-4a14-ab46-86d5c8c778bf" class="">프로세스 0: <code>foo()</code> 실행 → 프로세스 1 실행 → 프로세스0: <code>bar()</code></p><hr id="c3da0715-5d60-4005-ae3a-ad87fec118e6"/></li></ul></li></ul><ul id="a6f97214-ad9b-4dc8-8e8b-5fc2a7114f5e" class="bulleted-list"><li style="list-style-type:disc">이를 통해 예상보다 처리 시간이 오래 걸렸을 때 &#x27;이 처리 자체에 문제가 있는게 틀림없어&#x27;라는 단순한 결론을 내리기보다는 &#x27;처리 중에 컨텍스트 스위치가 발생하여 다른 프로세스가 움직였을 가능성도 있어&#x27;라는 관점을 가질 수 있음</li></ul><h2 id="c367f6f7-7c3a-4423-9f26-16977730ae67" class="">프로세스의 상태</h2><ul id="e36b6afa-b47b-4872-8603-798af3677d63" class="bulleted-list"><li style="list-style-type:disc"><strong>실행 상태 : </strong>현재 논리 CPU를 사용하고 있음</li></ul><ul id="8ef054b6-4ac7-4d55-ac11-b64e96caa97f" class="bulleted-list"><li style="list-style-type:disc"><strong>실행 대기 상태 : </strong>CPU 시간이 할당되기를 기다리고 있음</li></ul><ul id="dbf7713f-b7de-412f-8a11-93a2106120a2" class="bulleted-list"><li style="list-style-type:disc"><strong>슬립 상태 : </strong>이벤트가 발생하기를 기다리고 있으며, 이벤트 발생까지 CPU 시간을 사용하지 않음<ul id="74cd16eb-8ab0-46b7-8e12-31627d63f907" class="bulleted-list"><li style="list-style-type:circle">정해진 시간이 경과하는 것을 기다림 (예를 들어 3분 대기 등)</li></ul><ul id="e8d2f468-40c2-4a6f-9912-a57060600fd8" class="bulleted-list"><li style="list-style-type:circle">키보드나 마우스 같은 사용자 입력을 기다림</li></ul><ul id="da8dc5b5-49ab-4bbe-a244-f00941fad0d1" class="bulleted-list"><li style="list-style-type:circle">HDD(hard disk drive)나 SDD(Solid State Drive) 같은 저장 장치의 읽고 쓰기의 종료를 기다림</li></ul><ul id="5c07e61e-9859-430a-a587-833dcb1cb862" class="bulleted-list"><li style="list-style-type:circle">네트워크 데이터 송수신의 종료를 기다림</li></ul></li></ul><ul id="a5a944dd-f94b-4a9c-b03d-f5a4c800a8e7" class="bulleted-list"><li style="list-style-type:disc"><strong>좀비 상태 : </strong>프로세스가 종료한 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있음</li></ul><h2 id="fa04286b-4a4e-4e96-aa5b-2a4d29594769" class="">프로세스 상태 변환 - 여러 case 정리</h2><ul id="73f77333-6eb4-4f35-9532-bc534b310ee4" class="bulleted-list"><li style="list-style-type:disc">1개의 프로세스가 동작되며, 슬립없이 수행되는 경우<ul id="6caf1587-82d3-4dff-bed8-833cb39ef974" class="bulleted-list"><li style="list-style-type:circle">실행 상태를 유지함</li></ul></li></ul><ul id="718e6ef5-77d9-41d6-89c8-84f98f31fa2a" class="bulleted-list"><li style="list-style-type:disc">2개의 프로세스가 동작할 경우<ul id="33abfbf0-223a-464c-a1af-a33b13bfe8ad" class="bulleted-list"><li style="list-style-type:circle">각 프로세스가 실행 상태와 실행 가능 상태가 번갈아 변환됨</li></ul></li></ul><ul id="566dde37-18d1-435a-be90-c1e92f8720f7" class="bulleted-list"><li style="list-style-type:disc">1개의 프로세스가 동작되며, 1번 슬립을 하는 경우<ul id="669a05f7-9722-43a7-8622-5d814feb95aa" class="bulleted-list"><li style="list-style-type:circle">하나의 프로세스가 실행 상태 → 실행 가능 상태  → 실행 상태</li></ul><ul id="e1614450-0a37-4ef8-8c1f-00d33c22c58d" class="bulleted-list"><li style="list-style-type:circle">이 경우 실제로 동작하지 않는 시간을 idle 프로세스가 동작하고 있음</li></ul></li></ul><h2 id="82966d8c-be45-4d00-a869-21254c43d0aa" class="">idle 상태</h2><ul id="3b644060-e77d-4b52-80e3-7aed25b54650" class="bulleted-list"><li style="list-style-type:disc">idle 프로세스라고 하는 아무것도 하지 않는 특수한 프로세스가 동작</li></ul><ul id="35b786f7-4a5f-4be6-8f78-0cb3962ce443" class="bulleted-list"><li style="list-style-type:disc">즉, 프로세스가 실행하고 있지 않은 상태</li></ul><ul id="c1e9d107-fa06-4045-8339-7b7651a1a6da" class="bulleted-list"><li style="list-style-type:disc">CPU의 특수한 명령을 이용하여 논리 CPU를 휴식 상태로 만들어 하나 이상의 프로세스가 실행 가능한 상태가 될 때까지 소비 전력을 낮춰 대기 상태로 만듬</li></ul><ul id="ba9fadb6-b090-43fd-9db4-06e8f86ef459" class="bulleted-list"><li style="list-style-type:disc">예를 든다면 1개의 프로세스만 동작할 때 본 프로세스가 사용자로부터 입력을 받아 이 내용으로 파일을 읽는 경우<ul id="56f9356a-8d97-4c9f-abc6-766f69af7351" class="bulleted-list"><li style="list-style-type:circle">사용자로부터 입력을 대기 ~ 사용자가 입력</li></ul><ul id="b73eaee5-cc20-455a-95a6-6b4c0344639d" class="bulleted-list"><li style="list-style-type:circle">입력된 내용으로 파일 읽기 ~ 파일 읽기 완료<p id="a1b6e880-19df-45d4-8376-f2c0d8d20a28" class="">⇒ 두 구간에서 슬립 상태(idle 상태)가 유지되는 것</p></li></ul></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="fff1b0e6-d010-4154-bc5a-7fa3d64b8a94"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>슬립 상태와 idle 상태의 용어를 정리하자면, 슬립 상태는 특정 프로세스가 실행을 대기하고 있는 상태를 의미하며, idle 상태는 논리 CPU에서 어느 프로세스도 실행되고 있지 않은 상태를 말함. 아래 그림을 보면 조금 더 이해하기 쉬움</strong></div></figure><h2 id="6dbdd236-9f98-40a0-baf7-2b92225f065e" class="">정리</h2><ul id="db3d8d26-a238-43b6-ae0d-cbb8764ec256" class="bulleted-list"><li style="list-style-type:disc">논리 CPU로 한 번에 실행할 수 있는 프로세스는 1개 뿐</li></ul><ul id="a1f0dee8-018d-4ac5-b5df-a4c6c525b836" class="bulleted-list"><li style="list-style-type:disc">슬립 상태에서는 CPU의 시간을 사용하지 않음</li></ul><h2 id="45920b74-aec7-48e5-abef-c5e8a8f347e8" class="">스루풋과 레이턴시</h2><ul id="c15d22a7-bf27-4ea6-836f-d1af8a23ae17" class="bulleted-list"><li style="list-style-type:disc">각종 처리의 성능 지표인 스루풋(throughput)과 레이턴시(latency)<ul id="316b59f9-1e32-45ae-91a1-c6de048b3186" class="bulleted-list"><li style="list-style-type:circle">스루풋 : 단위 시간당 처리된 일의 양으로 높을수록 좋음<p id="34b64ee7-721a-4036-9a05-69888b759fc3" class="">⇒ 완료된 프로세스의 수 / 경과 시간</p></li></ul><ul id="2657e6dc-d69b-4782-a855-9c7ebf7d93ac" class="bulleted-list"><li style="list-style-type:circle">레이턴시 : 각각의 처리가 시작부터 종료까지 경과된 시간으로 짧을수록 좋음<p id="382f0959-fbcc-4451-bcb2-68928f455988" class="">⇒ 처리 종료 시간 - 처리 시작 시간</p></li></ul></li></ul><ul id="55a3e68c-f8b2-4ba0-a329-9e3852da2969" class="bulleted-list"><li style="list-style-type:disc">논리 CPU의 능력을 전부 활용, 즉 모든 논리 CPU가 idle 상태가 되지 않을 경우에는 프로세스 개수를 늘려도 스르풋은 변하지 않음<ul id="b7bf4fe1-f26f-4b32-856d-8ca684394e1a" class="bulleted-list"><li style="list-style-type:circle">정확하게 말하자면 %idle이 0인데도 프로세스를 계속 늘리면 컨텍스트 스위치의 오버헤드 등의 증가로 스루풋은 감소함</li></ul></li></ul><ul id="8f86ece7-f105-4c57-a4c0-6b3dc22d5996" class="bulleted-list"><li style="list-style-type:disc">프로세스 수를 늘릴수록 레이턴시는 악화됨</li></ul><ul id="48900775-cc03-4704-ab77-76ee648a1cbb" class="bulleted-list"><li style="list-style-type:disc">각 프로세스의 평균 레이턴시는 비슷함</li></ul><h3 id="6652516e-987d-4474-a961-cc217d01b48f" class="">실제 시스템</h3><ul id="aad54088-dd00-46c7-a2c4-ba1bb2015558" class="bulleted-list"><li style="list-style-type:disc">논리 CPU가 항상 움직이는, 즉 idle 상태가 없는 경우, 거기에 실행 대기 상태의 프로세스가 없는 경우에 스루풋과 레이턴시 모두 최대가 됨</li></ul><ul id="e245c058-acf7-4ac5-b6e2-f786637b28bc" class="bulleted-list"><li style="list-style-type:disc">이는 이상적인 상황일 뿐 실제로 논리 CPU는 아래와 같은 상태가 정신없이 바뀜<ul id="ee7189fc-53ce-40e5-9b46-81156778c8e2" class="bulleted-list"><li style="list-style-type:circle">idle 상태 :  논리 CPU가 쉬고 있기 때문에 스루풋이 떨어지는 경향이 있음</li></ul><ul id="287b0d1d-13c4-40b0-aab2-bf64744030d8" class="bulleted-list"><li style="list-style-type:circle">프로세스가 동작 중 : 실행 대기의 프로세스가 없기 때문에 이상적인 상태. 그러나 이러한 상태는 다음 프로세스가 실행 가능한 상태면 2개의 프로세스의 레이턴시가 양쪽 다 길어짐</li></ul><ul id="072327ed-e845-408a-895e-ba6c11df8422" class="bulleted-list"><li style="list-style-type:circle">프로세스가 대기 중 : 실행 대기 프로세스가 있음. 스루풋은 높지만 레이턴시가 길어지는 경향이 있음</li></ul></li></ul><h2 id="6ce68507-739d-454d-be29-30197075b667" class="">논리 CPU가 여러 개일 때 스케줄링</h2><h3 id="77ecdb14-2b25-4f72-82d0-9aec1a644200" class="">로드 밸런서(load balancer)</h3><ul id="fd87002f-6542-401d-9bfe-07f60838b495" class="bulleted-list"><li style="list-style-type:disc">혹은 글로벌 스케줄러(global scheduler)</li></ul><ul id="cb6360ec-1b73-4814-8620-8367c03151d3" class="bulleted-list"><li style="list-style-type:disc">여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할을 함</li></ul><ul id="4e1bf6b1-66e8-48a0-8824-2f6b26916cb7" class="bulleted-list"><li style="list-style-type:disc">프로세스를 할당받은 각 논리 CPU 안에서 1개의 논리 CPU가 있을 때와 마찬가지로 각 프로세스에 공평하게 CPU 시간을 분배함</li></ul><h2 id="258507cd-dd5b-4017-9230-e6be89c1939c" class="">고찰</h2><ul id="b0f5eb24-dea1-4e04-b9e5-cbc62b2bc051" class="bulleted-list"><li style="list-style-type:disc">1개의 CPU에 동시에 처리되는 프로세스는 1개</li></ul><ul id="8b843a0c-649c-4dd3-ab47-06ee917a4b0b" class="bulleted-list"><li style="list-style-type:disc">여러 개의 프로세스가 실행 가능한 경우 각각의 프로세스를 적절한 길이의 시간(타임 슬라이스)마다 CPU에서 순차적으로 처리함</li></ul><ul id="5ca4ac1a-7dd3-4412-a1e4-c1cd332bb774" class="bulleted-list"><li style="list-style-type:disc">멀티코어 CPU 환경에서는 여러 개의 프로세스를 동시에 동작시키지 않으면 스루풋이 오르지 않음<ul id="4318a690-1368-445b-95d7-70cd64ef1485" class="bulleted-list"><li style="list-style-type:circle">코어가 n개 있으므로 성능이 n배라고 말할 수 있는 것은 어디까지나 최선의 케이스인 경우임</li></ul></li></ul><ul id="55b3a940-8ef0-4e78-ac2b-4b28fc3ce587" class="bulleted-list"><li style="list-style-type:disc">단 1개의 논리 CPU의 경우와 마찬가지로 프로세스 수를 논리 CPU보다 많게 하더라도 스루풋은 오르지 않음</li></ul><h2 id="01996d8f-47a5-4e7b-bd6e-41366511a65a" class="">경과시간과 사용시간</h2><ul id="32aafa94-6d7a-41c1-ac35-7ca34b6c71cc" class="bulleted-list"><li style="list-style-type:disc">경과시간 : 프로세스가 시작해서 종료할 때까지의 시간</li></ul><ul id="1eaf9d21-712b-4d81-9504-d9fffecd68a1" class="bulleted-list"><li style="list-style-type:disc">사용시간 : 프로세스가 실제 논리 CPU를 사용한 시간</li></ul><h2 id="5d58a0a9-d2a0-4f67-a16b-bbcb3f1e40ef" class="">우선순위 변경</h2><ul id="4ee37654-0bd6-44d6-b0f6-a5a580ac032d" class="bulleted-list"><li style="list-style-type:disc">우선순위가 높은 프로세스는 평균보다 CPU 시간을 더 많이 배정받음</li></ul><ul id="bf235cd6-64f2-4ecd-bfb8-dedd41632ef5" class="bulleted-list"><li style="list-style-type:disc">이와 반대로 우선순위가 낮은 프로세스는 평균보다 적은 CPU 시간을 배정받음</li></ul><ul id="915cb0cc-6e49-47e1-8bb0-a6c78aaf1c08" class="bulleted-list"><li style="list-style-type:disc"><code>nice()</code>함수를 통해 -19~20의 수를 배정받하여 우선순위 결정<ul id="2d3eed27-f11c-4261-8989-0e3b2fbdfe03" class="bulleted-list"><li style="list-style-type:circle">값이 작을수록 우선순위가 높음</li></ul></li></ul><ul id="b9f15aec-454e-42cd-833a-814706a5785e" class="bulleted-list"><li style="list-style-type:disc">우선적으로 CPU 시간을 얻은 프로세스는 먼저 종료됨</li></ul></div></article></body></html>

{% endblock post_content %}