{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(8) 구조체, 공용체, 함수 포인터</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 27, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="af642fae-b1ae-463e-b48b-38491653e53f" class="page sans"><div class="page-body"><h2 id="58e2a5d3-80ff-4e69-af79-b9bbb0ff4792" class="">구조체</h2><ul id="746c7a8e-818c-4c93-ae1f-744486052c49" class="bulleted-list"><li style="list-style-type:disc">데이터의 집합 → 멤버 함수 따위 없음!</li></ul><ul id="ac71d572-7e8e-48e1-aa96-f6f641fb2939" class="bulleted-list"><li style="list-style-type:disc">여러 자료형을 가진 변수들을 하나의 패키지로 만들어 놓은 것</li></ul><ul id="c4b2bab5-8868-4c17-85df-05f1ac04408f" class="bulleted-list"><li style="list-style-type:disc">C에서는 모든 자료형은 값형<p id="74b31896-7895-4b6b-b659-78f1deeef933" class="">⇒ 하지만 주소를 전달하면 참조형으로 쓸 수 있음! 주소를 전달하지 않는 한 모두 값형임!</p></li></ul><h3 id="185ea309-1340-42cf-89c5-c06ae031937b" class="">구조체를 사용하는 이유</h3><ul id="b976d418-5105-460e-92f3-c31970e190ff" class="bulleted-list"><li style="list-style-type:disc">여러 데이터가 합쳐져 하나의 단위로 봐야하는 경우들이 있음<p id="a4ebb9bf-55a7-427e-ab93-f565245c272a" class="">⇒ 시간의 표현 (2시 + 34분)</p></li></ul><ul id="39d43e33-e484-49e4-a65d-6e268c700111" class="bulleted-list"><li style="list-style-type:disc">구조체를 통해 실수를 막을 수 있음<pre id="653bf21c-c842-4f4c-8b08-b11f32ef0c70" class="code"><code>if (is_monday(2043, 10, 1)) {
	run_format();
}
/*
10월 1일인지 1월 10일인지 사람마다 다르게 해석 가능
*/</code></pre></li></ul><ul id="d3c520c4-d98f-4334-b1b3-fc9f78b5b2f1" class="bulleted-list"><li style="list-style-type:disc">같은 형의 데이터 여러개를 매개변수로 받을 때 순서가 바뀌면 컴파일러가 실수를 찾을 방법이 없음<pre id="3e5aebc0-437d-4a63-baa1-f4510273c361" class="code"><code>float calculate_BMI(float height, float weight);

calculate_BMI(75.2f, 180.3f); /* 키와 몸무게가 잘못 들어감 */</code></pre></li></ul><ul id="300b74ac-1a6e-4891-bd31-3809677bbabd" class="bulleted-list"><li style="list-style-type:disc">묵시적으로 변환 가능한 자료형이 여러 개 일때도 마찬가지로 컴파일러가 실수를 찾을 수 없음<pre id="4920decb-d1da-4290-afa7-af499c3c03d1" class="code"><code>int save_data(unsigned char level, float money, const char* name)

unsigned char lvl = 10;
unsigned int exp = 12355;
float money = 256.10;
const char* name = &quot;Griff Bright&quot;;

int result = save_data(lvl, exp, name);</code></pre></li></ul><ul id="11dd9ff6-82d1-4095-ad8d-c73fe7fc76e3" class="bulleted-list"><li style="list-style-type:disc">매개변수 목록이 길어질수록 실수가 발생할 가능성이 높음<pre id="703f621b-e5b0-4896-b1b7-661cfe43c362" class="code"><code>int save_data(unsigned char level, unsigned int exp, float money, unsigned char str, unsigned char intell, unsigned short death_count, ...);

save_data(level, money, exp, intel, str, death, assist, ...);</code></pre></li></ul><ul id="e69d3f88-7a07-4302-977a-cd9ab03813b8" class="bulleted-list"><li style="list-style-type:disc">중간에 누군가 매개변수를 바꾸면 문제가 생김<pre id="dcff5bc1-f482-4747-881c-169759cc8c46" class="code"><code>void update_KDA(int kill, int assist, int death);

int kill = 40;
int assist = 60;
int death = 1;
update_KDA(kill, assist, death);

/* 변경 후 */
void update_KDA(int kill, int death, int assist);

int kill = 40;
int assist = 60;
int death = 1;
update_KDA(kill, assist, death);</code></pre></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8329b854-3628-4b32-9bee-7bfb0e29f3a5"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>실수를 줄일려면 원자성을 보장하는 연산(atomic operation)을 사용하는 것이 좋음</strong></div></figure><h3 id="cf083278-8e2c-4e43-b00f-2ef5324d5999" class="">실수 없는 구조체의 예시</h3><p id="eb459711-6ff4-4a5f-8596-58ae209a0805" class=""><strong>&lt;구조체의 선언&gt;</strong></p><pre id="0ed2315f-c680-4286-b9cb-39c13d4ba97e" class="code"><code>struct date{
	int year;
	int month;
	int day;
};</code></pre><ul id="5d4d00bc-70ac-45d6-9cdc-d6be2e4e69c7" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>반드시 세미콜론 마지막에 붙여야함</strong></mark></li></ul><ul id="6993f187-9815-4066-a2b3-467c9c4d621e" class="bulleted-list"><li style="list-style-type:disc">date란 구조체(새로운 형)를 만듬</li></ul><ul id="ac2ed451-0dc2-4396-98ad-50461b66e027" class="bulleted-list"><li style="list-style-type:disc">그 안에 들어가 있는 데이터(멤버 변수)는 총 세 개(year, month, day)</li></ul><ul id="23f308b7-4d27-4780-8e84-f4f0d40132dd" class="bulleted-list"><li style="list-style-type:disc"><code>struct date</code> 여기서 <code>date</code>를 자료형, 즉 <code>int</code>형, <code>char</code>형 등과 같은 개념으로 생각해주면 됨</li></ul><p id="372311a5-4696-4eb4-8648-140299092eab" class=""><strong>&lt;구조체의 변수 선언 및 사용하기&gt;</strong></p><pre id="88b67565-3f36-4863-b540-09ca80dc79e9" class="code"><code>
int is_monday(struct date date)
{
	int day = date.day;
	int month = date.month;
	int year = date.year;

	/* 위 세 변수 가지고 월요일인지 아닌지 구해서 참/거짓 반환 */
}</code></pre><pre id="2165dce0-9be6-4b2f-ac8a-d6394d7e0ef3" class="code"><code>struct date date;

date.year = 2043;
date.month = 10;
date.day = 1;

if (is_monday(date)) {
	/* 포맷 */
}</code></pre><ul id="a7509879-db1c-4a4b-b41a-09dfa666dbba" class="bulleted-list"><li style="list-style-type:disc"> <code>int is_monday(struct date date);</code> / <code>struct date date;</code><ul id="41533d18-7ec7-4997-9285-010ef4237a5c" class="bulleted-list"><li style="list-style-type:circle">date라는 구조체(자료형)</li></ul><ul id="2165a209-c9c5-45ee-83a6-c811b669bba7" class="bulleted-list"><li style="list-style-type:circle">변수명은 date</li></ul><ul id="66702ba2-ac95-477d-9f33-89acbbbea9c9" class="bulleted-list"><li style="list-style-type:circle">함수의 매개변수로도 사용 가능</li></ul></li></ul><ul id="df29a2c8-d4be-4e39-a6df-cac80cbed07e" class="bulleted-list"><li style="list-style-type:disc"><code>struct date date;</code><ul id="d26c05ca-94a2-48f4-992d-05251a9a5d49" class="bulleted-list"><li style="list-style-type:circle">지역변수 선언시 0으로 초기화 안됨</li></ul><ul id="aedaab92-9894-4486-ac29-9deb5b70bfc9" class="bulleted-list"><li style="list-style-type:circle">스택 위치에 있던 값을 그대로 가져다 씀</li></ul></li></ul><h3 id="1f56cc2d-6e08-4cb2-8a47-264c10776fd4" class="">너무 장황한 구조체의 데이터형</h3><pre id="4d27613e-063a-439e-bbdc-4506775cf392" class="code"><code>struct date date;</code></pre><ul id="564e8c9a-a056-4144-b23f-da5ec95b6028" class="bulleted-list"><li style="list-style-type:disc">해결책 → <code>typedef</code></li></ul><h3 id="1b04a6d5-4f4a-4ec0-9098-dea8e9725a6c" class="">typedef</h3><pre id="a286d9fa-6224-4259-9005-831f1bb15653" class="code"><code>/* &lt;stddef.n&gt; */
typedef unsigned int        size_t;</code></pre><ul id="8a1d4ca1-390d-40c7-b596-e76bae61c7ca" class="bulleted-list"><li style="list-style-type:disc">이미 있는 unsigned int에 새로운 별명을 지어줌</li></ul><ul id="113499d2-d473-4348-b025-a89296b6508b" class="bulleted-list"><li style="list-style-type:disc">그 새로운 이름은 size_t<p id="b3027b69-83d6-473d-8092-dea4e8fbdc38" class="">⇒ 그냥 unsigned int를 써도 전혀 상관없음<div class="indented"><p id="0484f735-2597-4012-b7dd-c92a019c761c" class="">서로 바꿔가며 써도 됨</p></div></p></li></ul><ul id="d1cb402e-adc6-40c1-9da3-57ad1cbec0fc" class="bulleted-list"><li style="list-style-type:disc">물론 size_t의 경우 각 구현마다 자료형이 달라질 수 있어서 typedef를 해놓은 것</li></ul><h3 id="934ecd76-12f8-4825-b3a2-9bf72eaa650a" class="">typedef 사용법 (1)</h3><ul id="71da8f05-5fce-4455-b848-6d954835681c" class="bulleted-list"><li style="list-style-type:disc">구조체에서 typedef를 쓰면 다른 자료형처럼 간결하게 변수 선언이 가능함</li></ul><pre id="324c2439-b4db-4682-8c5f-da1e33fb1a55" class="code"><code>struct date {
	int year;
	int month;
	int day;
};

typedef struct date date_t;</code></pre><pre id="ef5b6efe-c64d-4694-9e82-3233ce8916ab" class="code"><code>date_t date;

date.year = 2043;
date.month = 10;
date.day = 1;

if (is_monday(date)) {
	/* 포맷 */
}</code></pre><h3 id="3ee49be6-8a89-4536-bf0e-7822db58cbda" class="">typedef 사용법 (2)</h3><pre id="d8d78a08-51a6-46e8-b6d2-8a228e141c83" class="code"><code>typedef struct date {
	int year;
	int month;
	int day;
} date_t;</code></pre><h3 id="bd5eca5b-74ce-4592-980b-ebd4baf27b86" class="">typedef 사용법 (3)</h3><pre id="434bb67a-13b6-474e-9bde-39de866b4d8f" class="code"><code>typedef struct {
	int year;
	int month;
	int day;
} date_t;</code></pre><p id="96158758-91be-4968-b415-d91fba756e0c" class="">⇒ <code>_t</code> : typedef를 의미함</p><h3 id="46233eea-9f72-4eb5-9938-9e04e87b3492" class="">세 가지 typedef 사용법 정리</h3><pre id="9325e329-0f0d-4dd8-96c3-758fd0fc1c3b" class="code"><code>/* 1 */

struct date {
	int year;
	int month;
	int day;
};

typedef struct date date_t;

/* 2 */

typedef struct date {
	int year;
	int month;
	int day;
} date_t;

/* 3 */

typedef struct {
	int year;
	int month;
	int day;
} date_t;</code></pre><ul id="1489aa99-1023-4be1-b298-08d35e7e22a8" class="bulleted-list"><li style="list-style-type:disc">1번, 2번 : 함수 선언시 <code>struct date</code>, <code>date_t</code> 두가지 사용가능</li></ul><ul id="b3a53923-d85f-4077-8325-44c10f58eca2" class="bulleted-list"><li style="list-style-type:disc">3번 : <code>struct date</code> 사용이 불가능하며, 유일하게 <code>date_t</code>만 사용가능</li></ul><h3 id="ba9dbec0-6986-4fd5-8164-f0f4f86fae34" class="">enum의 typedef 활용</h3><pre id="8f063b76-26d0-4f37-b029-fa4b83c1b5b8" class="code"><code>/* 기본형 */

enum game_role {
	GAME_ROLE_MID,
	GAME_ROLE_JUNGLE
};</code></pre><pre id="2441517c-6b18-4015-b87c-3c6e661ddcc9" class="code"><code>/* 1 */

struct game_role {
	GAME_ROLE_MID,
	GAME_ROLE_JUNGLE
};

typedef struct game_role game_role_t;

/* 2 */

typedef struct game_role {
	GAME_ROLE_MID,
	GAME_ROLE_JUNGLE
} game_role_t;

/* 3 */

typedef struct {
	GAME_ROLE_MID,
	GAME_ROLE_JUNGLE
} game_role_t;</code></pre><h3 id="daf1d6d2-9b18-4c45-8d0a-d5c1e98c3b07" class="">코딩 표준 : 커스텀 자료형에 typedef를 쓰자</h3><ul id="f9acecb6-c9b4-476c-8b59-58a18a235313" class="bulleted-list"><li style="list-style-type:disc">가능하면 구조체, 열거형, 공용체에 typedef를 써서 정말 제대로 된 자료형처럼 보이게 하는 것이 좋음</li></ul><h3 id="a24944f7-80d0-4eba-a282-e530453789f0" class="">구조체 변수 초기화하기</h3><ul id="bae504d6-1edf-4777-b835-ab861ead8834" class="bulleted-list"><li style="list-style-type:disc"><strong>구조체 선언과 동시에 초기화는 되지 않음</strong><p id="08968acf-f8ff-4d8d-b677-96763eec89f7" class=""><strong>⇒ 스택에 남아있는 데이터를 그대로 사용</strong></p></li></ul><ul id="edfb3ab5-c5b8-45b8-85ad-29ae776719f3" class="bulleted-list"><li style="list-style-type:disc">그냥 구조체는 지역 변수를 여러 개 따로 사용하는 것과 마찬가지<ul id="8f527f54-13c4-41cc-81f0-ad24ab092d0e" class="bulleted-list"><li style="list-style-type:circle">기계는 구조체라는 개념 자체를 알지 못함</li></ul><ul id="54634dfe-14dc-48ed-b318-6488a789a5a2" class="bulleted-list"><li style="list-style-type:circle">프로그래밍 언어가 프로그래머 편하고 실수하지 말라고 제공해준 개념</li></ul></li></ul><h3 id="7307d6c1-5eb2-4455-8747-ba4fd1d9cf43" class="">메모리/어셈블리어 확인</h3><pre id="fcebee77-8bd2-4ae0-bd18-f1c08241d73e" class="code"><code>/* 그냥 int형 지역변수 사용 */

int main(void)
{
	int day;
	int month;
	int year;

	year = 2043;
	month = 10;
	day = 1;

	return 0;
}

/* 구조체 사용 */

int main(void)
{
	date_t date;

	date.year = 2043;
	date.month = 10;
	date.day = 1;

	return 0; 
}</code></pre><ul id="0aa2606e-845d-41ec-be8d-a2b5021ce828" class="bulleted-list"><li style="list-style-type:disc">완전히 똑같음!</li></ul><h3 id="b00cce59-b5e2-43a3-9f2c-90a315677086" class="">구조체의 초기화 방법</h3><pre id="883d77dc-e4a8-4ce3-9c8c-7c779367a54e" class="code"><code>date_t date;

date.year = 0;
date.month = 0;
date.day = 0;</code></pre><pre id="bfec7de0-2a00-4d9a-a496-58e98ed88da9" class="code"><code>date_t date = {0, };</code></pre><ul id="ac0555bc-3b6d-4165-b283-5b97cce74e5d" class="bulleted-list"><li style="list-style-type:disc">배열 초기화 방법과 같음</li></ul><ul id="006817cf-af09-4d8f-a1cb-a658fec60fe1" class="bulleted-list"><li style="list-style-type:disc">컴파일러에 따라 그냥 date가 차지하는 모든 메모리 공간을 0으로 채워주는 명령어로 바꿔줄 수도 있음 <code>memset()</code></li></ul><ul id="2bdb0f55-3ac1-42d6-b1dc-6b5b256d827a" class="bulleted-list"><li style="list-style-type:disc">배열의 초기화에서 쓴 방법처럼 요소 나열법으로 초기화도 가능함<pre id="11fe8c75-9f4b-4524-ae5d-0aa67f969395" class="code"><code>typedef struct date {
	int year;
	int month;
	int day;
} date_t;

date_t date = { 2043, 10, 1 };</code></pre><ul id="734474c3-1302-4f8a-9b66-78007e0316a2" class="bulleted-list"><li style="list-style-type:circle"><strong>하지만 이 방법은 최대한 쓰지 않는 것이 좋음 </strong></li></ul><ul id="db3ffde2-14da-4091-9279-e29e760212c1" class="bulleted-list"><li style="list-style-type:circle">실수의 여지가 농후함<p id="222219d0-ff46-46e8-8311-416c54d36367" class=""><strong>⇒ 나중에 다른 프로그래머가 구조체의 멤버 변수 분서를 바꾸고 변수 초기화 목록을 안 고칠 경우 엉뚱한 변수가 매치되버림</strong></p></li></ul><ul id="1a602376-b668-4125-a261-7fa04d401440" class="bulleted-list"><li style="list-style-type:circle"><strong>요소 나열법을 통한 초기화 방법이 유일한 경우는 단 하나</strong><p id="c6d0ccd4-ee33-45fc-bc31-0b51e26bdfb2" class=""><strong>⇒ 멤버 변수가 </strong><strong><code>const</code></strong><strong>일 때, 선언 시 초기화 안하면 다시는 못함</strong></p><pre id="6808abc2-ec3e-4c79-ad37-a5b5d4ff45cf" class="code"><code>typedef struct date {
	const int year;
	int month;
	int day;
} date_t;

/* 컴파일 오류나는 경우 */ 

date_t date;

date.year = 2019;                 /* 컴파일 오류 */
date.month = 12;
date.day = 31;

/* 컴파일 되는 경우 */

date_t date = { 2019, 12, 31 );    /* OK */</code></pre></li></ul></li></ul><h3 id="5bb453e1-9221-4842-86e9-abf6fcb2767b" class="">1년 더하기 - 잘못된 예시</h3><pre id="e3e82831-f8c6-42c5-b8a7-e78411f03c56" class="code"><code>void increase_year(date_t date)
{
	++date.year;
}</code></pre><pre id="fc733b7c-77f5-44ba-9b79-0b715dc36539" class="code"><code>date_t date;

date.year = 2019;
date.month = 12;
date.day = 31;

increase_year(date);

printf(&quot;%d-%d-%d\n&quot;, date.year, date.month, date.day);</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0b02ee1c-1947-47e1-9242-8a897ab92521"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>위와 같이 아무리 바꿔봐야 사본이 바뀔 뿐 원본은 바뀌지 않음! C에서 자료형은 다 똑같이 참조형이 아닌 값형으로 작동함!!! 잊어버리면 안됨!!</strong></div></figure><h3 id="ae66d1ea-2793-4b2a-a381-0df25073b320" class="">원본을 바꾸고 싶다면? 구조체의 포인터</h3><pre id="7ce3cf88-0cb2-46e0-a640-b060a1fe79e4" class="code"><code>date_t* date</code></pre><pre id="f87bbaf5-e4dd-46bb-b1d0-1f3e90f5996a" class="code"><code>void increase_year(date_t* date)
{
	(*date).year = (*date).year + 1
}</code></pre><ul id="a51301e9-7ffc-4def-a43d-6ebac0948b57" class="bulleted-list"><li style="list-style-type:disc"><code>()</code>이 필요한 이유<ul id="edb023b1-08fd-4168-b29f-2e2734e4a62c" class="bulleted-list"><li style="list-style-type:circle">연산자 우선순위 때문</li></ul><ul id="67fe2919-7897-40f1-a561-ddb0a1d4fa66" class="bulleted-list"><li style="list-style-type:circle"><code>.</code>연산자의 우선순위는 1, <code>*</code>연산자 우선순위는 2</li></ul></li></ul><ul id="d74419c9-9600-431f-a384-e7511e112e86" class="bulleted-list"><li style="list-style-type:disc">즉, 괄호가 없다면 <code>*date.year</code> → <code>*(date.year)</code></li></ul><h3 id="e62a77b8-10d4-49d4-b121-4b1ff8007acf" class="">-&gt; 연산자</h3><pre id="7dc10f3f-ba8f-4275-9f27-24c80ba87ced" class="code"><code>(*date).year = (*date).year + 1;
date-&gt;year = date-&gt; + 1;
date-&gt;year++;

/* 세 코드는 모두 같은 의미 */</code></pre><ul id="e7d55167-9f32-45d9-a62e-ac786359a03c" class="bulleted-list"><li style="list-style-type:disc"><code>(* ).</code> : <code>*</code>과 <code>()</code>를 합친 간단한 연산자</li></ul><h3 id="8403ebfb-eb3f-4849-8425-fc99b38bfa70" class="">구조체 매개변수 베스트 프랙티스</h3><p id="cdf05417-05b4-4541-8292-d2cf86e4efd3" class="">1) 값으로 전달 vs 주소로 전달</p><ul id="00f173a5-043b-42b0-a6c4-44bf43494586" class="bulleted-list"><li style="list-style-type:disc">기본 자료형 전달할 때는 간단했음<ul id="85ff3834-799a-4aaa-adb2-82ad176da08a" class="bulleted-list"><li style="list-style-type:circle">기본 데이터 크기가 작으니 원본을 바꿀 때만 주소로 전달하면 됨</li></ul></li></ul><ul id="c4243b1f-c382-4c13-a6b3-156e54820869" class="bulleted-list"><li style="list-style-type:disc"><strong>구조체의 경우 데이터 크기가 클 수도 있음</strong><ul id="02c4d463-07b3-418c-92ec-88c57eb60522" class="bulleted-list"><li style="list-style-type:circle">구조체 안에서 <code>int</code>형 멤버 변수가 5만 개면 200KB</li></ul><ul id="dd694006-09bc-477d-9ce9-36874ae7c66f" class="bulleted-list"><li style="list-style-type:circle"><strong>이럴 때는 다 복사하는 게 성능이 느릴 수 있음 → 주소로 전달!</strong></li></ul><ul id="1b9e4076-357b-44dc-a4cc-57a4b1d75ea7" class="bulleted-list"><li style="list-style-type:circle"><strong>포인터에 </strong><strong><code>const</code></strong><strong> 포인터를 붙이면 원본을 못 바꾸니 안전</strong></li></ul></li></ul><pre id="5b04c6ba-ddd2-4ebd-9165-da2d1fb4d3cc" class="code"><code>typedef struct achievement {
	int achv1;
	/* ... */
	int achv50000;
} achievement_t;

void save_achievements(const achievement_t achv)     /* BAD */
void save_achievements(const achievement_t* achv)    /* GOOD */</code></pre><p id="86504185-9bb8-4ed8-95bf-21737e92e517" class="">2) 구조체 매개변수 vs 여러 개의 개별 변수</p><ul id="5b19db75-a521-4af2-a9ce-98be27970604" class="bulleted-list"><li style="list-style-type:disc">딱히 정확한 규칙이 있지 않지만 <strong>보통 변수가 많이 전달하는 대신 구조체 하나 전달하라고 함</strong></li></ul><ul id="20af4ff7-d9b2-489f-820c-b01880f559d5" class="bulleted-list"><li style="list-style-type:disc">한 4개까지는 낱개 변수로 그 이후에는 구조체로 넘기라는 규칙을 쓰는 회사도 있음</li></ul><ul id="dec4671e-5008-40d3-8888-c05e320cc1e9" class="bulleted-list"><li style="list-style-type:disc">이유는 다양함<ul id="8fe852a9-f3e6-44d6-99ec-4fe8869f4a01" class="bulleted-list"><li style="list-style-type:circle">실수를 줄이기 위해</li></ul><ul id="8bfa43d2-c816-447c-972a-34618c4fd436" class="bulleted-list"><li style="list-style-type:circle">성능을 빠르게 하기 위해 (특히, 주소로 전달할 경우)</li></ul></li></ul><pre id="cf2d3070-4ad2-4391-b1fe-2d9a24eee95f" class="code"><code>void save_character_info(id_t id, const char* name, level_t lvl, float exp, class_t class, ... date_t last_logout);
/* 매개변수가 10개쯤 되는 함수 */

typedef struct character_info {
	id_t id;
	const char* name;
	/* ... */
	date_t last_logout;
} character_info_t

void save_character_info(const character_info_t* character)</code></pre><h3 id="c6faa107-038b-42fd-a72a-7dca443d7669" class="">퀴즈</h3><pre id="8e805bbd-e04d-41fa-b947-38370fa9df9a" class="code"><code>#include &lt;stdio.h&gt;

typedef struct {
    float x;
    float y;
} point_t;

void AddValueToPoint(point_t p);

int main(void)
{
    point_t point;
    point.x = 5.0f;
    point.y = 10.0f;

    AddValueToPoint(point);

    printf(&quot;%.1f, %.1f\n&quot;, point.x, point.y);

    return 0;
}

void AddValueToPoint(point_t p)
{
    p.x += 10.0f;
    p.y += 15.0f;
}

/* 정답 : 5.0 10.0 */</code></pre><h3 id="2e2a8bd8-9e4f-4e23-86b4-f2f5f072e7e3" class="">함수 반환값으로서의 구조체</h3><pre id="24a51280-fdd0-45b7-bc05-b99260ddd83c" class="code"><code>date_t get_dday(void)
{
	date_t date;

	date.year = 2043;
	date.month = 10;
	date.day = 1;

	return date;
}</code></pre><pre id="beef617b-7e67-4236-9785-d3bb89fecd6c" class="code"><code>date_t date;
date = get_dday();</code></pre><ul id="42d720a8-9efa-4715-bc50-f6c08f3193b9" class="bulleted-list"><li style="list-style-type:disc"><code>int</code>형 하나 반환하는 것과 마찬가지로 <strong>복사에 의해 반환</strong></li></ul><ul id="bbe502c3-2d05-47ec-a0c6-72d30264046c" class="bulleted-list"><li style="list-style-type:disc">C 언어의 함수는 반환값이 하나라고 했음</li></ul><ul id="7a4b6aa3-8773-40cc-8e50-c442f61a74c6" class="bulleted-list"><li style="list-style-type:disc">이렇게 구조체를 반환하면 실질적으로 여러 개의 값을 반환하는 격</li></ul><h3 id="456b501f-a439-493e-82e6-658a53d2bd7f" class="">구조체 대입</h3><ul id="6034fefe-f62b-40c9-a313-e50c951a4ffe" class="bulleted-list"><li style="list-style-type:disc"><code>date = get_dday();</code>가 된다는 건 대입도 가능하다는 것을 의미</li></ul><pre id="013a7dfb-1e05-4083-8a35-61854310dff2" class="code"><code>date_t date1; /* { 2043, 10, 1 } */
date_t date2; /* { 0, 0, 0 } */

date2 = date1</code></pre><ul id="214b0444-1af5-4a32-bc81-9015adb9f2bd" class="bulleted-list"><li style="list-style-type:disc">개념상 각 멤버 변수를 돌아가며 하나씩 대입한다고 봐도 됨</li></ul><ul id="b003fb46-48e2-4185-bb76-4c29a22d57e3" class="bulleted-list"><li style="list-style-type:disc">어떤 컴파일러들은 메모리를 통째로 그냥 복사해줌 <code>memcpy()</code></li></ul><h3 id="cd73ca17-8a48-4db7-9bcb-c94905958091" class="">구조체 배열</h3><ul id="9b273139-ba24-489a-b54d-aeadcc57ad37" class="bulleted-list"><li style="list-style-type:disc">구조체를 정말 기본 자료형이랑 다르지 않다고 생각하는게 편함</li></ul><ul id="aba879b2-0a39-41e2-b289-fffaf396f481" class="bulleted-list"><li style="list-style-type:disc">구조체마다 자료 크기가 딱 정해져 있으니 컴파일러가 다른 변수와 똑같이 처리해 줄 수 있음</li></ul><pre id="9e4ebfc6-e535-420e-a732-646464f2cb08" class="code"><code>typedef struct date {
	int year;
	int month;
	int day;
}

/*
int year 크기 + int month 크기 + int day 크기
sizeof(int) + sizeof(int) + sizeof(int)
*/</code></pre><pre id="87eaf33e-fc36-41dd-b48c-1e1b6776b280" class="code"><code>date_t family_birthdates[4];

family_birthdates[0].year = 1950;
family_birthdates[0].month = 1;
family_birthdates[0].day = 2;

family_birthdates[1].year = 1948;
family_birthdates[1].month = 8;
family_birthdates[1].day = 3;

family_birthdates[2].year = 1980;
family_birthdates[2].month = 12;
family_birthdates[2].day = 28;

family_birthdates[3].year = 1984;
family_birthdates[3].month = 4;
family_birthdates[3].day = 1;

size_t i;

for (i = 0; i &lt; LENGTH; ++i) {
	printf(&quot;%d-%d-%d\n&quot;, family_birthday[i].year, family_birthday[i].month, family_birthday[i].day);
}</code></pre><ul id="f8a484a8-10b1-4bba-96a9-000282338b99" class="bulleted-list"><li style="list-style-type:disc">요소 하나의 크기 : <code>sizeof(int) + sizeof(int) + sizeof(int)</code> = 12<pre id="1b45dd00-2bcf-4b18-9a1d-06fff44944b5" class="code"><code>size_t s;
s = sizeof(family_birthdates[0]);

size_t gap;
gap = (char*)&amp;family_birthdates[1] -(char*)&amp;family_birthdates[0];</code></pre></li></ul><h3 id="d6a5c60e-492a-4faf-b949-c72f1f3d8552" class="">퀴즈</h3><pre id="7316dfa8-d94d-40f9-b60e-8187a299a6dc" class="code"><code>typedef struct name {
	char* lastname;
	char* firstname;
} name_t;

char firstname[] = &quot;Lulu&quot;;
char lastname[] = &quot;Lee&quot;;

name_t name;
name_t clone;

name.lastname = lastname;
name.firstname = firstname;

clone = name;
name.lastname[0] = &#x27;N&#x27;;

printf(&quot;origin: %s %s\n&quot;, name.firstname, name.lastname);
printf(&quot;clone: %s %s\n&quot;, clone.firstname, clone.lastname);

/*
정답 : 
orgin: Lulu Nee
clone: Lulu Nee
*/</code></pre><ul id="8b56a111-2884-45ab-904e-d447ef69ec16" class="bulleted-list"><li style="list-style-type:disc">포인터 변수에 대입한 값은 주소<pre id="a56e18bf-317b-491c-bc04-08e312505dcd" class="code"><code>clone = name;

=

clone.firstname = name.firstname
clone.lastname = name.lastname;</code></pre></li></ul><ul id="b3ed8e30-a875-48e1-821d-31269b4e35b8" class="bulleted-list"><li style="list-style-type:disc">name과 clone은 둘다 주소로 같은 문자열을 가리키고 있으므로, 하나를 바꾸면 당연히 다른것도 바뀜 → 즉 둘 다 Nee를 가리키고 있음</li></ul><h3 id="0a570a7d-eb0c-4ef8-a10f-f3a661e1cc6a" class="">얕은 복사</h3><p id="78075d8f-24d4-4d88-90d9-cf11c1492cac" class="">위의 퀴즈와 같이 실제 데이터가 아니라 주소를 복사하는 것을 얕은 복사라고 함</p><h3 id="7176436d-e931-4edd-914d-ec0d908684ec" class="">얕은 복사 예제 1 - 포인터 사용</h3><pre id="bb2683ed-3264-4129-a9f0-d3ce840b9800" class="code"><code>name_t names[NUM_NAMES];
FILE* stream;

name[0].firstname = &quot;Teemo&quot;;
name[0].lastname = &quot;Kim&quot;;
name[1].firstname = &quot;Lulu&quot;;
name[1].lastname = &quot;Lee&quot;;

/* 오류 처리 생략 */
stream = fopen(&quot;names.text&quot;, &quot;wb&quot;);

fwrite(names, sizeof(names[0]), NUM_NAMES, stream);
fflush(stream);

fclose(stream);</code></pre><ul id="1ab06e10-ce07-4e48-8ce0-df31cbf389eb" class="bulleted-list"><li style="list-style-type:disc">먼저 파일에 다음과 같은 정보를 적은 후 프로그램 종료</li></ul><pre id="02e2c34b-04f1-4773-af0c-d0e818fa3a8d" class="code"><code>FILE* stream;
size_t read_num;
size_t i;
name_t names[NUM_NAMES];

/* 오류 처리 생략 */
stream = fopen(&quot;names.text&quot;, &quot;rb&quot;);

read num = fread(names, sizeof(names[0]), NUM_NAMES, stream);
for (i = 0; i &lt; read_num; ++i) {
	printf(&quot;%s %s\n&quot;, names[i].firstname, names[i].lastname);
}

fclose(stream);</code></pre><ul id="8818b780-3efe-4884-a6b2-c1598ea949ab" class="bulleted-list"><li style="list-style-type:disc">이번엔 읽는 코드를 짠 후 프로그램 실행</li></ul><ul id="e99df068-3fa9-46f3-a8f7-0e236c925c90" class="bulleted-list"><li style="list-style-type:disc">프로그램 재실행시 문자열이 다른 주소에 저장이 되어 출력시 오류가 발생할 수 있음</li></ul><ul id="6ae0fc36-8fa3-4b85-9e92-96b4796f2f64" class="bulleted-list"><li style="list-style-type:disc">주소는 파일이 돌아갈 때 그 순간의 위치를 나타내기 때문에 다음을 보장할 수 없음</li></ul><ul id="487a3a4a-86b5-4053-a2ac-5d32b1820809" class="bulleted-list"><li style="list-style-type:disc">문제는 포인터임!! 포인터를 없애야함</li></ul><h3 id="6b84086e-3b85-46ca-80b2-912beb921052" class="">얕은 복사 예제 2 - 포인터 사용 X</h3><ul id="2209f871-1371-46c1-8b61-52e960199c8a" class="bulleted-list"><li style="list-style-type:disc">구조체를 배열에 저장하면</li></ul><pre id="6fe615c2-f50b-464d-9983-7917847c6811" class="code"><code>name_t names[NUM_NAMES];
FILE* stream;

const char* firstname1 = &quot;Teemo&quot;;
const char* lastname1 = &quot;Kim&quot;;
const char* firstname2 = &quot;Lulu&quot;;
const char* lastname2 = &quot;Lee&quot;;

strncpy(name[0].firstname, firstname1, NAME_LEN);
names[0].firstname[NAME_LEN - 1] = &#x27;\0&#x27;
strncpy(name[0].lastname, lastname1, NAME_LEN);
names[0].lastname[NAME_LEN - 1] = &#x27;\0&#x27;
strncpy(name[1].firstname, firstname2, NAME_LEN);
names[0].firstname[NAME_LEN - 1] = &#x27;\0&#x27;
	strncpy(name[1].firstname, firstname2, NAME_LEN);
names[0].lastname[NAME_LEN - 1] = &#x27;\0&#x27;</code></pre><pre id="ba7486f7-8938-4e0d-8692-71ad8df7eb60" class="code"><code>/* 오류 처리 생략 */
stream = fopen(&quot;names.text&quot;, &quot;wb&quot;);

fwrite(names, sizeof(names[0]), NUM_NAMES, stream);
fflush(stream);

fclose(stream);</code></pre><pre id="3c5550b2-a261-4254-a9c9-aa35f340b88d" class="code"><code>FILE* stream;
size_t read_num;
size_t i;
name_t names[NUM_NAMES];

/* 오류 처리 생략 */
stream = fopen(&quot;names.text&quot;, &quot;rb&quot;);

read num = fread(names, sizeof(names[0]), NUM_NAMES, stream);
for (i = 0; i &lt; read_num; ++i) {
	printf(&quot;%s %s\n&quot;, names[i].firstname, names[i].lastname);
}

fclose(stream);</code></pre><ul id="55d5fe88-a190-47c8-9c83-fad956e4d8c1" class="bulleted-list"><li style="list-style-type:disc">파일에 저장할 때는 포인터가 없어야 제대로 저장이됨</li></ul><hr id="649de406-bb76-48d4-a7f5-c91a885809e8"/><p id="75aa6874-e171-4be7-b32b-405bc65b00e4" class=""><strong>포인터만 없으면 됨</strong></p><ul id="f2230f82-677a-460e-8af2-5961c3fd8c49" class="bulleted-list"><li style="list-style-type:disc">반드시 그럴 순 없겠지만 가능한 위와 같이 한 덩어리 메모리에 모든 데이터가 들어가고 대입 가능한 구조체를 만드는 것이 좋음</li></ul><ul id="c0e5dab1-4131-495e-85bb-85b986c82412" class="bulleted-list"><li style="list-style-type:disc">즉, 구조체를 구성할 때 데이터가 최대한 포인터가 없는 경우가 좋음</li></ul><hr id="2485dd5d-f3be-40db-a1b9-4797a8b7413b"/><h3 id="94de09c7-98c5-40b0-9971-09da4276cfaf" class="">구조체를 다른 구조체의 멤버로 사용하기 - 패딩(padding)</h3><pre id="42872405-69a5-47c2-a366-c012e0280ba4" class="code"><code>struct user_info {
	unsigned int id;
	name_t name;
	unsigned short height;
	float weight;
	unsigned short age;
};</code></pre><pre id="794fdc2c-a024-45a4-951d-5ddaa1f96f08" class="code"><code>user_info_t user;

user.id = 1234;
strncpy(user.name.firstname, firstname, NAME_LEN);
user.name.firstname[NAME_LEN -1] = &#x27;\0&#x27;;
strncpy(user.name.lastname, lastname, NAME_LEN);
user.name.lastname[NAME_LEN -1] = &#x27;\0&#x27;;
user.height = 1;
user.weight = 20.5f;
user.age = 30;</code></pre><p id="7289a952-55cc-424d-b91a-3962770839c9" class=""><strong>&lt;파일 안 메모리 확인&gt;</strong></p><pre id="2373aff6-7c62-43df-9c95-88f9e84df39d" class="code"><code>struct user_info {
	unsigned int id;          /* 4바이트 */
	name_t name;              /* 64바이트 */
	unsigned short height;    /* 2바이트 */
	float weight;             /* 4바이트 */
	unsigned short age;       /* 2바이트 */
};</code></pre><p id="9e21cd71-ca2a-40c2-a085-7d7527e1fd80" class="">⇒ 예상 총 76바이트</p><pre id="6788453d-c943-4041-af3e-b27c3f2c232e" class="code"><code>user_info_t info;

int off id = (char*)&amp;info.id - (char*)&amp;info;               /* 0 */
int off name = (char*)&amp;info.name - (char*)&amp;info;           /* 4 */
int off height = (char*)&amp;info.height - (char*)&amp;info;       /* 68 */
int off weight = (char*)&amp;info.weight - (char*)&amp;info;       /* 72 */
int off age = (char*)&amp;info.age - (char*)&amp;info;             /* 76 */</code></pre><p id="a08eb8b2-d26a-4e39-bf6d-b500c59467d2" class="">⇒ 실제론 80바이트로 쓰여짐</p><p id="4d347b26-8761-4e08-b05b-1435dda1982a" class=""><strong>&lt;바이트 정렬 요구사항 때문에 구멍이 생김&gt;</strong></p><ul id="34ba018f-0db2-4b0e-85cc-4e732f211d4c" class="bulleted-list"><li style="list-style-type:disc">4바이트를 꽉 채우지 않은 데이터들의 쓸데없는 공간을 차지함</li></ul><ul id="e909ecd9-d819-4236-85b9-3998376c7d25" class="bulleted-list"><li style="list-style-type:disc">각 시스템마다 메모리에 접근할 때 사용하는 주소에 대한 요구사항이 다르게 때문<ul id="22869b7b-f17f-4b48-8c10-86b4f3ec3a9f" class="bulleted-list"><li style="list-style-type:circle">시스템 상의 제약이 있거나</li></ul><ul id="8f40f9e9-2e68-4226-9fac-265d38633ac6" class="bulleted-list"><li style="list-style-type:circle">효율성 때문</li></ul></li></ul><ul id="7c2d2c55-9e52-490c-a4f6-01a5cae4285f" class="bulleted-list"><li style="list-style-type:disc">어떤 시스템은 n바이트 배수인 시작주소에서만 메모리 접근 가능</li></ul><ul id="bf170a89-e924-4172-8663-d331d99df1db" class="bulleted-list"><li style="list-style-type:disc">x86 시스템은 4바이트(워드 크기) 경계에서 읽어오는게 효율적<ul id="845fbaef-38e4-4fd1-99db-f395a1bf69df" class="bulleted-list"><li style="list-style-type:circle">이를 4바이트 경계에서 정렬된다(aligned)고 말함</li></ul></li></ul><ul id="40420cb8-1620-4d96-b417-80214f9011a8" class="bulleted-list"><li style="list-style-type:disc">따라서 컴파일러가 알아서 각 멤버의 세작 위치를 그 경계에 맞춤</li></ul><ul id="6e481d6f-713d-49b0-aac1-c93f464d2b97" class="bulleted-list"><li style="list-style-type:disc">그러기 위해 안 쓰는 바이트를 덧 붙임 <strong>(padding)</strong></li></ul><ul id="c47ba562-f637-4d93-86c0-a48d858edd60" class="bulleted-list"><li style="list-style-type:disc">32비트 clang 윈도우는 4바이트 정렬을 하려고함</li></ul><ul id="753620b7-370f-477e-a8f2-b8fca16b096d" class="bulleted-list"><li style="list-style-type:disc">따라서 어떤 아키텍쳐에서 저장한 파일이 다른 아키텍쳐에서 읽으면 잘못 읽힐 수 있음</li></ul><p id="ae2ee11e-0fe5-4dbe-80ab-a674edfb9319" class=""><strong>&lt;패딩 줄이기&gt;</strong></p><ul id="231716a7-e2f6-4f43-b2d2-2d5ae1877229" class="bulleted-list"><li style="list-style-type:disc">2개의 <code>short</code>형 변수를 4바이트로 합체</li></ul><pre id="58a42cc5-bff1-4af9-9ead-cacab1f356fd" class="code"><code>struct user_info {
	unsigned int id;          /* 4바이트 */
	name_t name;              /* 64바이트 */
	unsigned short height;    /* 2바이트 */
	float weight;             /* 4바이트 */
	unsigned short age;       /* 2바이트 */
};

/* 아래와 같이 2바이트끼리 묶어주는 것 만으로도 없어짐 : 크기도 76 */

struct user_info {
	unsigned int id;          /* 4바이트 */
	name_t name;              /* 64바이트 */
	unsigned short height;    /* 2바이트 */
	unsigned short age;       /* 2바이트 */
	float weight;             /* 4바이트 */
};</code></pre><ul id="9fe1b37d-8bbb-4557-aeff-8a91f3229f34" class="bulleted-list"><li style="list-style-type:disc"><code>#pragma pack</code><pre id="2203449d-56f8-44fa-b11a-f53021be725f" class="code"><code>#pragma pack(push, 1)
typedef struct {
	unsigned int id;
	name_t name;
	unsigned short height; 
	float weight;
	unsigned short age;
} user_info ;
#pragma pack(pop)

/* sizeof(user_info ) 76 */</code></pre><ul id="88815599-2541-4042-bf92-d88db227598b" class="bulleted-list"><li style="list-style-type:circle">76바이트 메모리 크기가 나옴</li></ul><ul id="d2270fed-809b-40e5-907e-cf3d410a87a1" class="bulleted-list"><li style="list-style-type:circle">그러나 표준은 아님 → 요즘 컴파일러들이 잘 지원해주는 것일 뿐</li></ul></li></ul><h3 id="bd8b01f3-9ed0-40a0-850b-1e34902f5539" class="">구조체 베스트 프랙티스</h3><ul id="6b266561-b84a-4870-ada7-e18d98d9e7c1" class="bulleted-list"><li style="list-style-type:disc">구조체를 파일이나 다른데 저장해야 해서 바이트 크기가 정확히 맞아야 한다면?<ul id="bfb512cf-41b3-454c-bead-db53cea3791d" class="bulleted-list"><li style="list-style-type:circle">보통 <code>assert()</code>를 사용해서 크기를 확인<pre id="0e1dc6f6-8f86-44d4-b1e9-871bab0fa46f" class="code"><code>#include &lt;assert.h&gt;
assert(sizeof(user_info_t) == 76);</code></pre></li></ul></li></ul><ul id="be80ebd8-cf1c-4a91-9b1b-01804735e7bf" class="bulleted-list"><li style="list-style-type:disc">어쩔 수 없이 패딩이 생길 거라면 구조체에 패딩을 명시적으로 넣기도 함<pre id="23887936-a987-476a-ad8a-5bf1499a985a" class="code"><code>typedef struct {
	unsigned int id;
	name_t name;
	float weight;
	unsigned short height;      
	unsigned short age;
	char unused[2];
} user_info_t;</code></pre><p id="c6be8a93-8cce-4bd2-8871-0a8082d7519d" class="">⇒ 특히 데이터의 전체 크기가 4바이트로 안 나눠 떨어질 때</p></li></ul><h3 id="8c217951-987a-483b-a34f-cb49d7c1ed05" class="">구조체 - 비트 필드</h3><p id="bdc3ac74-45d5-454f-92e3-3d7283aad3ed" class=""><strong>&lt;비트 플래그&gt;</strong></p><ul id="b5406420-9c6a-4e12-b9cd-3fc34de6e9a1" class="bulleted-list"><li style="list-style-type:disc">8개 이하의 <code>bool</code>값을 하나의 byte에 저장하는 방법</li></ul><ul id="9962de36-e0c4-4d86-85ce-037602055301" class="bulleted-list"><li style="list-style-type:disc">C#에는 <code>bool</code>형이 있지만 C는 없으니 <code>int</code>형</li></ul><ul id="78a9f8bd-880b-473f-88d5-345e7f2fa5fb" class="bulleted-list"><li style="list-style-type:disc">원래 8 x 4 = 32바이트이지만 1바이트(8 x 1비트)로 사용하니 더 효율적임</li></ul><p id="604fb3cd-8c16-44ee-9b0d-804be55aeb59" class=""><strong>&lt;구조체와 비트플래그&gt;</strong></p><ul id="b927af56-b3d9-4196-a915-0e6e82a2178f" class="bulleted-list"><li style="list-style-type:disc">C에서 구조체를 사용하면 매우 간단히 비트플래그를 구현할 수 있음</li></ul><pre id="11517156-73ee-4fa6-ab76-b755b7ef77a0" class="code"><code>typedef struct {
	unsigned char b0 : 1;
	unsigned char b1 : 1;
	unsigned char b2 : 1;
	unsigned char b3 : 1;
	unsigned char b4 : 1;
	unsigned char b5 : 1;
	unsigned char b6 : 1;
	unsigned char b7 : 1;
} bitflags_t;

/* sizeof(bitflags_t) = 1 */</code></pre><p id="8b144313-95bd-4ace-aed3-f52f1da14748" class=""><strong>⇒  </strong><strong><code>: 1</code></strong><strong> : char 1바이트가 아닌 1비트로만 쓰겠다는 것을 의미함 </strong></p><p id="488dbb91-8795-480c-a1ad-6dd427ea827c" class=""><strong>&lt;비트 플래그 구조체 사용 예&gt;</strong></p><ul id="c6203579-9b60-428c-82dd-12c4f8447777" class="bulleted-list"><li style="list-style-type:disc">b3 : 4번째(1, 2, 4, 8)이므로 08이 들어감</li></ul><p id="9d73e17e-b5a1-40f6-a26a-c93177c752df" class=""><strong>&lt;플래그 전체 체크&gt;</strong></p><pre id="406a6d61-dda2-4ae1-b79e-119f4a466526" class="code"><code>int is_set = (flags.b1 == 1);                 /* OK */
int is_same = (flags.b1 == flags.b7);         /* OK */
int is_all = (flags == 0xFF);                 /* 컴파일 오류 */
int is_zero = (flags == 0);                   /* 컴파일 오류 */</code></pre><ul id="bb44dbf1-c978-4fcc-9f47-4748c3fde5d9" class="bulleted-list"><li style="list-style-type:disc">지금 방식은 <strong>멤버 함수들끼리 비교만 가능</strong></li></ul><ul id="4d469dbd-5095-4da7-bb22-26e168d2e42a" class="bulleted-list"><li style="list-style-type:disc"><strong>구조체 전체가 0(모든 플래그가 거짓)인지 비교는 안됨</strong><p id="c8f8d2cf-51c9-418c-8121-0330d283e9a1" class="">→ <strong>하지만 포인트를 사용하면 가능함 </strong><code><strong>(char*)%flags</strong></code></p></li></ul><pre id="e1923d44-5228-4772-b214-1d4ac1a999ac" class="code"><code>char* val;
int is_zero;
bitflag_t flags = { 0, };

flag.b3 = 1;

val = (char*)&amp;flags;
is_zero = (*val == 0); /* 0 */</code></pre><p id="b6df6ad5-697c-49cf-bbc4-4c6bc0814e86" class="">⇒ 이를 좀더 제대로 해주는 C언어 기능이 있음 → <strong>공용체</strong></p><h2 id="469d8959-6b02-4ba9-8b47-000ff73e256a" class="">공용체</h2><p id="c0a0e234-8145-4b12-9ca4-4edbf8bdac5f" class="">⇒ <strong>어떤 메모리를 어떻게 읽을건가에 대한 내용과 관련이 있음</strong></p><ul id="377ce8ae-ca87-47d7-a5b0-fb397da0eeea" class="bulleted-list"><li style="list-style-type:disc">똑같은 메모리 위치를 다른 변수로 접근하는 방법</li></ul><ul id="8ee7acd6-0641-4822-891c-cc73f9a2737d" class="bulleted-list"><li style="list-style-type:disc">즉, 공용체 안에 있는 여러 변수들이 같은 메모리를 공유</li></ul><pre id="b372ff10-eff7-4127-bceb-fb4fc10936b0" class="code"><code>typedef union {
	unsigned char val;
	struct {
		unsigned char b0 :1;
		unsigned char b1 :1;
		unsigned char b2 :1;
		unsigned char b3 :1;
		unsigned char b4 :1;
		unsigned char b5 :1;
		unsigned char b6 :1;
		unsigned char b7 :1;
	} bits;
} bitflags_t</code></pre><pre id="d47b5872-05b0-45eb-aa5c-8992a21dc6b8" class="code"><code>int is_same;
int is_zero;
bitflags_t flags = { 0, };

flags.bits.b1 = 1;
flags.bits.b4 = 1;

is_same = (flags.bits.b1 == flags.bits.b7);
is_zero = (flags.val == 0); /* 0 */</code></pre><h3 id="b1e9624f-2959-4157-815c-af33d83fb67b" class="">val로도 bits로도 접근이 가능함</h3><ul id="122ccdb8-48c7-48df-9378-f3f8a829f82f" class="bulleted-list"><li style="list-style-type:disc">동일한 메모리를 두 개의 서로 다른 자료형으로 접근</li></ul><ul id="413046e0-04de-4d42-8a72-cd15782eb35e" class="bulleted-list"><li style="list-style-type:disc">그러나 그 메모리 안에 있는 값은 동일함</li></ul><h3 id="43ce4316-ca35-4ce1-af75-c43719505a73" class="">메모리 공유만 위한 공용체의 예</h3><pre id="08d7f116-f471-44da-aa7d-01780a833bd0" class="code"><code>typedef union {
	int ivalue;
	double dvalue;
} value_t;</code></pre><ul id="514ab494-b9a0-42e9-9404-a48e30cbafff" class="bulleted-list"><li style="list-style-type:disc">한 메모리 공간을 용도에 따라 다른 기본 데이터형으로 읽을 때 사용</li></ul><ul id="607b21cb-db72-4c48-a092-74d8a640e449" class="bulleted-list"><li style="list-style-type:disc">앞의 예보다 덜 유용</li></ul><ul id="87d1685d-9611-4152-bdaf-6e284448a2da" class="bulleted-list"><li style="list-style-type:disc">사용하기도 어렵고 실수가 쉬움</li></ul><pre id="08dfe32c-896e-4527-8150-74c9f718d243" class="code"><code>value_t op1;
value_t op2;
value_t result;

op1.ivalue = 55;
op2.ivalue = 27;
result = calculate(op1, op2, OP_INTADD);

op1.dvalue = 10.3453;
op2.dvalue - 53.24753;
result = calculate(op1, op2, OP_BOUBLEADD);
</code></pre><pre id="506e08eb-d6c8-4e14-95ec-aae3f0a6e4cd" class="code"><code>value_t calculate(value_t lhs, value_t rhs, op_t op)
{
	value_t result;

	if {op == OP_INTADD) {
		result.ivalue = lhs.ivalue + rhs.ivalue;
	} else if (op == OP_DOUBLEADD) {
		result.dvalue = lhs.dvalue + rhs.dvalue;
	} else {
		assert(0);
	}

	return result;
}</code></pre><ul id="5f5a178c-8840-42e8-9a17-020fd559abaf" class="bulleted-list"><li style="list-style-type:disc">서로 부분이 되는 것이 아닌 전혀 다른 메모리 공유</li></ul><h3 id="60dba331-17b4-4ac7-ba64-9ca3f367a822" class="">퀴즈</h3><p id="c6baf0fa-004a-4bbe-a798-822b8ab31da5" class="">다음 공용체에 대한 질문에 답하세요.</p><p id="c76dcc9a-7908-490d-8adf-98d456f31d70" class="">위 공용체의 크기로 올바른 것을 고르세요</p><p id="06c1c788-e650-41a8-b608-24aaf294f9d4" class="">(각 기본 자료형의 크기는 <code>sizeof(int)</code>= 4, <code>sizeof(float)</code> = 4, <code>sizeof(double)</code> = 8, <code>sizeof(char)</code> = 1, <code>sizeof(short)</code> = 2, 패딩은 없다고 가정)</p><pre id="68a98a18-61c1-4211-9a5c-7608b2458269" class="code"><code>typedef union {
    int ivalue;
    float fvalue;
    double dvalue;
    char cvalue;
    short svalue;
} value_t;

/* 정답 : 8 */</code></pre><h2 id="03706054-beac-4dd6-9dbb-25e622cf210f" class="">함수 포인터</h2><h3 id="a556bdb8-6830-417e-80d7-69fb8f0c8b3c" class="">switch문을 사용한 사칙연산 프로그램</h3><pre id="80c91b34-fe08-45ec-afe5-de9fc46cb2ab" class="code"><code>/* caclulator.h */

double add(double, double);
double sub(double, double);
double mul(double, double);
double div(double, double);

/* calculator.c */

double add(double x, doublt y)
{
	return x + y;
}
double sub(double x, doublt y)
{
	return x - y;
}
double mul(double x, doublt y)
{
	return x * y;
}
double div(double x, doublt y)
{
	return x / y;
}

/* main.c */

double op1 = 10.234;
double op2 = 3.521;
double result;
char op = &#x27;+&#x27;

/* 입력 받을 코드 생략 */

switch (op) {
case &#x27;+&#x27;:
	result = add(op1, op2)
	break;
case &#x27;-&#x27;:
	result = sub(op1, op2)
	break;
case &#x27;*&#x27;:
	result = mul(op1, op2)
	break;
case &#x27;/&#x27;:
	result = div(op1, op2)
	break;
default:
	fputs(&quot;Unknown op!&quot;, stderr);
{</code></pre><h3 id="cbc770c5-e75a-4a96-a396-5d1ef5fc20e9" class="">switch문 외에 다른 방법이 없을까?</h3><ul id="8e05c5ad-d3ab-4cd4-946e-f9b21f919d13" class="bulleted-list"><li style="list-style-type:disc">피연산자 2개, 함수 시그니처 비슷 → 유일하게 다른 점은 함수 이름 정도</li></ul><pre id="26dfee32-2a10-4deb-85ef-bac615b90c20" class="code"><code>result = calculator(op1, op2, operater); /* operator - add() */
result = calculator(op1, op2, operater); /* operator - sub() */
result = calculator(op1, op2, operater); /* operator - mul() */
result = calculator(op1, op2, operater); /* operator - div() */
</code></pre><ul id="6c49b623-a5e1-49a0-a53b-5c1f7dc8a6be" class="bulleted-list"><li style="list-style-type:disc">언제나 변하는 피연한자를 매개변수로 전달하듯이 함수도 어디다 저장해둔 뒤 매개변수로 전달할 수 없을까?</li></ul><h3 id="5d52e74f-c6fc-4995-99e6-3d11cf530b65" class="">함수를 변수에 저장할 수 있을까?</h3><ul id="8ab40890-af70-42e3-810a-c02a5477e178" class="bulleted-list"><li style="list-style-type:disc">어떤 함수를 호출할 때 직접 함수명을 씀<pre id="1f1ac978-873f-40cc-a040-54dd2da6218f" class="code"><code>result = sub(op1, op2);</code></pre></li></ul><ul id="f6c4de52-97f1-4d3f-99a9-9e0bacd7fcfc" class="bulleted-list"><li style="list-style-type:disc">그러나 어셈블리어로는 <strong>그 함수의 주소</strong>로 점프</li></ul><ul id="b76dcc2b-434c-4142-b60a-48f38a631633" class="bulleted-list"><li style="list-style-type:disc">실행 도중에 함수에서 반활할 때 돌아가야할 호출자 코드의 주소, 즉 돌아가야할 주소는 스택 메모리에 저장되어 있음<p id="4fd170eb-207f-43a3-9b55-c57d72446909" class="">⇒ 어셈블리어가 저장해주는 것이 아닌 실행할 때마다 바뀜</p></li></ul><ul id="67ba4d57-1841-4ed7-8016-93f9d86576a3" class="bulleted-list"><li style="list-style-type:disc">실행 도중 조건에 따라 어떤 함수를 실행해주려면 그 함수의 시작 주소를 변수에 기억해야함</li></ul><h3 id="b53edc3c-de61-4b7d-ba91-93e1bc34311f" class="">함수를 매개변수로 전달할 때 필요한 것들</h3><pre id="1cdaa3d3-474a-4ba2-b838-2efc103f0eb0" class="code"><code>double calculator(double, double, 매개변수로_전달된_함수*);</code></pre><p id="cc8e4a57-dfa2-4d60-b988-741e6c5a1959" class="">⇒ 앞의 두 <code>double</code>은 <code>calculator()</code>의 <code>매개변수지 매개변수로_전달된_함수</code>의 매개변수가 아님</p><ul id="dcdfa735-30b2-485b-94bf-3392e59a348a" class="bulleted-list"><li style="list-style-type:disc">매개변수로 전달된 함수가 무사히 실행되려면 그 함수에서 쓸 매개변수가 스택에 들어가 있어야 함</li></ul><ul id="214ad8a4-1307-4103-8414-c80561193605" class="bulleted-list"><li style="list-style-type:disc">또한 반환값이 있다면 어떻게 가져다 써야하는지 모름</li></ul><ul id="1632a707-f5ff-4878-b744-04b6a332cae3" class="bulleted-list"><li style="list-style-type:disc">즉, 함수를 매개변수로 전달하기 위해서는 다음의 정보가 필요함<p id="77d462a0-9d24-48c6-8759-7c6ceb0f6c2a" class=""><strong>1) 자기 자신이 받아야하는 매개변수 목록</strong></p><p id="a26792c8-84de-49c0-9f59-13dfe27cffe1" class=""><strong>2) 자기 자신이 반환하는 자료형</strong></p></li></ul><pre id="54157936-e465-4eb1-972a-fb3ef878c20f" class="code"><code>double add(double x, double y)
{
	return x + y;
}

/* 함수 포인터 변수의 선언과 사용 */
double (*func)(double, double) = add;
result = func(op1, op2);

/* 함수 포인터 매개변수의 선언과 사용 */
double calculate(double, double, double (*)(double, double));           /* 매개변수 이름 생략 가능 */
double calculate(double x, double y, double (*func)(double, double))    /* 실제 구현 */
{
	return func(x, y);
}
result = calculate(op1, op2, add);</code></pre><h3 id="1c3ff9ce-75b0-4763-a920-0383e9c789ef" class="">함수 포인터 선언</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="236349bf-3b43-4641-bc3f-43c9b5fe8740"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>&lt;반환형&gt; (*&lt;변수명&gt;)(&lt;매개변수 목록&gt;);</strong></div></figure><ul id="2225b889-faa9-414b-8062-52149bf675b8" class="bulleted-list"><li style="list-style-type:disc"><strong>함수의 시작 주소를 저장하는 변수</strong></li></ul><ul id="b842a8ec-85d3-417d-a702-6e7b9ee4006e" class="bulleted-list"><li style="list-style-type:disc">함수의 매개변수 목록과 반환형을 반드시 표기해야함</li></ul><h3 id="2e96d3f9-c6c7-47eb-8716-18cbefb168b4" class="">함수 포인터 읽는 방법</h3><p id="de509cd3-64c0-4b8b-829b-085b3f18e200" class="">⇒ 오른쪽-왼쪽 규칙(Right-Left Rule)이라고도 함</p><pre id="3e5c92f0-95db-43b6-b6c4-3d7a325418f8" class="code"><code>double (*func)(double, double)</code></pre><ul id="9a212b17-66dd-4fe5-b57d-d08259733bb1" class="bulleted-list"><li style="list-style-type:disc">변수 <code>func</code>는 두개의 <code>double</code>형 매개변수를 받고 <code>double</code>형을 반환하는 함수의 포인터</li></ul><pre id="ec63ff97-ce5a-4742-ae40-36e416064f38" class="code"><code>void (*func)(int)</code></pre><ul id="0541bb8f-592c-4a0c-96c2-c126924037a9" class="bulleted-list"><li style="list-style-type:disc">변수 <code>func</code>는 한개의 <code>int</code>형 매개변수를 받고 반환값이 없는 함수의 포인터</li></ul><h3 id="9dd5c3f5-f666-4548-8d1d-3fe54278b132" class="">정리</h3><pre id="8a81f358-99b9-4329-b6e2-2ea26327b83b" class="code"><code>double calculate(double, double, double (*)(double, double)); </code></pre><ul id="0f20ec71-d7c0-4f04-bf70-f74846942785" class="bulleted-list"><li style="list-style-type:disc">함수 <code>calculator()</code>는<ul id="51a72955-3363-4732-8022-d3d70ba5b77e" class="bulleted-list"><li style="list-style-type:circle">총 3개의 매개변수<p id="6acd6574-95c5-45c2-af5b-04b72dc67642" class="">1) <code>double</code>형</p><p id="05143613-4337-49f1-b997-71e99b72f160" class="">2) <code>double</code>형</p><p id="906a24ed-16d3-4c30-8394-9ce34b86e98b" class="">3) 함수 포인터<div class="indented"><p id="b0ceb4ef-9813-44b6-8509-3cc8fd2e6e23" class="">⇒ 두 개의 <code>double</code>형 매개변수를 받고 <code>double</code>형을 반환하는 함수의 포인터</p></div></p></li></ul><ul id="d34eb803-ea69-4435-9586-06d1edee58cf" class="bulleted-list"><li style="list-style-type:circle">반환형은 <code>double</code>형</li></ul></li></ul><pre id="054ba916-7f7b-4a5b-83d3-9e0fdf454e5d" class="code"><code>int (*ops[])(int, int) = { add, sub, mul, div };</code></pre><ul id="ffcdeda0-aedc-441d-bda1-bcfbb1788567" class="bulleted-list"><li style="list-style-type:disc">배열 또한 오른쪽-왼쪽 법칙을 사용해서 읽을 수 있음</li></ul><ul id="17c5a1b5-02c2-4cba-b7e0-4aec73187a96" class="bulleted-list"><li style="list-style-type:disc">ops는 배열<ul id="363e0f47-f0bb-4e30-9f0e-4f79455047f3" class="bulleted-list"><li style="list-style-type:circle">배열의 각 요소는 함수 포인터<p id="b3497c1c-1936-414b-ba94-3484cc99db40" class="">1) 두 개의 <code>int</code>형 매개변수</p><p id="463ecb66-f177-4db0-945f-68ddd576003a" class="">2) <code>int</code>형을 반환</p></li></ul></li></ul><pre id="c8daff77-2967-45ce-b594-1540245f4f51" class="code"><code>void (*bsd_signal(int, void (*)(int)))(int);</code></pre><ul id="0d7a8e13-1f71-47f1-8c85-9ebfbe08a691" class="bulleted-list"><li style="list-style-type:disc"><code>bsd_signal</code> 함수의 선언<ul id="1402c741-8bce-4f96-9c08-595e201dd471" class="bulleted-list"><li style="list-style-type:circle">매개변수<ul id="476d0919-42f0-492e-a371-4039b39ca45e" class="bulleted-list"><li style="list-style-type:square"><code>int</code> 형</li></ul><ul id="b71a879b-a0b3-45ae-b407-398440011beb" class="bulleted-list"><li style="list-style-type:square">함수의 포인터 : <code>void (*)(int)</code></li></ul></li></ul><ul id="677998ed-d580-49de-9d28-83551e0213f0" class="bulleted-list"><li style="list-style-type:circle">반환형<ul id="f9ac8d36-b0c3-4c38-bd83-77f3808fb681" class="bulleted-list"><li style="list-style-type:square">함수 포인터 : <code>void (*)(int)</code></li></ul></li></ul></li></ul><h3 id="d1b55bf4-670c-416b-b865-32d8e3bc3f7a" class="">콜백 함수</h3><pre id="0e819708-dc5e-4400-9f28-cc423c75822f" class="code"><code>/* error_handler.h */

#ifndef ERROR_HANDLER_H
#define ERROR_HANDLER_H

void register_error_handler(void (*handler)(const char* msg));
void (log_error(const char* msg);

void defaut_error_handler(const char* msg);

#endif /* ERROR_HANDLER_H */

/* error_handler.c */

#define _CRT_SECURE_NO_WARNINGS

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#include &quot;error_handler.h&quot;

static void (*s_handler)(const char*) = NULL;

void register_error_handler(void (*handler)(const char* msg))
{
	s_handler = handler;
}

void log_error(const char* msg)
{
	if (s_handler != NULL) {
		s_handler(msg);
	}
}

void default_error_handler(const char* msg)
{
	time_t now;
	struct tm* local;

	now = time(NULL);

	local = localtime(&amp;now);

	fprintf(stderr, &quot;[#02d:%02d:%02d] %s\n&quot;, local-&gt;tm_hour, local-&gt;tm_min, local-&gt;tim_sec, msg);
}

/* main.c */

#define _CRT_SECURE_NO_WARNINGS

#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

#include &quot;error_handler.h&quot;

#define TRUE (1)
#define FALSE (0)

void simple_stderr_print(const char* msg));
int run(void);

int main(void)
{
	int success;

	success = run();

	register_error_handler(default_error_handler);
	if (run() == FALSE) {
		success = FALSE;
	}
}

int run(void)
{
	int numerator;
	int denominator;

	while (TRUE) {
		pirntf(&quot;endter numerator: &quot;);
		if (scanf(&quot;%d&quot;, &amp;numerator) == 1) {
			break;
		}
	}

	while (TRUE) {
			pirntf(&quot;endter denominator: &quot;);
			if (scanf(&quot;%d&quot;, &amp;denominator) == 1) {
				break;
			}
		}

	if (denominator == 0) {
		log_error(&quot;cannot divide by zero&quot;);
		return FALSE;
	}

	printf(&quot;%d / %d = %02f\n&quot;, numerator, denominator, numerator / (float)denominator);

	return TRUE;
}
	
void simple_stderr_print(const char*msg)
{
	fputs(msg, stderr);
}</code></pre><h3 id="80d6df05-fbde-4574-926c-f71f52f99a87" class="">배열의 포인터</h3><pre id="03a1745f-c532-4267-ac30-5437de84db38" class="code"><code>int scores[3] = { 80, 90, 100 };
int* p = scores;</code></pre><ul id="b50ffb0d-f969-4d64-9151-a5ec4cb30b1e" class="bulleted-list"><li style="list-style-type:disc">p는 scores[0]을 가리키고 있음</li></ul><pre id="c9346153-baa0-4576-8f25-f24a2e10c277" class="code"><code>int scores[3] = { 80, 90, 100 };
int(*p)[3] = &amp;scores;      /* OK */</code></pre><pre id="baca22a2-c60a-4bce-b066-8828285df705" class="code"><code>int scores[5] = { 11, 22, 33, 44, 55 };
int(*p)[3] = &amp;scores;      /* 컴파일 오류 */</code></pre><ul id="def59f52-b9c6-4cd9-85b6-42e28a9237f8" class="bulleted-list"><li style="list-style-type:disc">배열 전체를 다 가리키는 포인터도 있음</li></ul><ul id="e3308aec-94bb-4e32-983d-925a987b242f" class="bulleted-list"><li style="list-style-type:disc">이것이 바로 배열의 포인터</li></ul><ul id="ddf2f506-f14f-48e7-853c-2d69c8aa57b6" class="bulleted-list"><li style="list-style-type:disc">영어로 pointer to array</li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1bf5ec67-83bd-4569-8d0e-e2fab746478b"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>&lt;자료형&gt; (*&lt;변수이름&gt;)[&lt;요소의 수&gt;];</strong></div></figure><ul id="3cc10f21-dd4d-4f3b-9c80-2c9567e5cce1" class="bulleted-list"><li style="list-style-type:disc">어디에 쓸지는 정말 모르겠고 사실 거의 쓰는 경우는 없음</li></ul><ul id="6fb5fc23-7730-4124-ad75-b66a2b55db6a" class="bulleted-list"><li style="list-style-type:disc">단, 2차원 배열을 매개변수로 받을 때 쓸 수 있음<ul id="f9c5f5ad-5375-4663-930c-253afc011813" class="bulleted-list"><li style="list-style-type:circle">1차원 배열의 2번째 요소에 접근할 때,</li></ul><ul id="627c9f0c-3a79-4fe9-b88c-391db7d7c1ed" class="bulleted-list"><li style="list-style-type:circle">arr[1]로도 쓰지만 arr + 1도 된다고 했음</li></ul><ul id="f222aa22-d9a9-4a17-88e5-264960f790c7" class="bulleted-list"><li style="list-style-type:circle">그럼 2D 배열은? arr[1][2] == *(*(arr + 1) + 2 )</li></ul></li></ul><pre id="31bc786c-442e-4bda-a59b-f780188e1b9f" class="code"><code>void do_magic(int matrix[][10], size_t m)
{
	/* 테스트를 위해 하나만 출력 */
	printf(&quot;m[1][2]: %d&quot;, *(*(matrix  + 1) + 2 ));
}

int main(void)
{
	int matrx[5][10] = {
		{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
		{ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 }, 
		{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
		{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
		{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
	};

	do_magic(matrix, 5);
}</code></pre><pre id="ab5c6b57-2dc0-46d8-a62c-d9b5e4535435" class="code"><code>m[1][2]: 13
_</code></pre><h3 id="18f74e20-8a85-4bce-aa12-c065fb824db6" class="">함수 포인터 : 퀵 정렬</h3><pre id="faf223fa-e3e3-4f14-91ab-de89e2f1b622" class="code"><code>void qsort(void *ptr, size_t count, size_t size, int (*comp)(const void*, const void*));</code></pre><ul id="0c028a95-1cea-449d-a7a1-2c421ebb1bd3" class="bulleted-list"><li style="list-style-type:disc"><code>&lt;stdlib.h&gt;</code> 안에 있는 함수 포인터를 받는 표준 라이브러리 함수</li></ul><ul id="a2b130c3-b8ea-4d12-90fc-2b898a345b2c" class="bulleted-list"><li style="list-style-type:disc">실행속도 : O(NlogN)</li></ul><ul id="cc26e906-d851-4c5b-99a2-fba53c7cacfb" class="bulleted-list"><li style="list-style-type:disc">어떤 데이터라도 처리 가능</li></ul><ul id="df8179fb-2dda-4640-8fa7-a20f38fc6b88" class="bulleted-list"><li style="list-style-type:disc">자료마다 정렬하는 기준이 다를 수 있음<ul id="6ffcd22c-e645-4a7b-ae51-b102b3fba71a" class="bulleted-list"><li style="list-style-type:circle">그 기준마다 정렬함수를 넘겨주기 위한 세 번째 인자가 존재</li></ul><pre id="d226f660-7c3d-40db-a1c2-b011e28a9107" class="code"><code>int (*comp)(const void*, const void*)</code></pre></li></ul><h3 id="d903f3d5-fc58-4f2c-82e1-5a219ed9acf5" class="">void*</h3><ul id="ea85f2ba-c710-4996-94ed-64a5acfe41f9" class="bulleted-list"><li style="list-style-type:disc">범용적 포인터</li></ul><ul id="a3bcf354-93fa-4907-b794-2a6f2166e7ae" class="bulleted-list"><li style="list-style-type:disc">어떤 포인터라도 여기에 대입 가능<ul id="1c362ff5-631e-4547-9060-e62f1387fd01" class="bulleted-list"><li style="list-style-type:circle">그 반대로 그냥 대입 가능</li></ul><ul id="9bad089e-71d3-4978-8b97-8e9b9acd6473" class="bulleted-list"><li style="list-style-type:circle">따라서 어떤 변수의 주소라도 곧바로 대입 가능</li></ul><ul id="5919a011-bd90-4109-bcf3-471bffddb416" class="bulleted-list"><li style="list-style-type:circle">매개변수 형으로 <code>void*</code>를 사용하면 어떤 포인터라도 받을 수 있는 함수 탄생</li></ul></li></ul><ul id="db2f440b-0e70-4fe4-b876-cf11937ae098" class="bulleted-list"><li style="list-style-type:disc">단, 다음과 같은 경우 다른 포인터로 캐스팅 또는 대입해서 써야함<ul id="81dc9798-9d63-4ae4-93a0-e103a7b53322" class="bulleted-list"><li style="list-style-type:circle">역 참조 (몇 바이트 읽을지 모르기 때문)</li></ul><ul id="0da1fa4e-2893-4783-a75b-bce7bc9206ab" class="bulleted-list"><li style="list-style-type:circle">포인터 산술 연산 (몇 바이트를 이동할지 모르기 때문)</li></ul><pre id="0228de9c-a7b4-43ab-a124-c79deea9f28e" class="code"><code>float pi = 3.14f;
void* p;
float* q;

p = &amp;pi;
q = p;

printf(&quot;%f\n&quot;, *p);                      /* 컴파일 오류 */
printf(&quot;%f\n&quot;, *(float*)p);</code></pre><pre id="68a5d4d0-9b5d-4213-a228-27c94162d871" class="code"><code>int add(void* op1, void* op2)
{
	int result;
	result = *op1 + *op2;                  /* 컴파일 오류 */
	result = *(int*)op1 + *(int*)op2;      /* OK */ </code></pre></li></ul></div></article></body>

{% endblock post_content %}