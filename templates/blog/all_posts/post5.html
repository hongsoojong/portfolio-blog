{% extends 'blog/all_posts/base_post.html' %}

{% load static %}

{% block post_title %}
    <a href="{% url 'blog:all-posts' %}" class="font_kor">(4) C 프로그램의 빌드 과정</a>
{% endblock post_title %}

{% block post_content %}

{% block post_date %}
    <div class="container w-1/2 mx-auto mb-10 post_date">[ Sept 13, 2021 ]</div>    
{% endblock post_date %}

<main class="container w-1/2 mx-auto font_kor">

{% include "blog/all_posts/css_post.html" %}
  
<!-- notion html -->
<body><article id="84d5acb8-b938-4510-8d76-a3a32735b7dc" class="page sans"><div class="page-body"><h2 id="f5006429-e5fc-4615-89a1-c97446ddc626" class="">빌드(build)</h2><ul id="e989ffad-beae-40e8-856c-695dc1b666bb" class="bulleted-list"><li style="list-style-type:disc">사람이 읽기 쉬운 소스코드를 기계어 명령어로 변환하는 과정</li></ul><ul id="ad5bc71f-417e-445c-bb78-e644adc8a575" class="bulleted-list"><li style="list-style-type:disc">그 명령어들을 모아 기계에서 실행 가능한 실행파일로 만드는 과정</li></ul><ul id="86fab95d-baba-4861-8b7c-724210404472" class="bulleted-list"><li style="list-style-type:disc">C의 빌드는 4단계로 나뉘어짐<p id="98e661d7-f5fe-49d0-8181-4bc0bdb6133d" class="">1) 전처리 (preprocessing)</p><p id="fc06bc55-111c-4665-8735-f7573c2c2fb7" class="">2) 컴파일 (compilation)</p><p id="3d07b30b-e6cb-4045-9f3b-b04ce3eded66" class="">3) 어셈블 (assembling)</p><p id="bc81323d-1d8d-4865-860e-b681f4515603" class="">4) 링크 (linking)</p><p id="c25ba7f5-1521-4ba9-827b-26f43936d582" class="">⇒ 전처리/컴파일/어셈블을 하나로 묶어 컴파일이라고도 함</p></li></ul><ul id="0da06760-527b-4dd3-b84d-3bd211093960" class="bulleted-list"><li style="list-style-type:disc">보통 아래와 같이 빌드를 함<pre id="9fe79c36-6911-465b-ae4e-e4ff6a792fd7" class="code"><code>&gt; clang -std=c89 -W -Wall -pedantic-errors *.c</code></pre><p id="a918de90-62f5-4194-8223-4fbb7098a984" class="">⇒ 그러면 clang이 알아서 모든 4단계를 실행해 줌<div class="indented"><p id="a8c2c8aa-5d17-477d-90dc-bf0e73b06311" class="">결과는 최종 실행파일(.exe, .out)</p></div></p></li></ul><h2 id="132b4831-c951-4d2e-8c73-a5c246265732" class="">예시 : 빌드 단계를 설명하기 위한 코드</h2><pre id="cc9b2534-7023-402a-bdae-def16c946094" class="code"><code>/* adder.h */

    int add(const int a, const int b);
    
    /* adder.c */
    
    #include &quot;adder.h&quot;
    
    int add(const int a, const int b)
    {
        return a + b;
    }
    
    /* main.c */
    
    #include &quot;adder.h&quot;
    
    int main(void)
    {
        const int res = add(1, 2);
        return 0;
    }</code></pre><h2 id="c4324561-77e7-4d81-a0ea-db6e2328f910" class="">소스코드의 구성(.h와 .c 파일)</h2><ul id="e6a6515e-fb7f-4d61-a819-892005892f05" class="bulleted-list"><li style="list-style-type:disc">두 종류의 소스코드 파일 존재</li></ul><ul id="5585f40a-67d5-4248-af6c-4faa8c33beb7" class="bulleted-list"><li style="list-style-type:disc">C파일(<code>.c</code>)<ul id="a78c36f9-c62d-4887-a415-92a1c1805a90" class="bulleted-list"><li style="list-style-type:circle">실제 프로그램을 돌게 하는 로직코드를 저장해두는 파일</li></ul><ul id="a6635050-2e12-40e7-aa81-cddb6e64fade" class="bulleted-list"><li style="list-style-type:circle">내용물 : 함수 정의(=함수 구현), 전역변수 등, 매크로</li></ul></li></ul><ul id="4d07e177-6b53-4708-b7c5-f63e824dfed7" class="bulleted-list"><li style="list-style-type:disc">헤더파일(<code>.h</code>)<ul id="0e67ac83-a01d-4c3c-a537-3accdb68c22f" class="bulleted-list"><li style="list-style-type:circle">여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일</li></ul><ul id="bd8e32ca-151f-4f9a-8abc-66d577e152eb" class="bulleted-list"><li style="list-style-type:circle">내용물 : 함수 선언, 매크로, <code>extern </code>변수 선언 등</li></ul><ul id="330bdbb5-7c7c-4cdc-9ba0-affc6186e7f9" class="bulleted-list"><li style="list-style-type:circle"><code>#include</code>로 포함함 (예 : <code>#include &quot;adder.h&quot;</code>)</li></ul></li></ul><ul id="36a6e372-27ef-4b03-9175-32f76ae9f618" class="bulleted-list"><li style="list-style-type:disc">위의 예시에서 <code>main.c</code> 파일에 <code>add()</code>란 함수 사용<ol type="1" id="7d23662a-ba56-46b3-a79b-8ac62861ef34" class="numbered-list" start="1"><li><code>add()</code> 함수는 <code>adder.c</code>에 정의되어 있음</li></ol><ol type="1" id="4bd5dca8-bc70-4f97-850e-4877e0549161" class="numbered-list" start="2"><li>이 때 <code>adder.h</code>에 <code>add()</code>의 원형을 저장해두면 <code>main.c</code>에서 <code>#include &quot;adder.h&quot;</code> 입력해주면 사용이 가능함</li></ol></li></ul><h3 id="da7e0f70-0f98-4623-85a3-b0703ed1bb21" class="">헤더파일이 필요한 이유</h3><ul id="6f9d086f-4eb4-4608-9df8-edb67f01bf8c" class="bulleted-list"><li style="list-style-type:disc">모든 소스코드를 .c 파일 하나에 집어 넣을 수도 있으나 연관된 기능끼리 모아서 .c 파일 하나씩 저장하여 논리적으로 분리된 .c 파일을 만들어 효율적으로 관리 할 수 있음</li></ul><ul id="45090a7a-04e8-4c6b-a1a0-a05558cfd7ee" class="bulleted-list"><li style="list-style-type:disc">이 때 동일한 함수를 여러 곳에서 써야 할 때 모든 파일에 복붙을 하는 것은 좋지 않음 ⇒ 유지 보수시 여러가지 이슈를 유발함</li></ul><ul id="b655290a-1da7-483f-830f-d8da54c70b8a" class="bulleted-list"><li style="list-style-type:disc">헤더파일을 사용하면 함수 선언을 여러 C 파일에 공유 가능</li></ul><h3 id="a4461028-bf71-408f-8631-4d54e8d17c25" class="">함수 선언만을 통해 프로그램이 돌아가는 이유</h3><ul id="a22ed1b9-bc65-48c6-8bea-81d1fbe601e2" class="bulleted-list"><li style="list-style-type:disc">빌드가 여러 단계로 쪼개져 있는 이유가 바로 정의 없이 선언만 가지고도 컴파일이 되게 하기 위해서 임</li></ul><ul id="b58bd124-465d-4861-b8b7-5608975736ce" class="bulleted-list"><li style="list-style-type:disc">실제 올바른 기능 호출은 링크 단계에서 이루어짐</li></ul><h3 id="cd0fc44c-d640-48da-815e-05cade7bd625" class="">include의 2가지 방식</h3><ul id="7d2bebeb-cbd4-4f2f-a387-b4312ca75f85" class="bulleted-list"><li style="list-style-type:disc">디스크 상의 어디에서 헤더파일을 찾느냐에 따라 두 가지로 나뉘어짐</li></ul><ul id="f5459bac-2c54-45e4-b540-00ae523c0ded" class="bulleted-list"><li style="list-style-type:disc"><code>#include &lt;&gt;</code><ul id="f0f6df42-0b0e-4fcb-adcd-622281cba959" class="bulleted-list"><li style="list-style-type:circle">시스템 경로에서만 헤더파일을 검색</li></ul><ul id="f5c8f295-a369-4bb8-8697-003ebd64ab5d" class="bulleted-list"><li style="list-style-type:circle">보통 컴파일러가 제공하는 시스템 헤더파일을 include할 때 사용</li></ul><ul id="7e3feab5-ffbe-42ac-88e0-407ba7748853" class="bulleted-list"><li style="list-style-type:circle">예 : <code>#include &lt;stdio.h&gt;</code></li></ul></li></ul><ul id="f0642c48-0d61-4342-b09c-7f4f76b0f635" class="bulleted-list"><li style="list-style-type:disc"><code>#include &quot;&quot;</code><ul id="10430fce-6061-4a15-92fa-bc79549f9cb6" class="bulleted-list"><li style="list-style-type:circle">현재 작업 중인 디렉터리(working directory)에서 헤더파일을 먼저 검색한 뒤 없으면 시스템 경로를 검색</li></ul><ul id="2fc09026-97d0-42ed-88c4-82e813af7fc2" class="bulleted-list"><li style="list-style-type:circle">개발자가 구현한 헤더파일들을 include할 때 사용</li></ul><ul id="e7b13e82-c41d-497e-864f-62cd9ef06228" class="bulleted-list"><li style="list-style-type:circle">예 : <code>#include &quot;adder.h&quot;</code></li></ul></li></ul><h2 id="95ec1860-7022-42f5-8126-997182f4d5ad" class="">전처리 단계</h2><ul id="614f6879-c77e-4dde-90d8-331f41bacf5a" class="bulleted-list"><li style="list-style-type:disc">보통 전처리기(preprocessor)라는 별도의 프로그램이 담당</li></ul><h3 id="334a305d-aa0b-4cc1-a06f-e848e5df6c38" class="">전처리 단계의 진행 과정</h3><p id="c92e2b69-c1bb-4a46-ae96-1880d8c194c7" class="">1) 입력 : c 파일 하나<div class="indented"><pre id="ec991572-73ae-494d-871e-3073cf7679da" class="code"><code>/* main.c */
    
    #include &quot;adder.h&quot;
    
    int main(void)
    {
        const int res = add(1, 2);
        return 0;
    }</code></pre></div></p><p id="b6e97364-c695-4c7f-9a37-7e188b9864c3" class="">2) 주석 제거<div class="indented"><pre id="bf994c29-a327-4b81-a6d4-61929f590567" class="code"><code>#include &quot;adder.h&quot;
    
    int main(void)
    {
        const int res = add(1, 2);
        return 0;
    }</code></pre></div></p><p id="7b0d9e62-c5c9-4a06-b3a7-4ac0a4e8507e" class="">3) 매크로 복붙 → 확장</p><p id="ac50e017-7f76-4bc0-9ffa-191f8f3d86e8" class="">4) include 파일 복붙 → 확장<div class="indented"><p id="0d244586-1545-4e73-934f-3afdd148aa97" class="">⇒ 확장 : <code>#include &quot;헤더파일&quot;</code>을 지우고 그 자리에 헤더파일 속에 있는 내용을 복사해다가 가져다 붙임</p><pre id="82a11cfb-96a8-42e0-a23f-7501688e9185" class="code"><code>int add(const int a, const int b);
    
    int main(void)
    {
        const int res = add(1, 2);
        return 0;
    }</code></pre></div></p><p id="321f332f-fac8-4436-aab6-26438e231948" class="">5) 출력 : 확장된 소스코드<div class="indented"><p id="d7b5aa8e-460c-4caf-9e2b-c4ae0a28b314" class="">⇒ 컴파일의 기본 단위인 트랜슬레이션 유닛(translation unit)</p></div></p><h3 id="a7eae890-8f48-4dc5-8a5e-e116ecc3223e" class="">트랜슬레이션 유닛 보는 방법</h3><ul id="b97af493-2155-44ca-8532-7ce42bd03648" class="bulleted-list"><li style="list-style-type:disc">결과는 화면에 도출<pre id="b995833c-8b3b-4b6e-978a-b268dc2b89fb" class="code"><code>&gt; clang -std=89 -W -Wall -pedantic-errors -E adder.c</code></pre></li></ul><ul id="5ab1b3a5-f9ba-4d4f-a44e-2adf0f4e182d" class="bulleted-list"><li style="list-style-type:disc">파일로 저장하려면 출력 리디렉션(output redirection)<pre id="60fb8c38-abc1-4bb4-9a09-93bf01376c6d" class="code"><code>&gt; clang -std=89 -W -Wall -pedantic-errors -E adder.c &gt; adder.pre</code></pre></li></ul><h2 id="0c5909b5-cf15-4d9a-9142-c934e0aed96d" class="">컴파일러</h2><ul id="3dc6d544-1095-4780-b2d7-1c2e153e869a" class="bulleted-list"><li style="list-style-type:disc">컴파일러(compiler)라는 프로그램이 담당</li></ul><h3 id="137a69f0-9e1e-4405-a2e3-40da4f98bc59" class="">컴파일 단계의 진행 과정</h3><p id="26c3355f-f41a-4b83-b461-111c47c989a2" class="">1) 입력 : 트랜슬레이션 유닛</p><p id="5aa8a825-1ba4-434f-8ce9-2a20be2130d8" class="">2) 출력 : 어셈블리어 코드</p><h3 id="8f5428a3-e60c-46e1-9b72-cb93a598fe7e" class="">어셈블리어 코드</h3><ul id="83de060b-a258-4556-9bea-15b679267417" class="bulleted-list"><li style="list-style-type:disc">어셈블리어는 기계 코드와 거의 1:1로 대응 (하드웨어에 아주 가까움)</li></ul><ul id="efa8531b-765e-4880-ab18-120d1c8500f7" class="bulleted-list"><li style="list-style-type:disc">그러나 텍스트 파일이어서 여전히 사람에게만 읽기 쉬운 언어</li></ul><ul id="766a4399-4591-481e-986b-5b8def4bc3ff" class="bulleted-list"><li style="list-style-type:disc">어셈블리어 코드는 아직 정의를 모르는 심볼을 사용할 수 있음<p id="5798cafe-130f-4f5b-b3af-1e780a85ef10" class=""><strong>이것이 바로 헤더를 통한 선언만으로 컴파일이 가능한 이유!</strong></p><p id="5af36b55-544c-4c0a-9379-22461e2eda63" class="">⇒ 심볼(symbol) : 함수나 변수의 이름</p></li></ul><h3 id="7753811c-8031-4b39-b4c7-e325313c08b8" class="">어셈블리어 코드 보는 방법 : main.c / adder.c</h3><ul id="9ee52123-4293-4aff-aae9-6f4a09b382e0" class="bulleted-list"><li style="list-style-type:disc">컴파일 플래그 <code>-S</code>를 쓰면 어셈블리어 코드가 .s 파일에 저장됨<pre id="575d4b5d-728c-4a44-b2c8-bcc3488dd7e4" class="code"><code>&gt; clang -std=c89 -W -Wall -pedantic-errors -S main.c
    &gt; clang -std=c89 -W -Wall -pedantic-errors -S adder.c</code></pre></li></ul><h3 id="1d8334a4-186a-4bfd-9129-7bb128e4f0fd" class="">어셈블리어 코드가 나왔다는 의미</h3><ul id="dd838779-f1b7-420e-b3e5-3e8a18893c0e" class="bulleted-list"><li style="list-style-type:disc">이 단계 이후부터 코드는 특정 플랫폼에서만 동작한다는 이야기</li></ul><ul id="9011c871-3196-4e1e-85c5-9a997ee88a12" class="bulleted-list"><li style="list-style-type:disc">C가 크로스 플랫폼이라는 주장은 컴파일되기 전까지!</li></ul><ul id="5c2318cf-e11f-450d-8f48-8cad07a2e9e3" class="bulleted-list"><li style="list-style-type:disc">또한 타겟 플랫폼이 몇 비트냐에 따라 C의 자료형 크기가 달라질 수 있음<p id="014fa087-4ee0-4dbe-a25a-240cec0c869b" class="">⇒ 어셈블리어 코드는 이미 그 자료형 크기가 결정된 후임</p></li></ul><h2 id="217b8cdb-0de6-474d-b671-329461995352" class="">어셈블 단계</h2><ul id="67618e8d-cff0-4833-9346-c4b684cdb7ef" class="bulleted-list"><li style="list-style-type:disc">어셈블러(assembler)라는 프로그램이 담당</li></ul><h3 id="81d55bc5-ba17-416d-a604-43c15fe8141f" class="">어셈블 단계의 진행 과정</h3><p id="6d2ed0f7-566c-4a08-8192-b78ff471f071" class="">1) 입력 : 어셈블리어 코드</p><p id="ece9373f-a4f5-469c-8b7a-9bb7b816a0dc" class="">2) 출력 : 오브젝트 코드 (object code)</p><h3 id="5d0df9bb-da5f-4c3e-98e4-1ec2b4386c32" class="">오브젝트 코드</h3><ul id="3e615314-19d3-49ff-bff5-98f7211b2b57" class="bulleted-list"><li style="list-style-type:disc">기계가 곧바로 이해 가능한 기계 코드(machine code)</li></ul><ul id="d48aa1bb-c1d7-4701-b229-025e198c6b24" class="bulleted-list"><li style="list-style-type:disc">기계어(machine instruction)라고도 함</li></ul><ul id="1f2b6b1f-685c-429d-bc47-73b8d0b60a8a" class="bulleted-list"><li style="list-style-type:disc">즉, 2진 코드 (0과 1로만 이루어진 코드)</li></ul><ul id="58d5e60b-9049-4842-8c8a-48b3a86a37bf" class="bulleted-list"><li style="list-style-type:disc">어셈블리어 코드와 마찬가지로 여전히 메꿔야하는 구멍이 있음</li></ul><h3 id="4ec4cacb-00ee-4c55-b939-4432fa67988e" class="">오브젝트 코드 보는 방법 : main.o / adder.o</h3><ul id="74824bb1-420e-434f-a285-64440afd6c6b" class="bulleted-list"><li style="list-style-type:disc"><code>-c</code> 플래그를 넣어서 컴파일 하면 .o파일로 저장됨<pre id="f002294e-7ae7-4610-b5d0-2ba2f9b0a3f9" class="code"><code>&gt; clang -std=c89 -W -Wall -pedantic-errors -c main.c
    &gt; clang -std=c89 -W -Wall -pedantic-errors -c adder.c</code></pre></li></ul><h2 id="1adcfdd5-af7b-4bb2-b221-0d8ee95d0fea" class="">링크 단계</h2><ul id="fdaf8a3e-119e-4e27-9dfb-291ed8049d9f" class="bulleted-list"><li style="list-style-type:disc">링커(linker)라는 프로그램이 담당</li></ul><h3 id="e234ca0b-e21b-4ddd-84ce-d454f9362579" class="">링크 단계의 진행 과정</h3><p id="2c24eb15-8211-48ee-89e1-647336ae8973" class="">1) 입력 : 모든 오브젝트 코드들<div class="indented"><p id="352c0b01-454b-4528-86e3-e99c0614e549" class="">⇒ 링커는 모든 오브젝트 코드들을 모아다 구멍을 메꾼 뒤 실행파이롤 저장</p><p id="cbeda121-be15-4ab7-b528-fa459c3e3fd6" class="">⇒ 링커가 구멍을 메우는 방법<div class="indented"><p id="aaa3ae51-137c-4ecb-a824-d7f8b40f7fb6" class="">링커가 오브젝틑 파일을 다 모아서 하나의 이진(binary) 파일로 만들어 주다가 함수의 위치를 기억하여 함수를 호출하려는 코드를 만나면 실행위치(주소)로 점프하여 코드를 넣어줌</p></div></p><p id="f8587012-f621-415e-9910-ed1efd993ee1" class="">⇒ 만약 선언만 믿고 사용한 함수나 변수가 여전히 구멍으로 남아 있다면?<div class="indented"><p id="9a4bfb4b-fd9d-416f-a890-fe18b36a4180" class="">링커 오류를 뱉음 : 그 함수나 변수가 없어 실행할 방법이 없기에 경고가 아니라 오류</p></div></p></div></p><p id="6cfbbecb-0007-4a13-99c8-d58b27518fb3" class="">2) 출력 : 최종 실행파일(.exe, .out)</p><h3 id="afdef5b9-954a-4bc0-bc18-fd0c16ec0feb" class="">왜 굳이 링크단계가 분리되어 있을까?</h3><ul id="51767517-e64a-43a6-a969-56f1f5d603e4" class="bulleted-list"><li style="list-style-type:disc">보통 컴파일(전처리/컴파일/어셈블)과 링크, 두 단계로 나눠서 생각</li></ul><h3 id="30685c4e-e922-4d73-8c3d-db3873dfa80c" class="">수많은 구멍을 컴파일 때마다 메꿀려면</h3><ul id="17998f2a-2e7d-4cab-9a33-b28e90630481" class="bulleted-list"><li style="list-style-type:disc">.c파일이 너무 많이 있으면 구멍을 메꿔주는 일이 매우 복잡 → .c파일이 수 천개나 있는 프로젝트에서 .c파일 하나 컴파일 할때마다 모든 함수를 찾아서 메꾸기 힘듬</li></ul><ul id="fc9bd793-3da3-47e2-b694-119cf0df3b6d" class="bulleted-list"><li style="list-style-type:disc">여러 개의 .c파일에서 동일한 외부 함수를 사용할 경우 최종 실행파일에 그 정의가 중복으로 들어가는 것을 막아야함 → 이 중복을 체크하기도 힘듬</li></ul><ul id="877d960b-3238-49a0-931f-2fd772285ab0" class="bulleted-list"><li style="list-style-type:disc">모든 C 파일을 한번에 합쳐서 컴파일 한다면? → .c파일 하나만 수정해도 모든걸 컴파일 하기 힘듬<p id="359dfb50-a230-4ecb-b7c3-fdd994f71083" class=""><strong>⇒ .c파일 하나씩 따로 컴파일해서 오브젝트 파일로 저장해두는 방법이 젤 합리적임</strong><div class="indented"><p id="e9f2b6d5-a125-4efa-b0eb-4993333151bf" class="">1) 나중에 바뀐 .c파일만 컴파일해서새로운 오브젝트 파일 생성</p><p id="7def9c5b-6232-488c-bfad-c4499f756a60" class="">2) 기존에 있던 오브젝트 파일들과 합쳐서 링크</p><p id="8e138775-5b37-4f69-b69d-56601196e73c" class="">3) 훨씬 빠르게 처리 가능</p></div></p></li></ul><h3 id="fdcb7a3a-4236-4a20-a073-7725b02542fb" class="">.o파일을 .exe로 만드는 방법</h3><ul id="c984d957-5e54-48b9-944a-fc1f6a181821" class="bulleted-list"><li style="list-style-type:disc">비주얼 스튜디오는 기본적으로 오브젝트 파일과 .exe 파일을 모두 만들어줌</li></ul><ul id="41addb59-189c-4e29-be30-34041a94ddaf" class="bulleted-list"><li style="list-style-type:disc">clang은 그냥 바로 .exe 파일만 만들어줌<pre id="bd13a075-b960-4898-b9fe-24f183b2c504" class="code"><code>&gt; clang -std=c89 -W -Wall -pedantic-errors *.o
    /* 아래와 같이 명시할 경우 .o 파일로 .exe 파일 생성 */
    &gt; clang -std=c89 -W -Wall -pedantic-errors main.o adder.o</code></pre></li></ul><h2 id="4b287dde-879b-487f-b5cf-5c0e7de0c4b0" class="">라이브러리</h2><ul id="5489be2a-0807-4344-871c-73150bd3d008" class="bulleted-list"><li style="list-style-type:disc">빌드 결과가 실행파일이 아니라 라이브러리 파일로 나오게 할 수 있음</li></ul><ul id="37a8faa8-6908-42c9-a6fa-f5aa25dc75f7" class="bulleted-list"><li style="list-style-type:disc">라이브러리란?<p id="3ee74355-94e5-490a-8cc3-00f27813c93b" class="">⇒ 함수 등을 기계어로 변환한 후 파일 하나에 저장해 놓은 것<div class="indented"><p id="2f148ab1-2f85-45c3-8214-8f1b7774d389" class="">나중에 다른 .c파일에서 이 기능이 필요할 때 같이 링크해서 쓸 수 있음</p></div></p></li></ul><ul id="6f899829-8b40-4f17-989a-d506beeb674c" class="bulleted-list"><li style="list-style-type:disc">라이브러리는 정적(static) 라이브러리, 동적(dynamic) 라이브러리 두 종류로 나눌 수 있음</li></ul><h3 id="ee9f6e59-97cb-4083-8bb2-44e37de1d580" class="">정적 라이브러리와 링크</h3><ul id="3444badf-53d1-45e2-91a3-dfb0ecb6ca8e" class="bulleted-list"><li style="list-style-type:disc">정적 라이브러리와 링크하는 것을 정적 링킹이라고 함</li></ul><ul id="e6efe7c1-9b18-4be3-9991-c6af67937266" class="bulleted-list"><li style="list-style-type:disc">라이브러리 안에 있는 기계어를 최종 실행파일에 가져다 복사함</li></ul><ul id="26caf7bb-c60e-4f85-81d8-794b36851fc8" class="bulleted-list"><li style="list-style-type:disc">동적 링킹에 비해<p id="d61705e2-203d-49b4-a7e0-a3857fcc8256" class="">1) 실행파일의 크기가 커짐</p><p id="176247e1-d84b-40c7-988d-1947313c03ed" class="">2) 메모리를 더 잡아먹을 수 있음</p><p id="ad090948-7b5e-4675-9590-5fcb2fc698be" class="">3) 실행속도가 빠름</p></li></ul><h3 id="11393d12-4f76-4645-98f2-16fae6a1af61" class="">동적 라이브리러와 링크</h3><ul id="62f2803b-d373-4dc6-9934-67d8b208bdf6" class="bulleted-list"><li style="list-style-type:disc">동적 라이브러리와 링크하는 것을 동적 링킹이라고 함</li></ul><ul id="6205b26f-97d1-42a1-a2b0-f7f7ead83ec0" class="bulleted-list"><li style="list-style-type:disc">실행파일 안에 여전히 구멍으로 남겨두는 방법</li></ul><ul id="62a357c0-1828-45af-a0a2-726f770b3ba9" class="bulleted-list"><li style="list-style-type:disc">실행파일을 실행할 때 실제로 링킹이 일어남 → 이 링킹은 실행중 운영체제가 해줌</li></ul><ul id="fc654d6d-aea0-4729-ae6f-10d3200d7221" class="bulleted-list"><li style="list-style-type:disc">정적 링킹에 비해<p id="49cc4cb9-885e-418e-a2a7-671b291252d4" class="">1) 실행파일 크기가 작음</p><p id="943cd0ff-2d54-4b94-b18b-a1ed65747f93" class="">2) 여러 실행파일이 동일한 라이브러리를 공유할 수 있음 → 메모리 절약</p><p id="40e17bf5-ef72-49fe-abcb-85ff4e6eebb7" class="">3) 여러 실행파일이 이름은 같지만 버전이 다른 동적 라이브러리를 사용한다면 DLL 지옥(DLL Hell)을 맛볼 수 있음</p></li></ul><h2 id="deeaa80e-5adf-43e5-80c4-024d04a3e3a5" class="">분할 컴파일</h2><ul id="97c15ee6-1a31-462a-9cff-32ab32f9fad6" class="bulleted-list"><li style="list-style-type:disc">2개 이상의 .c파일을 개별적으로 컴파일해서 오브젝트 파일을 만듬</li></ul><ul id="aac9a1a4-8e8f-4a58-9774-10b063a9b288" class="bulleted-list"><li style="list-style-type:disc">오브젝트 파일들을 서로 연결(링크)해서 실행파일을 만듬</li></ul><h3 id="0d756c2a-106e-48ad-a74b-37e23785e8a8" class="">다른 파일에 있는 전역 변수 사용 시 문제점</h3><pre id="0714f8cf-cd9c-477e-b73b-9da8b3ae272e" class="code"><code>/* 아래와 같이 작성시 컴파일 오류 발생 */
    
    /* monster_repo.h */
    
    void add_monster(void);
    
    /* monster_repo.c */
    
    int g_mob_count = 0;
    
    void add_monster(void)
    {
        ++g_mob_count;
    }
    
    /* main.c */
    
    #include &lt;stdio.h&gt;
    #include &quot;monster_repo.h&quot;
    
    int main(void)
    {
        add_monster();
        printf(&quot;# monsters: %d\n&quot;, g_mob_count);
    
        return 0;
    }</code></pre><ul id="bcb097a8-3a12-4484-8e4d-72ff6eaf9ca5" class="bulleted-list"><li style="list-style-type:disc">컴파일 오류 발생 : 컴파일러가 각 .c파일을 따로따로 컴파일 하기 때문에 <code>main.c</code>는 <code>monster_repo.c</code> 안에 있는 <code>g_mob_count</code>의 존재를 모름</li></ul><pre id="02dd23ed-e15f-4723-bd0d-f124a8161f82" class="code"><code>/* 아래와 같이 작성시 링커 오류 발생 */
    
    /* monster_repo.h */
    
    void add_monster(void);
    
    /* monster_repo.c */
    
    int g_mob_count = 0;
    
    void add_monster(void)
    {
        ++g_mob_count;
    }
    
    /* main.c */
    
    #include &lt;stdio.h&gt;
    #include &quot;monster_repo.h&quot;
    
    int g_mob_count = 0;
    
    int main(void)
    {
        add_monster();
        printf(&quot;# monsters: %d\n&quot;, g_mob_count);
    
        return 0;
    }</code></pre><ul id="3d243c5b-d520-4bb5-9714-d6164e684bd1" class="bulleted-list"><li style="list-style-type:disc"><code>monster_repo.c</code>와 <code>main.c</code> 모두에 <code>g_mob_count</code>가 있음</li></ul><ul id="f3f0e5d1-8c3a-479a-96b9-1cc3bd5deff1" class="bulleted-list"><li style="list-style-type:disc">컴파일 동안에는 서로를 모르니 되지만, 링크를 하려고 하니 전역 범위에 같은 이름을 쓰는 변수가 두 개나 있어 오류가 발생함</li></ul><p id="3d6251a6-f983-43ad-b8bc-8511402ef326" class=""><strong>⇒ 다른 방법이 필요함</strong><div class="indented"><p id="1bfd801b-6428-4a7e-a956-e7589598df03" class="">새로운 전역변수를 만드는 것이 아니라 <code>monster_repo.c</code>안에 있는 것을 가져다 쓸거다라고 컴파일러에게 말해줘야함 → 그래야 컴파일러가 구멍을 비워둠 (전방선언과 같은 원리)</p></div></p><h3 id="43909b20-228b-4f66-af91-ba431cb72c0b" class="">extern 키워드</h3><pre id="71c7aa3a-0754-476d-a931-1cf1484a6a9e" class="code"><code>/* monster_repo.h */
    
    extern int g_mob_count;
    void add_monster(void);
    
    /* monster_repo.c */
    
    int g_mob_count = 0;
    
    void add_monster(void)
    {
        ++g_mob_count;
    }
    
    /* main.c */
    
    #include &lt;stdio.h&gt;
    #include &quot;monster_repo.h&quot;
    
    /* 또는 main.c.에 extern int g_mob_count;을 둬도 됨 */
    
    int main(void)
    {
        add_monster();
        printf(&quot;# monsters: %d\n&quot;, g_mob_count);
    
        return 0;
    }</code></pre><ul id="04ede002-ba97-48b5-a787-9ef397d57bd6" class="bulleted-list"><li style="list-style-type:disc">다른 파일에 있는 전역변수에 접근하려면 <code>extern</code> 키워드를 사용</li></ul><h3 id="ffa5f576-adee-4dc4-98b0-63df2a76ebf7" class="">extern 사용법</h3><p id="1dcc7995-41ba-4060-a76b-7c43b5891b11" class="">1) 헤더파일에 포함</p><ul id="f853240e-0bbd-40fe-9ac3-369246baa733" class="bulleted-list"><li style="list-style-type:disc">어떤 경우(남의 라이브러리는 .c 대신 라이브러리 바이너리 파일과 헤더만 줌)에는 .c파일을 볼 수 없을 수도 있음 → 이 경우 라이브러리 제작자가 <code>extern</code>을 아예 헤더에 포함시켜 줌</li></ul><ul id="8488d23d-8b92-4a9e-a64f-5788470e7440" class="bulleted-list"><li style="list-style-type:disc">결과적으로는 include는 그냥 복붙으로 직접 .c에 넣는 것과 같음<p id="88053786-5e84-4504-9d72-129256d4a2d5" class="">⇒ 누구라도 쓸 수 있음</p></li></ul><p id="deacf8f3-c362-4ad8-b94a-3af6b1aec454" class="">2) .c파일에 포함<div class="indented"><p id="15bce566-6615-4b08-868c-f178064a742a" class="">⇒ 그 파일 안에서만 쓸 수 있음</p></div></p><pre id="2ac5ad4a-f0ec-4e74-839f-ee70ce72de81" class="code"><code>/* 아래와 같이 작성시 링커 오류 발생 */
    
    /* monster_repo.h */
    
    int g_mob_count = 0;
    void add_monster(void);
    
    /* monster_repo.c */
    
    #include &quot;monster_repo.h&quot;
    
    void add_monster(void)
    {
        ++g_mob_count;
    }
    
    /* main.c */
    
    #include &lt;stdio.h&gt;
    #include &quot;monster_repo.h&quot;
    
    int main(void)
    {
        add_monster();
        printf(&quot;# monsters: %d\n&quot;, g_mob_count);
    
        return 0;
    }</code></pre><ul id="8a113a5d-cc40-4ff3-9465-2b02625ed478" class="bulleted-list"><li style="list-style-type:disc"><code>g_mob_count</code>가 <code>monster_repo.c</code>에 복붙 된 뒤 오브젝트 코드로 컴파일 됨</li></ul><ul id="171f5166-9949-4edb-9630-f1e1986f627b" class="bulleted-list"><li style="list-style-type:disc"><code>g_mob_count</code>가 <code>main.c</code>에 복붙된 두 오브젝트 코드로 컴파일됨</li></ul><ul id="8484e1af-8a75-43f2-ae24-915543126134" class="bulleted-list"><li style="list-style-type:disc">링크가 이 둘을 합치려다 중복된 전역변수 발견</li></ul><h3 id="0ceb5ccf-9530-4e9e-ab02-d07758ba58ea" class="">함수의 경우는?</h3><ul id="e281d760-faf0-4166-804b-40fc90b2f742" class="bulleted-list"><li style="list-style-type:disc">함수 프로토타입(=선언)<ul id="2ed4fd68-279a-4a97-840d-c1aa794da499" class="bulleted-list"><li style="list-style-type:circle">함수 앞에 <code>extern</code>을 붙일 수 있으나 그냥 선언을 하면 자동으로 <code>extern</code></li></ul><ul id="c2345d94-1de7-43e2-aab1-7473abff9756" class="bulleted-list"><li style="list-style-type:circle">굳이 <code>extern</code> 없어도 함수 뒤에 { 안 열고 ;로 끝나니 쉽게 알 수 있음</li></ul><ul id="518a5654-45d5-4d94-8121-e41dc4cadcff" class="bulleted-list"><li style="list-style-type:circle">그래서 보통 <code>extern</code> 키워드는 사용하지 않음</li></ul></li></ul><ul id="a4944728-f690-4bd2-b394-c282632cbaa7" class="bulleted-list"><li style="list-style-type:disc">함수 프로토타입 넣는 2가지 방법<ul id="0ec72af0-6b7b-4049-b2c8-8f1d111073d1" class="bulleted-list"><li style="list-style-type:circle">사용할 곳에서 호출하기 전에 직접 원형을 넣어줌</li></ul><ul id="68a807fa-a7d0-4ee9-a879-8422284b6cd3" class="bulleted-list"><li style="list-style-type:circle">헤더파일에 넣어줌</li></ul></li></ul><ul id="fb9b1292-06ed-439a-a5bc-e1d562f56d75" class="bulleted-list"><li style="list-style-type:disc">함수의 경우 헤더파일에 넣는 방법을 많이 사용함</li></ul><h3 id="396c3c0f-9cca-4504-b08f-19040dc8d330" class="">전역변수의 문제</h3><ul id="d8fd3856-9cd2-4594-bb11-3683b2f5698f" class="bulleted-list"><li style="list-style-type:disc">전역변수는 쓰지마라는 이야기들이 많음</li></ul><ul id="47103111-7ef2-40b2-90be-05325a3ecb4d" class="bulleted-list"><li style="list-style-type:disc">확실히 문제는 있음<ul id="3a001a95-e87d-4c53-932f-4e05129708e9" class="bulleted-list"><li style="list-style-type:circle"><code>extern</code>을 사용하면 아무데서나 확인이 가능</li></ul><ul id="c0f1a580-5a79-433f-9ffa-4b7907efaea9" class="bulleted-list"><li style="list-style-type:circle">심지어 손쉽게 파일의 변수를 바꿔버릴 수 있음</li></ul><ul id="dc33a429-ea1d-478b-9a8b-f822815a0dbc" class="bulleted-list"><li style="list-style-type:circle">파일이 2만개나 있으나 어떤 코드가 전역변수를 바꾸는지 알 수 없음</li></ul></li></ul><ul id="6056ef9d-60b7-4b7b-873b-ca89a54e9b18" class="bulleted-list"><li style="list-style-type:disc">이러한 경우 전역변수에 <code>static</code>을 붙여 다른 곳에서 사용하지 못하게 할 수 있음</li></ul><h3 id="8f86391a-f504-4c48-876a-ea2e415d42a3" class="">static</h3><ul id="93bf0d5b-c3fd-43df-93c5-392d37c88e44" class="bulleted-list"><li style="list-style-type:disc">다른 파일에서 전역변수에 접근 못하게 막는 방법</li></ul><ul id="b6538340-ba44-43d2-a8b5-5f4e41acc0ae" class="bulleted-list"><li style="list-style-type:disc">이 변수의 범위가 파일로 한정됨</li></ul><ul id="916e9007-6dc2-42b3-aa8e-619d8be9ea8f" class="bulleted-list"><li style="list-style-type:disc">흔히 정적 변수라고 함</li></ul><ul id="9261e5c5-d879-4d1f-a97a-75f5237c0601" class="bulleted-list"><li style="list-style-type:disc">여전히 전역변수로 프로그램을 실행하는 동안 실제 공간을 계속 차지하고 있음</li></ul><ul id="2f5314a6-35aa-4c72-a3f3-e3b0eb5b2c75" class="bulleted-list"><li style="list-style-type:disc"><code>static</code> 변수를 다른 파일에서 접근하려고 하면 링커 오류 발생<pre id="cbdd64e1-8b63-40b6-aef1-de7ddf209586" class="code"><code>/* 아래와 같이 작성시 링커 오류 발생 */
    
    /* monster_repo.h */
    
    void add_monster(void);
    
    /* monster_repo.c */
    
    #include &quot;monster_repo.h&quot;
    
    static int s_mob_count = 0;
    
    void add_monster(void)
    {
        ++s_mob_count;
    }
    
    /* main.c */
    
    #include &lt;stdio.h&gt;
    #include &quot;monster_repo.h&quot;
    
    int main(void)
    {
        add_monster();
        printf(&quot;# monsters: %d\n&quot;, s_mob_count);
    
        return 0;
    }</code></pre></li></ul><ul id="dc936c76-9890-4418-97f0-7ef6df0fbebf" class="bulleted-list"><li style="list-style-type:disc">지역변수에도 <code>static</code>을 넣을 수 있음<pre id="a49d345d-2138-4af8-86d6-b96e2cd4545a" class="code"><code>/* monster_repo.h */
    
    void add_monster(void);
    
    /* monster_repo.c */
    
    #include &quot;monster_repo.h&quot;
    
    void add_monster(void)
    {
        static int s_mob_count = 0;
        ++s_mob_count;
    }
    
    /* main.c */
    
    #include &lt;stdio.h&gt;
    #include &quot;monster_repo.h&quot;
    
    int main(void)
    {
        add_monster();
        add_monster();
        add_monster();
        return 0;
    }</code></pre><p id="c25e927f-f7e5-4dfb-ae44-731b5d363c5f" class="">
    </p></li></ul><h3 id="813ac878-6709-4dd2-a8f6-256b83acbca9" class="">static의 또 다른 의미</h3><pre id="4833175c-6f55-4151-88fb-8e6a242ef99b" class="code"><code>/* 지역변수 mob_count */
    
    #include &quot;monster_repo.h&quot;
    
    void add_monster(void)
    {
        int mob_count = 0;
        ++mob_count;
    }
    
    /* static 지역변수 s_mob_count */
    
    #include &quot;monster_repo.h&quot;
    
    void add_monster(void)
    {
        static int s_mob_count = 0;
        ++s_mob_count;
    }</code></pre><ul id="ed9a78d8-a940-4d47-889c-b77814027a1f" class="bulleted-list"><li style="list-style-type:disc"><code>static</code>이 없으면 지역변수. 함수 반환 시 그 변수도 사라짐</li></ul><ul id="7823f3db-86cc-49c7-bbd6-33accff1a7d3" class="bulleted-list"><li style="list-style-type:disc"><code>static</code>을 쓰면 개념상 전역변수, 허나 그 함수 안에서만 접근 가능<p id="75f1d6ac-7e6b-47d8-84c9-01a079e0420f" class="">⇒ 함수가 반환되도 여전히 값은 저장되어 있음</p></li></ul><ul id="0727f0d4-a218-4478-b1e2-cf4bb7d3d112" class="bulleted-list"><li style="list-style-type:disc"><code>static</code>이 없으면 0으로 초기화 되지만, <code>static</code>을 붙일 경우 처음 함수를 실행할 때만 초기화되고 두번째 실행될 때는 증가(0, 1, 2, 3 ...)만 진행됨</li></ul><h3 id="a17569de-df03-4eeb-810b-9c524bcf8587" class="">static 함수</h3><ul id="c82a0d6b-d42b-4a05-a518-dbae41adb971" class="bulleted-list"><li style="list-style-type:disc">함수 역시 앞에 <code>static </code>키워드를 넣으면 외부로부터 접근을 막을 수 있음</li></ul><h3 id="197cb858-9539-4d6d-85c5-e46a618549f3" class="">.c와 .h 파일 정리</h3><ul id="0bbc4f04-928d-40cd-93fd-0eeb4ff99ba8" class="bulleted-list"><li style="list-style-type:disc">빌드의 4단계가 올바르게 돌아가려면 아래의 기본 원칙을 따라야함<p id="0aa216b5-6adc-4483-9c4f-0401825cddce" class="">1) 헤더파일에는 선언만 들어가야함<div class="indented"><p id="41023701-fee0-4cda-9f1b-69b0029bf002" class="">⇒ 함수 선언, 전역변수 <code>extern</code> 선언</p></div></p><p id="181b8009-02ee-41da-ba2d-b02fc67ba2fa" class="">2) .c파일에는 정의가 들어가야함<div class="indented"><p id="13901f18-670b-47b1-b728-d976fc82463d" class="">⇒ 함수 정의, 전역 및 정적 변수 정의</p></div></p></li></ul><pre id="5ea3c37c-3a2e-4094-a9bf-16eb063ce2e4" class="code"><code>/* Circular Header Include 발생 */
    
    /* a.h */
    
    #include &quot;b.h&quot;
    /* 다른 코드들 */
    
    /* b.h */
    
    #include &quot;a.h&quot;
    /* 다른 코드들 */
    
    /* c.c */
    
    #include &quot;a.h&quot;
    /* 다른 코드들 */</code></pre><ul id="0f53b634-3ca5-452e-baad-26654f8924ea" class="bulleted-list"><li style="list-style-type:disc">순환 헤더 인클루드(circular header include) 발생 : 헤더가 꼬여버림</li></ul><ul id="55c33aba-3331-4e84-9697-aa987919f2b4" class="bulleted-list"><li style="list-style-type:disc">해결법 1<ul id="3117685f-ea95-4088-a8fe-ea9b81f4cd48" class="bulleted-list"><li style="list-style-type:circle"><code>#include</code>는 가능하면 .c에서만 하기</li></ul><ul id="ad4adeb6-ae31-443b-a2bc-e04b4a524504" class="bulleted-list"><li style="list-style-type:circle">b헤더에서 a헤더를 include하는 대신 a에서 정의된 것을 전방 선언하기</li></ul><ul id="d15901b1-39da-4f0f-a694-5d239d04180e" class="bulleted-list"><li style="list-style-type:circle">하지만 어쩔 수 없이 헤더파일을 서로 인클루드해야 할 일이 있음</li></ul></li></ul><ul id="7e78b00d-f2a6-4814-b2b4-bebfe33592f1" class="bulleted-list"><li style="list-style-type:disc">해결법 2 <strong>(인클루드 가드)</strong><pre id="d0b261c6-f6c7-4dd3-812b-be1753d99a3f" class="code"><code>/* foo.h */
    #ifndef FOO.H
    #define FOO.H
    /* 원래 헤더 파일 내용 */
    #endif /* FOO.H */</code></pre><p id="b00b6a1c-1aa4-4ae2-9dcd-aba7a62f6321" class="">⇒ C에서 헤더파일이 여러번 include되는 것을 막는 업계 표준 (# : 전처리기 지시문)</p></li></ul><h3 id="84b34ff9-46c8-4d91-bb43-177e650e2540" class="">인클루드 가드 작동법</h3><pre id="24d0f75e-57d5-4c36-b26b-b16ba968720a" class="code"><code>/* a.h */
    
    #ifndef A_H
    #define A_H
    #include &quot;b.h&quot;
    /* 다른 코드들 */
    #endif /* A_H */
    
    /* b.h */
    
    #ifndef B_H
    #define B_H
    #include &quot;a.h&quot;
    /* 다른 코드들 */
    #endif /* B_H */
    
    /* c.c */
    
    #include &quot;a.h&quot;
    /* 다른 코드들 */</code></pre><ul id="655b3fb0-701b-4df4-b75e-8a25fe45730b" class="bulleted-list"><li style="list-style-type:disc">전처리기 지시문은 컴파일하기 전에 전처리기가 처리</li></ul><ul id="943dbfa8-086e-41fc-a018-0d8707b45336" class="bulleted-list"><li style="list-style-type:disc">이때 (1) 어떤 상수를 정의하고 (2) 컴파일러에게 조건적으로 코드를 컴파일하라고 지시</li></ul><h3 id="63337dbf-4830-4790-b3d1-ba8e69422394" class="">#pragma once</h3><ul id="9249cc6f-d1af-4c9e-8b4e-9ce0def2627c" class="bulleted-list"><li style="list-style-type:disc">인클루드 가드 대신 사용 가능</li></ul><ul id="3ecd4a97-7f21-477a-ae05-77673a657c1f" class="bulleted-list"><li style="list-style-type:disc">하지만 표준은 아님</li></ul><ul id="906ca320-03a4-41f0-943c-33138bf43579" class="bulleted-list"><li style="list-style-type:disc">최신 컴파일러가 대체적으로 이를 지원하지만, 포팅을 생각한다면 예전 컴파일러 및 시스템과의 호환을 위해 인클루드 가드를 사용하는 것이 좋음</li></ul><h3 id="6e30468c-d68b-4ff0-96cf-53f22d37ec0f" class="">컴파일러의 종류와 특징</h3><ul id="60e10b2f-8d09-4aba-ab92-fe11ca79baad" class="bulleted-list"><li style="list-style-type:disc">C는 어느 한 회사가 주도하는 표준이 아니기에 컴파일러도 다양한 회사에서 나옴</li></ul><ul id="ba42f87a-5562-4aba-afc0-6c51b752d6a6" class="bulleted-list"><li style="list-style-type:disc">GCC(GNU 컴파일러 모음, GNU Compiler Collection)<ol type="a" id="2f6a549c-9de2-4100-8413-e37f86b5f794" class="numbered-list" start="1"><li>GNU C  컴파일러는 1987년에 첫 출시</li></ol><ol type="a" id="7b0811d7-3c3c-4f89-91c9-a34f1964ffe4" class="numbered-list" start="2"><li>리눅스/유닉스 기반 플랫폼에서 주로 사용되던 컴파일러</li></ol><ol type="a" id="af2dc614-d400-4343-8f97-dc6f28f8a952" class="numbered-list" start="3"><li>다양한 C 표준을 대부분 제대로 지원</li></ol></li></ul><ul id="c720bc64-9fdb-41db-b2c7-8194b7032303" class="bulleted-list"><li style="list-style-type:disc">마이크로소프드 Visual C++<ol type="a" id="ebe19e3f-8411-41ad-a32b-c312cd8b08fd" class="numbered-list" start="1"><li>원래 비주얼 스튜디오에 딸려오는 C++ 컴파일러나 확장자 .c일 경우 C로 컴파일</li></ol><ol type="a" id="83578293-bebc-402e-a664-c1378d7c0843" class="numbered-list" start="2"><li>C99 표준 ⇒ 그러나 모든 표준을 지키지는 않음</li></ol><ol type="a" id="10fb5fcc-3157-40dc-b476-baf654f5ebae" class="numbered-list" start="3"><li>윈도우 기반 플랫폼에서 주로 사용</li></ol></li></ul><ul id="3a82298a-cd11-4b93-a247-f4403e5f26e3" class="bulleted-list"><li style="list-style-type:disc">Clang<ol type="a" id="024fee12-9ca6-4fb6-98fa-c73d2d30b50d" class="numbered-list" start="1"><li>LLVM 컴파일러 구조를 사용하는 C 계열 언어(C++, Object-C/C++, OpenCL, CUDA 등) 컴파일러 프론트엔드</li></ol><ol type="a" id="f18e69e3-8e8e-457a-af70-2174f472a1c0" class="numbered-list" start="2"><li>원래 애플이 개발하였으나 2007년 오픈소스로 된 뒤 마이크로소프트, 구글 등 다양한 대기업들이 개발에 참여</li></ol><ol type="a" id="ebceb1bf-3140-4003-919f-9569a1cac4e2" class="numbered-list" start="3"><li>GCC 컴파일러 대신 Clang을 쓰면 코드 변경이 거의 없어 그대로 컴파일되고 빠른 컴파일 속도와 LLVM 구조가 제공하는 유용한 기능 덕에 많은 GCC 사용자들이 Clang으로 이주 중</li></ol><ol type="a" id="107a4fc6-d674-4cb2-8e47-672d9392d1c9" class="numbered-list" start="4"><li>clang-ci라는 비주얼 C와 호환되는 프론트엔드 제공</li></ol></li></ul><ul id="ee4a31c6-bc0a-468d-8f18-d522e1996b10" class="bulleted-list"><li style="list-style-type:disc">기타 소형기기 전용 컴파일로도 많이 있음</li></ul><p id="abd5a732-5d4f-4da6-b0f9-e45d7cb2b089" class="">
    </p></div></article></body>

{% endblock post_content %}